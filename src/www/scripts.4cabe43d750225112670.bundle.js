webpackJsonp([2,5],{1478:function(e,n){e.exports='/*!\n * Cropper.js v1.0.0-beta.2\n * https://github.com/fengyuanchen/cropperjs\n *\n * Copyright (c) 2017 Fengyuan Chen\n * Released under the MIT license\n *\n * Date: 2017-02-25T07:36:34.540Z\n */\n\n!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):t.Cropper=e()}(this,function(){"use strict";function t(t){return rt.call(t).slice(8,-1).toLowerCase()}function e(t){return"number"==typeof t&&!isNaN(t)}function a(t){return"undefined"==typeof t}function i(t){return"object"===("undefined"==typeof t?"undefined":Z(t))&&null!==t}function o(t){if(!i(t))return!1;try{var e=t.constructor,a=e.prototype;return e&&a&&ht.call(a,"isPrototypeOf")}catch(t){return!1}}function n(e){return"function"===t(e)}function r(e){return Array.isArray?Array.isArray(e):"array"===t(e)}function h(t){return"string"==typeof t&&(t=t.trim?t.trim():t.replace(et,"$1")),t}function c(t,a){if(t&&n(a)){var o=void 0;if(r(t)||e(t.length)){var h=t.length;for(o=0;o<h&&a.call(t,t[o],o,t)!==!1;o++);}else i(t)&&Object.keys(t).forEach(function(e){a.call(t,t[e],e,t)})}return t}function s(t){for(var e=arguments.length,a=Array(e>1?e-1:0),o=1;o<e;o++)a[o-1]=arguments[o];if(i(t)&&a.length>0){if(Object.assign)return Object.assign.apply(Object,[t].concat(a));a.forEach(function(e){i(e)&&Object.keys(e).forEach(function(a){t[a]=e[a]})})}return t}function d(t,e){for(var a=arguments.length,i=Array(a>2?a-2:0),o=2;o<a;o++)i[o-2]=arguments[o];return function(){for(var a=arguments.length,o=Array(a),n=0;n<a;n++)o[n]=arguments[n];return t.apply(e,i.concat(o))}}function l(t,a){var i=t.style;c(a,function(t,a){tt.test(a)&&e(t)&&(t+="px"),i[a]=t})}function p(t,e){return t.classList?t.classList.contains(e):t.className.indexOf(e)>-1}function u(t,a){if(a){if(e(t.length))return void c(t,function(t){u(t,a)});if(t.classList)return void t.classList.add(a);var i=h(t.className);i?i.indexOf(a)<0&&(t.className=i+" "+a):t.className=a}}function m(t,a){if(a)return e(t.length)?void c(t,function(t){m(t,a)}):t.classList?void t.classList.remove(a):void(t.className.indexOf(a)>=0&&(t.className=t.className.replace(a,"")))}function f(t,a,i){if(a)return e(t.length)?void c(t,function(t){f(t,a,i)}):void(i?u(t,a):m(t,a))}function g(t){return t.replace(J,"$1-$2").toLowerCase()}function v(t,e){return i(t[e])?t[e]:t.dataset?t.dataset[e]:t.getAttribute("data-"+g(e))}function w(t,e,a){i(a)?t[e]=a:t.dataset?t.dataset[e]=a:t.setAttribute("data-"+g(e),a)}function b(t,e){if(i(t[e]))delete t[e];else if(t.dataset)try{delete t.dataset[e]}catch(a){t.dataset[e]=null}else t.removeAttribute("data-"+g(e))}function x(t,e,a){var i=h(e).split(_);return i.length>1?void c(i,function(e){x(t,e,a)}):void(t.removeEventListener?t.removeEventListener(e,a,!1):t.detachEvent&&t.detachEvent("on"+e,a))}function y(t,e,a,i){var o=h(e).split(_),n=a;return o.length>1?void c(o,function(e){y(t,e,a)}):(i&&(a=function(){for(var i=arguments.length,o=Array(i),r=0;r<i;r++)o[r]=arguments[r];return x(t,e,a),n.apply(t,o)}),void(t.addEventListener?t.addEventListener(e,a,!1):t.attachEvent&&t.attachEvent("on"+e,a)))}function M(t,e,i){if(t.dispatchEvent){var o=void 0;return n(Event)&&n(CustomEvent)?o=a(i)?new Event(e,{bubbles:!0,cancelable:!0}):new CustomEvent(e,{detail:i,bubbles:!0,cancelable:!0}):a(i)?(o=document.createEvent("Event"),o.initEvent(e,!0,!0)):(o=document.createEvent("CustomEvent"),o.initCustomEvent(e,!0,!0,i)),t.dispatchEvent(o)}return!t.fireEvent||t.fireEvent("on"+e)}function C(t){var a=t||window.event;if(a.target||(a.target=a.srcElement||document),!e(a.pageX)&&e(a.clientX)){var i=t.target.ownerDocument||document,o=i.documentElement,n=i.body;a.pageX=a.clientX+((o&&o.scrollLeft||n&&n.scrollLeft||0)-(o&&o.clientLeft||n&&n.clientLeft||0)),a.pageY=a.clientY+((o&&o.scrollTop||n&&n.scrollTop||0)-(o&&o.clientTop||n&&n.clientTop||0))}return a}function D(t){var e=document.documentElement,a=t.getBoundingClientRect();return{left:a.left+((window.scrollX||e&&e.scrollLeft||0)-(e&&e.clientLeft||0)),top:a.top+((window.scrollY||e&&e.scrollTop||0)-(e&&e.clientTop||0))}}function B(t,e){return t.getElementsByTagName(e)}function k(t,e){return t.getElementsByClassName?t.getElementsByClassName(e):t.querySelectorAll("."+e)}function T(t){return document.createElement(t)}function L(t,e){t.appendChild(e)}function W(t){t.parentNode&&t.parentNode.removeChild(t)}function X(t){for(;t.firstChild;)t.removeChild(t.firstChild)}function Y(t){var e=t.match(Q);return e&&(e[1]!==location.protocol||e[2]!==location.hostname||e[3]!==location.port)}function E(t){var e="timestamp="+(new Date).getTime();return t+(t.indexOf("?")===-1?"?":"&")+e}function H(t,e){if(t.naturalWidth&&!ot)return void e(t.naturalWidth,t.naturalHeight);var a=T("img");a.onload=function(){e(this.width,this.height)},a.src=t.src}function N(t){var a=[],i=t.translateX,o=t.translateY,n=t.rotate,r=t.scaleX,h=t.scaleY;e(i)&&0!==i&&a.push("translateX("+i+"px)"),e(o)&&0!==o&&a.push("translateY("+o+"px)"),e(n)&&0!==n&&a.push("rotate("+n+"deg)"),e(r)&&1!==r&&a.push("scaleX("+r+")"),e(h)&&1!==h&&a.push("scaleY("+h+")");var c=a.length?a.join(" "):"none";return{WebkitTransform:c,msTransform:c,transform:c}}function O(t,e){var a=Math.abs(t.degree)%180,i=(a>90?180-a:a)*Math.PI/180,o=Math.sin(i),n=Math.cos(i),r=t.width,h=t.height,c=t.aspectRatio,s=void 0,d=void 0;return e?(s=r/(n+o/c),d=s/c):(s=r*n+h*o,d=r*o+h*n),{width:s,height:d}}function z(t,a){var i=T("canvas"),o=i.getContext("2d"),n=0,r=0,h=a.naturalWidth,c=a.naturalHeight,s=a.rotate,d=a.scaleX,l=a.scaleY,p=e(d)&&e(l)&&(1!==d||1!==l),u=e(s)&&0!==s,m=u||p,f=h*Math.abs(d||1),g=c*Math.abs(l||1),v=void 0,w=void 0,b=void 0;return p&&(v=f/2,w=g/2),u&&(b=O({width:f,height:g,degree:s}),f=b.width,g=b.height,v=f/2,w=g/2),i.width=f,i.height=g,m&&(n=-h/2,r=-c/2,o.save(),o.translate(v,w)),u&&o.rotate(s*Math.PI/180),p&&o.scale(d,l),o.drawImage(t,Math.floor(n),Math.floor(r),Math.floor(h),Math.floor(c)),m&&o.restore(),i}function A(t,e,a){var i="",o=e;for(a+=e;o<a;o++)i+=ct(t.getUint8(o));return i}function R(t){var e=new DataView(t),a=e.byteLength,i=void 0,o=void 0,n=void 0,r=void 0,h=void 0,c=void 0,s=void 0,d=void 0,l=void 0,p=void 0;if(255===e.getUint8(0)&&216===e.getUint8(1))for(l=2;l<a;){if(255===e.getUint8(l)&&225===e.getUint8(l+1)){s=l;break}l++}if(s&&(o=s+4,n=s+10,"Exif"===A(e,o,4)&&(c=e.getUint16(n),h=18761===c,(h||19789===c)&&42===e.getUint16(n+2,h)&&(r=e.getUint32(n+4,h),r>=8&&(d=n+r)))),d)for(a=e.getUint16(d,h),p=0;p<a;p++)if(l=d+12*p+2,274===e.getUint16(l,h)){l+=8,i=e.getUint16(l,h),ot&&e.setUint16(l,1,h);break}return i}function S(t){var e=t.replace(G,""),a=atob(e),i=a.length,o=new ArrayBuffer(i),n=new Uint8Array(o),r=void 0;for(r=0;r<i;r++)n[r]=a.charCodeAt(r);return o}function I(t){var e=new Uint8Array(t),a=e.length,i="",o=void 0;for(o=0;o<a;o++)i+=ct(e[o]);return"data:image/jpeg;base64,"+btoa(i)}function U(t,e){var a=t.pageX,i=t.pageY,o={endX:a,endY:i};return e?o:s({startX:a,startY:i},o)}function j(t){var e=s({},t),a=[];return c(t,function(t,i){delete e[i],c(e,function(e){var i=Math.abs(t.startX-e.startX),o=Math.abs(t.startY-e.startY),n=Math.abs(t.endX-e.endX),r=Math.abs(t.endY-e.endY),h=Math.sqrt(i*i+o*o),c=Math.sqrt(n*n+r*r),s=(c-h)/h;a.push(s)})}),a.sort(function(t,e){return Math.abs(t)<Math.abs(e)}),a[0]}function P(t){var e=0,a=0,i=0;return c(t,function(t){var o=t.startX,n=t.startY;e+=o,a+=n,i+=1}),e/=i,a/=i,{pageX:e,pageY:a}}var q={viewMode:0,dragMode:"crop",aspectRatio:NaN,data:null,preview:"",responsive:!0,restore:!0,checkCrossOrigin:!0,checkOrientation:!0,modal:!0,guides:!0,center:!0,highlight:!0,background:!0,autoCrop:!0,autoCropArea:.8,movable:!0,rotatable:!0,scalable:!0,zoomable:!0,zoomOnTouch:!0,zoomOnWheel:!0,wheelZoomRatio:.1,cropBoxMovable:!0,cropBoxResizable:!0,toggleDragModeOnDblclick:!0,minCanvasWidth:0,minCanvasHeight:0,minCropBoxWidth:0,minCropBoxHeight:0,minContainerWidth:200,minContainerHeight:100,ready:null,cropstart:null,cropmove:null,cropend:null,crop:null,zoom:null},$=\'<div class="cropper-container"><div class="cropper-wrap-box"><div class="cropper-canvas"></div></div><div class="cropper-drag-box"></div><div class="cropper-crop-box"><span class="cropper-view-box"></span><span class="cropper-dashed dashed-h"></span><span class="cropper-dashed dashed-v"></span><span class="cropper-center"></span><span class="cropper-face"></span><span class="cropper-line line-e" data-action="e"></span><span class="cropper-line line-n" data-action="n"></span><span class="cropper-line line-w" data-action="w"></span><span class="cropper-line line-s" data-action="s"></span><span class="cropper-point point-e" data-action="e"></span><span class="cropper-point point-n" data-action="n"></span><span class="cropper-point point-w" data-action="w"></span><span class="cropper-point point-s" data-action="s"></span><span class="cropper-point point-ne" data-action="ne"></span><span class="cropper-point point-nw" data-action="nw"></span><span class="cropper-point point-sw" data-action="sw"></span><span class="cropper-point point-se" data-action="se"></span></div></div>\',Z="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},K=function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")},V=function(){function t(t,e){for(var a=0;a<e.length;a++){var i=e[a];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(e,a,i){return a&&t(e.prototype,a),i&&t(e,i),e}}(),F=function(t){if(Array.isArray(t)){for(var e=0,a=Array(t.length);e<t.length;e++)a[e]=t[e];return a}return Array.from(t)},G=/^data:.*,/,J=/([a-z\\d])([A-Z])/g,Q=/^(https?:)\\/\\/([^:\\/?#]+):?(\\d*)/i,_=/\\s+/,tt=/^(width|height|left|top|marginLeft|marginTop)$/,et=/^\\s+(.*)\\s+$/,at=/(Macintosh|iPhone|iPod|iPad).*AppleWebKit/i,it="undefined"!=typeof window?window.navigator:null,ot=it&&at.test(it.userAgent),nt=Object.prototype,rt=nt.toString,ht=nt.hasOwnProperty,ct=(Array.prototype.slice,String.fromCharCode),st={render:function(){var t=this;t.initContainer(),t.initCanvas(),t.initCropBox(),t.renderCanvas(),t.cropped&&t.renderCropBox()},initContainer:function(){var t=this,e=t.options,a=t.element,i=t.container,o=t.cropper,n="cropper-hidden",r=void 0;u(o,n),m(a,n),t.containerData=r={width:Math.max(i.offsetWidth,Number(e.minContainerWidth)||200),height:Math.max(i.offsetHeight,Number(e.minContainerHeight)||100)},l(o,{width:r.width,height:r.height}),u(a,n),m(o,n)},initCanvas:function(){var t=this,e=t.options.viewMode,a=t.containerData,i=t.imageData,o=90===Math.abs(i.rotate),n=o?i.naturalHeight:i.naturalWidth,r=o?i.naturalWidth:i.naturalHeight,h=n/r,c=a.width,d=a.height;a.height*h>a.width?3===e?c=a.height*h:d=a.width/h:3===e?d=a.width/h:c=a.height*h;var l={naturalWidth:n,naturalHeight:r,aspectRatio:h,width:c,height:d};l.oldLeft=l.left=(a.width-c)/2,l.oldTop=l.top=(a.height-d)/2,t.canvasData=l,t.limited=1===e||2===e,t.limitCanvas(!0,!0),t.initialImageData=s({},i),t.initialCanvasData=s({},l)},limitCanvas:function(t,e){var a=this,i=a.options,o=i.viewMode,n=a.containerData,r=a.canvasData,h=r.aspectRatio,c=a.cropBoxData,s=a.cropped&&c;if(t){var d=Number(i.minCanvasWidth)||0,l=Number(i.minCanvasHeight)||0;o>1?(d=Math.max(d,n.width),l=Math.max(l,n.height),3===o&&(l*h>d?d=l*h:l=d/h)):o>0&&(d?d=Math.max(d,s?c.width:0):l?l=Math.max(l,s?c.height:0):s&&(d=c.width,l=c.height,l*h>d?d=l*h:l=d/h)),d&&l?l*h>d?l=d/h:d=l*h:d?l=d/h:l&&(d=l*h),r.minWidth=d,r.minHeight=l,r.maxWidth=1/0,r.maxHeight=1/0}if(e)if(o){var p=n.width-r.width,u=n.height-r.height;r.minLeft=Math.min(0,p),r.minTop=Math.min(0,u),r.maxLeft=Math.max(0,p),r.maxTop=Math.max(0,u),s&&a.limited&&(r.minLeft=Math.min(c.left,c.left+(c.width-r.width)),r.minTop=Math.min(c.top,c.top+(c.height-r.height)),r.maxLeft=c.left,r.maxTop=c.top,2===o&&(r.width>=n.width&&(r.minLeft=Math.min(0,p),r.maxLeft=Math.max(0,p)),r.height>=n.height&&(r.minTop=Math.min(0,u),r.maxTop=Math.max(0,u))))}else r.minLeft=-r.width,r.minTop=-r.height,r.maxLeft=n.width,r.maxTop=n.height},renderCanvas:function(t){var e=this,a=e.canvasData,i=e.imageData,o=i.rotate;if(e.rotated){e.rotated=!1;var n=O({width:i.width,height:i.height,degree:o}),r=n.width/n.height,h=1===i.aspectRatio;if(h||r!==a.aspectRatio){if(a.left-=(n.width-a.width)/2,a.top-=(n.height-a.height)/2,a.width=n.width,a.height=n.height,a.aspectRatio=r,a.naturalWidth=i.naturalWidth,a.naturalHeight=i.naturalHeight,h&&o%90||o%180){var c=O({width:i.naturalWidth,height:i.naturalHeight,degree:o});a.naturalWidth=c.width,a.naturalHeight=c.height}e.limitCanvas(!0,!1)}}(a.width>a.maxWidth||a.width<a.minWidth)&&(a.left=a.oldLeft),(a.height>a.maxHeight||a.height<a.minHeight)&&(a.top=a.oldTop),a.width=Math.min(Math.max(a.width,a.minWidth),a.maxWidth),a.height=Math.min(Math.max(a.height,a.minHeight),a.maxHeight),e.limitCanvas(!1,!0),a.oldLeft=a.left=Math.min(Math.max(a.left,a.minLeft),a.maxLeft),a.oldTop=a.top=Math.min(Math.max(a.top,a.minTop),a.maxTop),l(e.canvas,s({width:a.width,height:a.height},N({translateX:a.left,translateY:a.top}))),e.renderImage(),e.cropped&&e.limited&&e.limitCropBox(!0,!0),t&&e.output()},renderImage:function(t){var e=this,a=e.canvasData,i=e.imageData,o=void 0,n=void 0,r=void 0,h=void 0;i.rotate&&(n=O({width:a.width,height:a.height,degree:i.rotate,aspectRatio:i.aspectRatio},!0),r=n.width,h=n.height,o={width:r,height:h,left:(a.width-r)/2,top:(a.height-h)/2}),s(i,o||{width:a.width,height:a.height,left:0,top:0}),l(e.image,s({width:i.width,height:i.height},N(s({translateX:i.left,translateY:i.top},i)))),t&&e.output()},initCropBox:function(){var t=this,e=t.options,a=e.aspectRatio,i=Number(e.autoCropArea)||.8,o=t.canvasData,n={width:o.width,height:o.height};a&&(o.height*a>o.width?n.height=n.width/a:n.width=n.height*a),t.cropBoxData=n,t.limitCropBox(!0,!0),n.width=Math.min(Math.max(n.width,n.minWidth),n.maxWidth),n.height=Math.min(Math.max(n.height,n.minHeight),n.maxHeight),n.width=Math.max(n.minWidth,n.width*i),n.height=Math.max(n.minHeight,n.height*i),n.oldLeft=n.left=o.left+(o.width-n.width)/2,n.oldTop=n.top=o.top+(o.height-n.height)/2,t.initialCropBoxData=s({},n)},limitCropBox:function(t,e){var a=this,i=a.options,o=i.aspectRatio,n=a.containerData,r=a.canvasData,h=a.cropBoxData,c=a.limited;if(t){var s=Number(i.minCropBoxWidth)||0,d=Number(i.minCropBoxHeight)||0,l=Math.min(n.width,c?r.width:n.width),p=Math.min(n.height,c?r.height:n.height);s=Math.min(s,n.width),d=Math.min(d,n.height),o&&(s&&d?d*o>s?d=s/o:s=d*o:s?d=s/o:d&&(s=d*o),p*o>l?p=l/o:l=p*o),h.minWidth=Math.min(s,l),h.minHeight=Math.min(d,p),h.maxWidth=l,h.maxHeight=p}e&&(c?(h.minLeft=Math.max(0,r.left),h.minTop=Math.max(0,r.top),h.maxLeft=Math.min(n.width,r.left+r.width)-h.width,h.maxTop=Math.min(n.height,r.top+r.height)-h.height):(h.minLeft=0,h.minTop=0,h.maxLeft=n.width-h.width,h.maxTop=n.height-h.height))},renderCropBox:function(){var t=this,e=t.options,a=t.containerData,i=t.cropBoxData;(i.width>i.maxWidth||i.width<i.minWidth)&&(i.left=i.oldLeft),(i.height>i.maxHeight||i.height<i.minHeight)&&(i.top=i.oldTop),i.width=Math.min(Math.max(i.width,i.minWidth),i.maxWidth),i.height=Math.min(Math.max(i.height,i.minHeight),i.maxHeight),t.limitCropBox(!1,!0),i.oldLeft=i.left=Math.min(Math.max(i.left,i.minLeft),i.maxLeft),i.oldTop=i.top=Math.min(Math.max(i.top,i.minTop),i.maxTop),e.movable&&e.cropBoxMovable&&w(t.face,"action",i.width===a.width&&i.height===a.height?"move":"all"),l(t.cropBox,s({width:i.width,height:i.height},N({translateX:i.left,translateY:i.top}))),t.cropped&&t.limited&&t.limitCanvas(!0,!0),t.disabled||t.output()},output:function(){var t=this;t.preview(),t.complete&&M(t.element,"crop",t.getData())}},dt="preview",lt={initPreview:function(){var t=this,e=t.options.preview,a=T("img"),i=t.crossOrigin,o=i?t.crossOriginUrl:t.url;if(i&&(a.crossOrigin=i),a.src=o,L(t.viewBox,a),t.image2=a,e){var n=e.querySelector?[e]:document.querySelectorAll(e);t.previews=n,c(n,function(t){var e=T("img");w(t,dt,{width:t.offsetWidth,height:t.offsetHeight,html:t.innerHTML}),i&&(e.crossOrigin=i),e.src=o,e.style.cssText=\'display:block;width:100%;height:auto;min-width:0!important;min-height:0!important;max-width:none!important;max-height:none!important;image-orientation:0deg!important;"\',X(t),L(t,e)})}},resetPreview:function(){c(this.previews,function(t){var e=v(t,dt);l(t,{width:e.width,height:e.height}),t.innerHTML=e.html,b(t,dt)})},preview:function(){var t=this,e=t.imageData,a=t.canvasData,i=t.cropBoxData,o=i.width,n=i.height,r=e.width,h=e.height,d=i.left-a.left-e.left,p=i.top-a.top-e.top;t.cropped&&!t.disabled&&(l(t.image2,s({width:r,height:h},N(s({translateX:-d,translateY:-p},e)))),c(t.previews,function(t){var a=v(t,dt),i=a.width,c=a.height,u=i,m=c,f=1;o&&(f=i/o,m=n*f),n&&m>c&&(f=c/n,u=o*f,m=c),l(t,{width:u,height:m}),l(B(t,"img")[0],s({width:r*f,height:h*f},N(s({translateX:-d*f,translateY:-p*f},e))))}))}},pt="undefined"!=typeof window?window.PointerEvent:null,ut=pt?"pointerdown":"touchstart mousedown",mt=pt?"pointermove":"touchmove mousemove",ft=pt?" pointerup pointercancel":"touchend touchcancel mouseup",gt="wheel mousewheel DOMMouseScroll",vt="dblclick",wt="resize",bt="cropstart",xt="cropmove",yt="cropend",Mt="crop",Ct="zoom",Dt={bind:function(){var t=this,e=t.options,a=t.element,i=t.cropper;n(e.cropstart)&&y(a,bt,e.cropstart),n(e.cropmove)&&y(a,xt,e.cropmove),n(e.cropend)&&y(a,yt,e.cropend),n(e.crop)&&y(a,Mt,e.crop),n(e.zoom)&&y(a,Ct,e.zoom),y(i,ut,t.onCropStart=d(t.cropStart,t)),e.zoomable&&e.zoomOnWheel&&y(i,gt,t.onWheel=d(t.wheel,t)),e.toggleDragModeOnDblclick&&y(i,vt,t.onDblclick=d(t.dblclick,t)),y(document,mt,t.onCropMove=d(t.cropMove,t)),y(document,ft,t.onCropEnd=d(t.cropEnd,t)),e.responsive&&y(window,wt,t.onResize=d(t.resize,t))},unbind:function(){var t=this,e=t.options,a=t.element,i=t.cropper;n(e.cropstart)&&x(a,bt,e.cropstart),n(e.cropmove)&&x(a,xt,e.cropmove),n(e.cropend)&&x(a,yt,e.cropend),n(e.crop)&&x(a,Mt,e.crop),n(e.zoom)&&x(a,Ct,e.zoom),x(i,ut,t.onCropStart),e.zoomable&&e.zoomOnWheel&&x(i,gt,t.onWheel),e.toggleDragModeOnDblclick&&x(i,vt,t.onDblclick),x(document,mt,t.onCropMove),x(document,ft,t.onCropEnd),e.responsive&&x(window,wt,t.onResize)}},Bt=/^(e|w|s|n|se|sw|ne|nw|all|crop|move|zoom)$/,kt={resize:function(){var t=this,e=t.options.restore,a=t.container,i=t.containerData;if(!t.disabled&&i){var o=a.offsetWidth/i.width,n=void 0,r=void 0;1===o&&a.offsetHeight===i.height||(e&&(n=t.getCanvasData(),r=t.getCropBoxData()),t.render(),e&&(t.setCanvasData(c(n,function(t,e){n[e]=t*o})),t.setCropBoxData(c(r,function(t,e){r[e]=t*o}))))}},dblclick:function(){var t=this;t.disabled||t.setDragMode(p(t.dragBox,"cropper-crop")?"move":"crop")},wheel:function(t){var e=this,a=C(t),i=Number(e.options.wheelZoomRatio)||.1,o=1;e.disabled||(a.preventDefault(),e.wheeling||(e.wheeling=!0,setTimeout(function(){e.wheeling=!1},50),a.deltaY?o=a.deltaY>0?1:-1:a.wheelDelta?o=-a.wheelDelta/120:a.detail&&(o=a.detail>0?1:-1),e.zoom(-o*i,a)))},cropStart:function(t){var e=this;if(!e.disabled){var a=e.options,i=e.pointers,o=C(t),n=void 0;if(o.changedTouches?c(o.changedTouches,function(t){i[t.identifier]=U(t)}):i[o.pointerId||0]=U(o),n=Object.keys(i).length>1&&a.zoomable&&a.zoomOnTouch?"zoom":v(o.target,"action"),Bt.test(n)){if(M(e.element,"cropstart",{originalEvent:o,action:n})===!1)return;o.preventDefault(),e.action=n,e.cropping=!1,"crop"===n&&(e.cropping=!0,u(e.dragBox,"cropper-modal"))}}},cropMove:function(t){var e=this,a=e.action;if(!e.disabled&&a){var i=e.pointers,o=C(t);o.preventDefault(),M(e.element,"cropmove",{originalEvent:o,action:a})!==!1&&(o.changedTouches?c(o.changedTouches,function(t){s(i[t.identifier],U(t,!0))}):s(i[o.pointerId||0],U(o,!0)),e.change(o))}},cropEnd:function(t){var e=this,a=e.action;if(!e.disabled&&a){var i=e.pointers,o=C(t);o.preventDefault(),o.changedTouches?c(o.changedTouches,function(t){delete i[t.identifier]}):delete i[o.pointerId||0],Object.keys(i).length||(e.action=""),e.cropping&&(e.cropping=!1,f(e.dragBox,"cropper-modal",e.cropped&&this.options.modal)),M(e.element,"cropend",{originalEvent:o,action:a})}}},Tt="e",Lt="w",Wt="s",Xt="n",Yt="se",Et="sw",Ht="ne",Nt="nw",Ot={change:function(t){var e=this,a=e.options,i=e.containerData,o=e.canvasData,n=e.cropBoxData,r=a.aspectRatio,h=e.action,s=n.width,d=n.height,l=n.left,p=n.top,u=l+s,f=p+d,g=0,v=0,w=i.width,b=i.height,x=!0,y=void 0;!r&&t.shiftKey&&(r=s&&d?s/d:1),e.limited&&(g=n.minLeft,v=n.minTop,w=g+Math.min(i.width,o.width,o.left+o.width),b=v+Math.min(i.height,o.height,o.top+o.height));var M=e.pointers,C=M[Object.keys(M)[0]],B={x:C.endX-C.startX,y:C.endY-C.startY};switch(r&&(B.X=B.y*r,B.Y=B.x/r),h){case"all":l+=B.x,p+=B.y;break;case Tt:if(B.x>=0&&(u>=w||r&&(p<=v||f>=b))){x=!1;break}s+=B.x,r&&(d=s/r,p-=B.Y/2),s<0&&(h=Lt,s=0);break;case Xt:if(B.y<=0&&(p<=v||r&&(l<=g||u>=w))){x=!1;break}d-=B.y,p+=B.y,r&&(s=d*r,l+=B.X/2),d<0&&(h=Wt,d=0);break;case Lt:if(B.x<=0&&(l<=g||r&&(p<=v||f>=b))){x=!1;break}s-=B.x,l+=B.x,r&&(d=s/r,p+=B.Y/2),s<0&&(h=Tt,s=0);break;case Wt:if(B.y>=0&&(f>=b||r&&(l<=g||u>=w))){x=!1;break}d+=B.y,r&&(s=d*r,l-=B.X/2),d<0&&(h=Xt,d=0);break;case Ht:if(r){if(B.y<=0&&(p<=v||u>=w)){x=!1;break}d-=B.y,p+=B.y,s=d*r}else B.x>=0?u<w?s+=B.x:B.y<=0&&p<=v&&(x=!1):s+=B.x,B.y<=0?p>v&&(d-=B.y,p+=B.y):(d-=B.y,p+=B.y);s<0&&d<0?(h=Et,d=0,s=0):s<0?(h=Nt,s=0):d<0&&(h=Yt,d=0);break;case Nt:if(r){if(B.y<=0&&(p<=v||l<=g)){x=!1;break}d-=B.y,p+=B.y,s=d*r,l+=B.X}else B.x<=0?l>g?(s-=B.x,l+=B.x):B.y<=0&&p<=v&&(x=!1):(s-=B.x,l+=B.x),B.y<=0?p>v&&(d-=B.y,p+=B.y):(d-=B.y,p+=B.y);s<0&&d<0?(h=Yt,d=0,s=0):s<0?(h=Ht,s=0):d<0&&(h=Et,d=0);break;case Et:if(r){if(B.x<=0&&(l<=g||f>=b)){x=!1;break}s-=B.x,l+=B.x,d=s/r}else B.x<=0?l>g?(s-=B.x,l+=B.x):B.y>=0&&f>=b&&(x=!1):(s-=B.x,l+=B.x),B.y>=0?f<b&&(d+=B.y):d+=B.y;s<0&&d<0?(h=Ht,d=0,s=0):s<0?(h=Yt,s=0):d<0&&(h=Nt,d=0);break;case Yt:if(r){if(B.x>=0&&(u>=w||f>=b)){x=!1;break}s+=B.x,d=s/r}else B.x>=0?u<w?s+=B.x:B.y>=0&&f>=b&&(x=!1):s+=B.x,B.y>=0?f<b&&(d+=B.y):d+=B.y;s<0&&d<0?(h=Nt,d=0,s=0):s<0?(h=Et,s=0):d<0&&(h=Ht,d=0);break;case"move":e.move(B.x,B.y),x=!1;break;case"zoom":e.zoom(j(M),t),x=!1;break;case"crop":if(!B.x||!B.y){x=!1;break}y=D(e.cropper),l=C.startX-y.left,p=C.startY-y.top,s=n.minWidth,d=n.minHeight,B.x>0?h=B.y>0?Yt:Ht:B.x<0&&(l-=s,h=B.y>0?Et:Nt),B.y<0&&(p-=d),e.cropped||(m(e.cropBox,"cropper-hidden"),e.cropped=!0,e.limited&&e.limitCropBox(!0,!0))}x&&(n.width=s,n.height=d,n.left=l,n.top=p,e.action=h,e.renderCropBox()),c(M,function(t){t.startX=t.endX,t.startY=t.endY})}},zt={crop:function(){var t=this;return t.ready&&!t.disabled&&(t.cropped||(t.cropped=!0,t.limitCropBox(!0,!0),t.options.modal&&u(t.dragBox,"cropper-modal"),m(t.cropBox,"cropper-hidden")),t.setCropBoxData(t.initialCropBoxData)),t},reset:function(){var t=this;return t.ready&&!t.disabled&&(t.imageData=s({},t.initialImageData),t.canvasData=s({},t.initialCanvasData),t.cropBoxData=s({},t.initialCropBoxData),t.renderCanvas(),t.cropped&&t.renderCropBox()),t},clear:function(){var t=this;return t.cropped&&!t.disabled&&(s(t.cropBoxData,{left:0,top:0,width:0,height:0}),t.cropped=!1,t.renderCropBox(),t.limitCanvas(),t.renderCanvas(),m(t.dragBox,"cropper-modal"),u(t.cropBox,"cropper-hidden")),t},replace:function(t,e){var a=this;return!a.disabled&&t&&(a.isImg&&(a.element.src=t),e?(a.url=t,a.image.src=t,a.ready&&(a.image2.src=t,c(a.previews,function(e){B(e,"img")[0].src=t}))):(a.isImg&&(a.replaced=!0),a.options.data=null,a.load(t))),a},enable:function(){var t=this;return t.ready&&(t.disabled=!1,m(t.cropper,"cropper-disabled")),t},disable:function(){var t=this;return t.ready&&(t.disabled=!0,u(t.cropper,"cropper-disabled")),t},destroy:function(){var t=this,e=t.element,a=t.image;return t.loaded?(t.isImg&&t.replaced&&(e.src=t.originalUrl),t.unbuild(),m(e,"cropper-hidden")):t.isImg?x(e,"load",t.onStart):a&&W(a),b(e,"cropper"),t},move:function(t,e){var i=this,o=i.canvasData;return i.moveTo(a(t)?t:o.left+Number(t),a(e)?e:o.top+Number(e))},moveTo:function(t,i){var o=this,n=o.canvasData,r=!1;return a(i)&&(i=t),t=Number(t),i=Number(i),o.ready&&!o.disabled&&o.options.movable&&(e(t)&&(n.left=t,r=!0),e(i)&&(n.top=i,r=!0),r&&o.renderCanvas(!0)),o},zoom:function(t,e){var a=this,i=a.canvasData;return t=Number(t),t=t<0?1/(1-t):1+t,a.zoomTo(i.width*t/i.naturalWidth,e)},zoomTo:function(t,e){var a=this,i=a.options,o=a.canvasData,n=o.width,r=o.height,h=o.naturalWidth,c=o.naturalHeight;if(t=Number(t),t>=0&&a.ready&&!a.disabled&&i.zoomable){var s=h*t,d=c*t;if(M(a.element,"zoom",{originalEvent:e,oldRatio:n/h,ratio:s/h})===!1)return a;if(e){var l=a.pointers,p=D(a.cropper),u=l&&Object.keys(l).length?P(l):{pageX:e.pageX,pageY:e.pageY};o.left-=(s-n)*((u.pageX-p.left-o.left)/n),o.top-=(d-r)*((u.pageY-p.top-o.top)/r)}else o.left-=(s-n)/2,o.top-=(d-r)/2;o.width=s,o.height=d,a.renderCanvas(!0)}return a},rotate:function(t){var e=this;return e.rotateTo((e.imageData.rotate||0)+Number(t))},rotateTo:function(t){var a=this;return t=Number(t),e(t)&&a.ready&&!a.disabled&&a.options.rotatable&&(a.imageData.rotate=t%360,a.rotated=!0,a.renderCanvas(!0)),a},scale:function(t,i){var o=this,n=o.imageData,r=!1;return a(i)&&(i=t),t=Number(t),i=Number(i),o.ready&&!o.disabled&&o.options.scalable&&(e(t)&&(n.scaleX=t,r=!0),e(i)&&(n.scaleY=i,r=!0),r&&o.renderImage(!0)),o},scaleX:function(t){var a=this,i=a.imageData.scaleY;return a.scale(t,e(i)?i:1)},scaleY:function(t){var a=this,i=a.imageData.scaleX;return a.scale(e(i)?i:1,t)},getData:function(t){var e=this,a=e.options,i=e.imageData,o=e.canvasData,n=e.cropBoxData,r=void 0,h=void 0;return e.ready&&e.cropped?(h={x:n.left-o.left,y:n.top-o.top,width:n.width,height:n.height},r=i.width/i.naturalWidth,c(h,function(e,a){e/=r,h[a]=t?Math.round(e):e})):h={x:0,y:0,width:0,height:0},a.rotatable&&(h.rotate=i.rotate||0),a.scalable&&(h.scaleX=i.scaleX||1,h.scaleY=i.scaleY||1),h},setData:function(t){var a=this,i=a.options,r=a.imageData,h=a.canvasData,c={},s=void 0,d=void 0,l=void 0;return n(t)&&(t=t.call(a.element)),a.ready&&!a.disabled&&o(t)&&(i.rotatable&&e(t.rotate)&&t.rotate!==r.rotate&&(r.rotate=t.rotate,a.rotated=s=!0),i.scalable&&(e(t.scaleX)&&t.scaleX!==r.scaleX&&(r.scaleX=t.scaleX,d=!0),e(t.scaleY)&&t.scaleY!==r.scaleY&&(r.scaleY=t.scaleY,d=!0)),s?a.renderCanvas():d&&a.renderImage(),l=r.width/r.naturalWidth,e(t.x)&&(c.left=t.x*l+h.left),e(t.y)&&(c.top=t.y*l+h.top),e(t.width)&&(c.width=t.width*l),e(t.height)&&(c.height=t.height*l),a.setCropBoxData(c)),a},getContainerData:function(){var t=this;return t.ready?t.containerData:{}},getImageData:function(){var t=this;return t.loaded?t.imageData:{}},getCanvasData:function(){var t=this,e=t.canvasData,a={};return t.ready&&c(["left","top","width","height","naturalWidth","naturalHeight"],function(t){a[t]=e[t]}),a},setCanvasData:function(t){var a=this,i=a.canvasData,r=i.aspectRatio;return n(t)&&(t=t.call(a.element)),a.ready&&!a.disabled&&o(t)&&(e(t.left)&&(i.left=t.left),e(t.top)&&(i.top=t.top),e(t.width)?(i.width=t.width,i.height=t.width/r):e(t.height)&&(i.height=t.height,i.width=t.height*r),a.renderCanvas(!0)),a},getCropBoxData:function(){var t=this,e=t.cropBoxData,a=void 0;return t.ready&&t.cropped&&(a={left:e.left,top:e.top,width:e.width,height:e.height}),a||{}},setCropBoxData:function(t){var a=this,i=a.cropBoxData,r=a.options.aspectRatio,h=void 0,c=void 0;return n(t)&&(t=t.call(a.element)),a.ready&&a.cropped&&!a.disabled&&o(t)&&(e(t.left)&&(i.left=t.left),e(t.top)&&(i.top=t.top),e(t.width)&&t.width!==i.width&&(h=!0,i.width=t.width),e(t.height)&&t.height!==i.height&&(c=!0,i.height=t.height),r&&(h?i.height=i.width/r:c&&(i.width=i.height*r)),a.renderCropBox()),a},getCroppedCanvas:function(t){var e=this;if(!e.ready||!window.HTMLCanvasElement)return null;if(!e.cropped)return z(e.image,e.imageData);o(t)||(t={});var a=e.getData(),i=a.width,n=a.height,r=i/n,h=void 0,c=void 0,s=void 0;o(t)&&(h=t.width,c=t.height,h?(c=h/r,s=h/i):c&&(h=c*r,s=c/n));var d=Math.floor(h||i),l=Math.floor(c||n),p=T("canvas"),u=p.getContext("2d");p.width=d,p.height=l,t.fillColor&&(u.fillStyle=t.fillColor,u.fillRect(0,0,d,l));var m=function(){var t=z(e.image,e.imageData),o=t.width,r=t.height,h=e.canvasData,c=[t],d=a.x+h.naturalWidth*(Math.abs(a.scaleX||1)-1)/2,l=a.y+h.naturalHeight*(Math.abs(a.scaleY||1)-1)/2,p=void 0,u=void 0,m=void 0,f=void 0,g=void 0,v=void 0;return d<=-i||d>o?d=p=m=g=0:d<=0?(m=-d,d=0,p=g=Math.min(o,i+d)):d<=o&&(m=0,p=g=Math.min(i,o-d)),p<=0||l<=-n||l>r?l=u=f=v=0:l<=0?(f=-l,l=0,u=v=Math.min(r,n+l)):l<=r&&(f=0,u=v=Math.min(n,r-l)),c.push(Math.floor(d),Math.floor(l),Math.floor(p),Math.floor(u)),s&&(m*=s,f*=s,g*=s,v*=s),g>0&&v>0&&c.push(Math.floor(m),Math.floor(f),Math.floor(g),Math.floor(v)),c}();return u.drawImage.apply(u,F(m)),p},setAspectRatio:function(t){var e=this,i=e.options;return e.disabled||a(t)||(i.aspectRatio=Math.max(0,t)||NaN,e.ready&&(e.initCropBox(),e.cropped&&e.renderCropBox())),e},setDragMode:function(t){var e=this,a=e.options,i=e.dragBox,o=e.face,n=void 0,r=void 0;return e.loaded&&!e.disabled&&(n="crop"===t,r=a.movable&&"move"===t,t=n||r?t:"none",w(i,"action",t),f(i,"cropper-crop",n),f(i,"cropper-move",r),a.cropBoxMovable||(w(o,"action",t),f(o,"cropper-crop",n),f(o,"cropper-move",r))),e}},At="cropper",Rt=At+"-hidden",St="error",It="load",Ut="ready",jt="crop",Pt=/^data:/,qt=/^data:image\\/jpeg;base64,/,$t=void 0,Zt=function(){function t(e,a){K(this,t);var i=this;i.element=e,i.options=s({},q,o(a)&&a),i.loaded=!1,i.ready=!1,i.complete=!1,i.rotated=!1,i.cropped=!1,i.disabled=!1,i.replaced=!1,i.limited=!1,i.wheeling=!1,i.isImg=!1,i.originalUrl="",i.canvasData=null,i.cropBoxData=null,i.previews=null,i.pointers={},i.init()}return V(t,[{key:"init",value:function(){var t=this,e=t.element,a=e.tagName.toLowerCase(),i=void 0;if(!v(e,At)){if(w(e,At,t),"img"===a){if(t.isImg=!0,t.originalUrl=i=e.getAttribute("src"),!i)return;i=e.src}else"canvas"===a&&window.HTMLCanvasElement&&(i=e.toDataURL());t.load(i)}}},{key:"load",value:function(t){var e=this,a=e.options,i=e.element;if(t){if(e.url=t,e.imageData={},!a.checkOrientation||!window.ArrayBuffer)return void e.clone();if(Pt.test(t))return void(qt?e.read(S(t)):e.clone());var o=new XMLHttpRequest;o.onerror=o.onabort=function(){e.clone()},o.onload=function(){e.read(o.response)},a.checkCrossOrigin&&Y(t)&&i.crossOrigin&&(t=E(t)),o.open("get",t),o.responseType="arraybuffer",o.withCredentials="use-credentials"===i.crossOrigin,o.send()}}},{key:"read",value:function(t){var e=this,a=e.options,i=R(t),o=e.imageData,n=0,r=1,h=1;if(i>1)switch(e.url=I(t),i){case 2:r=-1;break;case 3:n=-180;break;case 4:h=-1;break;case 5:n=90,h=-1;break;case 6:n=90;break;case 7:n=90,r=-1;break;case 8:n=-90}a.rotatable&&(o.rotate=n),a.scalable&&(o.scaleX=r,o.scaleY=h),e.clone()}},{key:"clone",value:function(){var t=this,e=t.element,a=t.url,i=void 0,o=void 0,n=void 0,r=void 0;t.options.checkCrossOrigin&&Y(a)&&(i=e.crossOrigin,i?o=a:(i="anonymous",o=E(a))),t.crossOrigin=i,t.crossOriginUrl=o;var h=T("img");i&&(h.crossOrigin=i),h.src=o||a,t.image=h,t.onStart=n=d(t.start,t),t.onStop=r=d(t.stop,t),t.isImg?e.complete?t.start():y(e,It,n):(y(h,It,n),y(h,St,r),u(h,"cropper-hide"),e.parentNode.insertBefore(h,e.nextSibling))}},{key:"start",value:function(t){var e=this,a=e.isImg?e.element:e.image;t&&(x(a,It,e.onStart),x(a,St,e.onStop)),H(a,function(t,a){s(e.imageData,{naturalWidth:t,naturalHeight:a,aspectRatio:t/a}),e.loaded=!0,e.build()})}},{key:"stop",value:function(){var t=this,e=t.image;x(e,It,t.onStart),x(e,St,t.onStop),W(e),t.image=null}},{key:"build",value:function(){var t=this,e=t.options,a=t.element,i=t.image,o=void 0,r=void 0,h=void 0,c=void 0,s=void 0,d=void 0;if(t.loaded){t.ready&&t.unbuild();var l=T("div");l.innerHTML=$,t.container=o=a.parentNode,t.cropper=r=k(l,"cropper-container")[0],t.canvas=h=k(r,"cropper-canvas")[0],t.dragBox=c=k(r,"cropper-drag-box")[0],t.cropBox=s=k(r,"cropper-crop-box")[0],t.viewBox=k(r,"cropper-view-box")[0],t.face=d=k(s,"cropper-face")[0],L(h,i),u(a,Rt),o.insertBefore(r,a.nextSibling),t.isImg||m(i,"cropper-hide"),t.initPreview(),t.bind(),e.aspectRatio=Math.max(0,e.aspectRatio)||NaN,e.viewMode=Math.max(0,Math.min(3,Math.round(e.viewMode)))||0,t.cropped=e.autoCrop,e.autoCrop?e.modal&&u(c,"cropper-modal"):u(s,Rt),e.guides||u(k(s,"cropper-dashed"),Rt),e.center||u(k(s,"cropper-center"),Rt),e.background&&u(r,"cropper-bg"),\ne.highlight||u(d,"cropper-invisible"),e.cropBoxMovable&&(u(d,"cropper-move"),w(d,"action","all")),e.cropBoxResizable||(u(k(s,"cropper-line"),Rt),u(k(s,"cropper-point"),Rt)),t.setDragMode(e.dragMode),t.render(),t.ready=!0,t.setData(e.data),t.completing=setTimeout(function(){n(e.ready)&&y(a,Ut,e.ready,!0),M(a,Ut),M(a,jt,t.getData()),t.complete=!0},0)}}},{key:"unbuild",value:function(){var t=this;t.ready&&(t.complete||clearTimeout(t.completing),t.ready=!1,t.complete=!1,t.initialImageData=null,t.initialCanvasData=null,t.initialCropBoxData=null,t.containerData=null,t.canvasData=null,t.cropBoxData=null,t.unbind(),t.resetPreview(),t.previews=null,t.viewBox=null,t.cropBox=null,t.dragBox=null,t.canvas=null,t.container=null,W(t.cropper),t.cropper=null)}}],[{key:"noConflict",value:function(){return window.Cropper=$t,t}},{key:"setDefaults",value:function(t){s(q,o(t)&&t)}}]),t}();return s(Zt.prototype,st),s(Zt.prototype,lt),s(Zt.prototype,Dt),s(Zt.prototype,kt),s(Zt.prototype,Ot),s(Zt.prototype,zt),"undefined"!=typeof window&&($t=window.Cropper,window.Cropper=Zt),Zt});'},1479:function(e,n){e.exports="/**\n * Created by jiuyuong on 2016/8/13.\n */\n(function (r) {\n  'use strict';\n\n    var crc32 = (function() {\n      var table = [],\n        poly = 0xEDB88320; // reverse polynomial\n\n      // build the table\n      function makeTable() {\n        var c, n, k;\n\n        for (n = 0; n < 256; n += 1) {\n          c = n;\n          for (k = 0; k < 8; k += 1) {\n            if (c & 1) {\n              c = poly ^ (c >>> 1);\n            } else {\n              c = c >>> 1;\n            }\n          }\n          table[n] = c >>> 0;\n        }\n      }\n\n      function strToArr(str) {\n        // sweet hack to turn string into a 'byte' array\n        return Array.prototype.map.call(str, function (c) {\n          return c.charCodeAt(0);\n        });\n      }\n\n      /*\n       * Compute CRC of array directly.\n       *\n       * This is slower for repeated calls, so append mode is not supported.\n       */\n      function crcDirect(arr) {\n        var crc = -1, // initial contents of LFBSR\n          i, j, l, temp;\n\n        for (i = 0, l = arr.length; i < l; i += 1) {\n          temp = (crc ^ arr[i]) & 0xff;\n\n          // read 8 bits one at a time\n          for (j = 0; j < 8; j += 1) {\n            if ((temp & 1) === 1) {\n              temp = (temp >>> 1) ^ poly;\n            } else {\n              temp = (temp >>> 1);\n            }\n          }\n          crc = (crc >>> 8) ^ temp;\n        }\n\n        // flip bits\n        return crc ^ -1;\n      }\n\n      /*\n       * Compute CRC with the help of a pre-calculated table.\n       *\n       * This supports append mode, if the second parameter is set.\n       */\n      function crcTable(arr, append) {\n        var crc, i, l;\n\n        // if we're in append mode, don't reset crc\n        // if arr is null or undefined, reset table and return\n        if (typeof crcTable.crc === 'undefined' || !append || !arr) {\n          crcTable.crc = 0 ^ -1;\n\n          if (!arr) {\n            return;\n          }\n        }\n\n        // store in temp variable for minor speed gain\n        crc = crcTable.crc;\n\n        for (i = 0, l = arr.length; i < l; i += 1) {\n          crc = (crc >>> 8) ^ table[(crc ^ arr[i]) & 0xff];\n        }\n\n        crcTable.crc = crc;\n\n        return crc ^ -1;\n      }\n\n      // build the table\n      // this isn't that costly, and most uses will be for table assisted mode\n      makeTable();\n\n      var fn = function (val, direct) {\n        var val = (typeof val === 'string') ? strToArr(val) : val,\n          ret = direct ? crcDirect(val) : crcTable(val);\n\n        // convert to 2's complement hex\n        return (ret >>> 0).toString(16);\n      };\n      fn.direct = crcDirect;\n      fn.table = crcTable;\n      return fn;\n    })(),\n       deflate = (function () {\n         var deflate = (function () {\n           /* constant parameters */\n           var WSIZE = 32768, // Sliding Window size\n             STORED_BLOCK = 0,\n             STATIC_TREES = 1,\n             DYN_TREES = 2,\n\n           /* for deflate */\n             DEFAULT_LEVEL = 6,\n             FULL_SEARCH = false,\n             INBUFSIZ = 32768, // Input buffer size\n           //INBUF_EXTRA = 64, // Extra buffer\n             OUTBUFSIZ = 1024 * 8,\n             window_size = 2 * WSIZE,\n             MIN_MATCH = 3,\n             MAX_MATCH = 258,\n             BITS = 16,\n           // for SMALL_MEM\n             LIT_BUFSIZE = 0x2000,\n//\t\tHASH_BITS = 13,\n           //for MEDIUM_MEM\n           //\tLIT_BUFSIZE = 0x4000,\n           //\tHASH_BITS = 14,\n           // for BIG_MEM\n           //\tLIT_BUFSIZE = 0x8000,\n             HASH_BITS = 15,\n             DIST_BUFSIZE = LIT_BUFSIZE,\n             HASH_SIZE = 1 << HASH_BITS,\n             HASH_MASK = HASH_SIZE - 1,\n             WMASK = WSIZE - 1,\n             NIL = 0, // Tail of hash chains\n             TOO_FAR = 4096,\n             MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1,\n             MAX_DIST = WSIZE - MIN_LOOKAHEAD,\n             SMALLEST = 1,\n             MAX_BITS = 15,\n             MAX_BL_BITS = 7,\n             LENGTH_CODES = 29,\n             LITERALS = 256,\n             END_BLOCK = 256,\n             L_CODES = LITERALS + 1 + LENGTH_CODES,\n             D_CODES = 30,\n             BL_CODES = 19,\n             REP_3_6 = 16,\n             REPZ_3_10 = 17,\n             REPZ_11_138 = 18,\n             HEAP_SIZE = 2 * L_CODES + 1,\n             H_SHIFT = parseInt((HASH_BITS + MIN_MATCH - 1) / MIN_MATCH, 10),\n\n           /* variables */\n             free_queue,\n             qhead,\n             qtail,\n             initflag,\n             outbuf = null,\n             outcnt,\n             outoff,\n             complete,\n             window,\n             d_buf,\n             l_buf,\n             prev,\n             bi_buf,\n             bi_valid,\n             block_start,\n             ins_h,\n             hash_head,\n             prev_match,\n             match_available,\n             match_length,\n             prev_length,\n             strstart,\n             match_start,\n             eofile,\n             lookahead,\n             max_chain_length,\n             max_lazy_match,\n             compr_level,\n             good_match,\n             nice_match,\n             dyn_ltree,\n             dyn_dtree,\n             static_ltree,\n             static_dtree,\n             bl_tree,\n             l_desc,\n             d_desc,\n             bl_desc,\n             bl_count,\n             heap,\n             heap_len,\n             heap_max,\n             depth,\n             length_code,\n             dist_code,\n             base_length,\n             base_dist,\n             flag_buf,\n             last_lit,\n             last_dist,\n             last_flags,\n             flags,\n             flag_bit,\n             opt_len,\n             static_len,\n             deflate_data,\n             deflate_pos;\n\n           if (LIT_BUFSIZE > INBUFSIZ) {\n             console.error(\"error: INBUFSIZ is too small\");\n           }\n           if ((WSIZE << 1) > (1 << BITS)) {\n             console.error(\"error: WSIZE is too large\");\n           }\n           if (HASH_BITS > BITS - 1) {\n             console.error(\"error: HASH_BITS is too large\");\n           }\n           if (HASH_BITS < 8 || MAX_MATCH !== 258) {\n             console.error(\"error: Code too clever\");\n           }\n\n           /* objects (deflate) */\n\n           function DeflateCT() {\n             this.fc = 0; // frequency count or bit string\n             this.dl = 0; // father node in Huffman tree or length of bit string\n           }\n\n           function DeflateTreeDesc() {\n             this.dyn_tree = null; // the dynamic tree\n             this.static_tree = null; // corresponding static tree or NULL\n             this.extra_bits = null; // extra bits for each code or NULL\n             this.extra_base = 0; // base index for extra_bits\n             this.elems = 0; // max number of elements in the tree\n             this.max_length = 0; // max bit length for the codes\n             this.max_code = 0; // largest code with non zero frequency\n           }\n\n           /* Values for max_lazy_match, good_match and max_chain_length, depending on\n            * the desired pack level (0..9). The values given below have been tuned to\n            * exclude worst case performance for pathological files. Better values may be\n            * found for specific files.\n            */\n           function DeflateConfiguration(a, b, c, d) {\n             this.good_length = a; // reduce lazy search above this match length\n             this.max_lazy = b; // do not perform lazy search above this match length\n             this.nice_length = c; // quit search above this match length\n             this.max_chain = d;\n           }\n\n           function DeflateBuffer() {\n             this.next = null;\n             this.len = 0;\n             this.ptr = []; // new Array(OUTBUFSIZ); // ptr.length is never read\n             this.off = 0;\n           }\n\n           /* constant tables */\n           var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];\n           var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];\n           var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];\n           var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n           var configuration_table = [\n             new DeflateConfiguration(0, 0, 0, 0),\n             new DeflateConfiguration(4, 4, 8, 4),\n             new DeflateConfiguration(4, 5, 16, 8),\n             new DeflateConfiguration(4, 6, 32, 32),\n             new DeflateConfiguration(4, 4, 16, 16),\n             new DeflateConfiguration(8, 16, 32, 32),\n             new DeflateConfiguration(8, 16, 128, 128),\n             new DeflateConfiguration(8, 32, 128, 256),\n             new DeflateConfiguration(32, 128, 258, 1024),\n             new DeflateConfiguration(32, 258, 258, 4096)\n           ];\n\n\n           /* routines (deflate) */\n\n           function deflate_start(level) {\n             var i;\n\n             if (!level) {\n               level = DEFAULT_LEVEL;\n             } else if (level < 1) {\n               level = 1;\n             } else if (level > 9) {\n               level = 9;\n             }\n\n             compr_level = level;\n             initflag = false;\n             eofile = false;\n             if (outbuf !== null) {\n               return;\n             }\n\n             free_queue = qhead = qtail = null;\n             outbuf = []; // new Array(OUTBUFSIZ); // outbuf.length never called\n             window = []; // new Array(window_size); // window.length never called\n             d_buf = []; // new Array(DIST_BUFSIZE); // d_buf.length never called\n             l_buf = []; // new Array(INBUFSIZ + INBUF_EXTRA); // l_buf.length never called\n             prev = []; // new Array(1 << BITS); // prev.length never called\n\n             dyn_ltree = [];\n             for (i = 0; i < HEAP_SIZE; i++) {\n               dyn_ltree[i] = new DeflateCT();\n             }\n             dyn_dtree = [];\n             for (i = 0; i < 2 * D_CODES + 1; i++) {\n               dyn_dtree[i] = new DeflateCT();\n             }\n             static_ltree = [];\n             for (i = 0; i < L_CODES + 2; i++) {\n               static_ltree[i] = new DeflateCT();\n             }\n             static_dtree = [];\n             for (i = 0; i < D_CODES; i++) {\n               static_dtree[i] = new DeflateCT();\n             }\n             bl_tree = [];\n             for (i = 0; i < 2 * BL_CODES + 1; i++) {\n               bl_tree[i] = new DeflateCT();\n             }\n             l_desc = new DeflateTreeDesc();\n             d_desc = new DeflateTreeDesc();\n             bl_desc = new DeflateTreeDesc();\n             bl_count = []; // new Array(MAX_BITS+1); // bl_count.length never called\n             heap = []; // new Array(2*L_CODES+1); // heap.length never called\n             depth = []; // new Array(2*L_CODES+1); // depth.length never called\n             length_code = []; // new Array(MAX_MATCH-MIN_MATCH+1); // length_code.length never called\n             dist_code = []; // new Array(512); // dist_code.length never called\n             base_length = []; // new Array(LENGTH_CODES); // base_length.length never called\n             base_dist = []; // new Array(D_CODES); // base_dist.length never called\n             flag_buf = []; // new Array(parseInt(LIT_BUFSIZE / 8, 10)); // flag_buf.length never called\n           }\n\n           function deflate_end() {\n             free_queue = qhead = qtail = null;\n             outbuf = null;\n             window = null;\n             d_buf = null;\n             l_buf = null;\n             prev = null;\n             dyn_ltree = null;\n             dyn_dtree = null;\n             static_ltree = null;\n             static_dtree = null;\n             bl_tree = null;\n             l_desc = null;\n             d_desc = null;\n             bl_desc = null;\n             bl_count = null;\n             heap = null;\n             depth = null;\n             length_code = null;\n             dist_code = null;\n             base_length = null;\n             base_dist = null;\n             flag_buf = null;\n           }\n\n           function reuse_queue(p) {\n             p.next = free_queue;\n             free_queue = p;\n           }\n\n           function new_queue() {\n             var p;\n\n             if (free_queue !== null) {\n               p = free_queue;\n               free_queue = free_queue.next;\n             } else {\n               p = new DeflateBuffer();\n             }\n             p.next = null;\n             p.len = p.off = 0;\n\n             return p;\n           }\n\n           function head1(i) {\n             return prev[WSIZE + i];\n           }\n\n           function head2(i, val) {\n             return (prev[WSIZE + i] = val);\n           }\n\n           /* put_byte is used for the compressed output, put_ubyte for the\n            * uncompressed output. However unlzw() uses window for its\n            * suffix table instead of its output buffer, so it does not use put_ubyte\n            * (to be cleaned up).\n            */\n           function put_byte(c) {\n             outbuf[outoff + outcnt++] = c;\n             if (outoff + outcnt === OUTBUFSIZ) {\n               qoutbuf();\n             }\n           }\n\n           /* Output a 16 bit value, lsb first */\n           function put_short(w) {\n             w &= 0xffff;\n             if (outoff + outcnt < OUTBUFSIZ - 2) {\n               outbuf[outoff + outcnt++] = (w & 0xff);\n               outbuf[outoff + outcnt++] = (w >>> 8);\n             } else {\n               put_byte(w & 0xff);\n               put_byte(w >>> 8);\n             }\n           }\n\n           /* ==========================================================================\n            * Insert string s in the dictionary and set match_head to the previous head\n            * of the hash chain (the most recent string with same hash key). Return\n            * the previous length of the hash chain.\n            * IN  assertion: all calls to to INSERT_STRING are made with consecutive\n            *    input characters and the first MIN_MATCH bytes of s are valid\n            *    (except for the last MIN_MATCH-1 bytes of the input file).\n            */\n           function INSERT_STRING() {\n             ins_h = ((ins_h << H_SHIFT) ^ (window[strstart + MIN_MATCH - 1] & 0xff)) & HASH_MASK;\n             hash_head = head1(ins_h);\n             prev[strstart & WMASK] = hash_head;\n             head2(ins_h, strstart);\n           }\n\n           /* Send a code of the given tree. c and tree must not have side effects */\n           function SEND_CODE(c, tree) {\n             send_bits(tree[c].fc, tree[c].dl);\n           }\n\n           /* Mapping from a distance to a distance code. dist is the distance - 1 and\n            * must not have side effects. dist_code[256] and dist_code[257] are never\n            * used.\n            */\n           function D_CODE(dist) {\n             return (dist < 256 ? dist_code[dist] : dist_code[256 + (dist >> 7)]) & 0xff;\n           }\n\n           /* ==========================================================================\n            * Compares to subtrees, using the tree depth as tie breaker when\n            * the subtrees have equal frequency. This minimizes the worst case length.\n            */\n           function SMALLER(tree, n, m) {\n             return tree[n].fc < tree[m].fc || (tree[n].fc === tree[m].fc && depth[n] <= depth[m]);\n           }\n\n           /* ==========================================================================\n            * read string data\n            */\n           function read_buff(buff, offset, n) {\n             var i;\n             for (i = 0; i < n && deflate_pos < deflate_data.length; i++) {\n               buff[offset + i] = deflate_data[deflate_pos++] & 0xff;\n             }\n             return i;\n           }\n\n           /* ==========================================================================\n            * Initialize the \"longest match\" routines for a new file\n            */\n           function lm_init() {\n             var j;\n\n             // Initialize the hash table. */\n             for (j = 0; j < HASH_SIZE; j++) {\n               // head2(j, NIL);\n               prev[WSIZE + j] = 0;\n             }\n             // prev will be initialized on the fly */\n\n             // Set the default configuration parameters:\n             max_lazy_match = configuration_table[compr_level].max_lazy;\n             good_match = configuration_table[compr_level].good_length;\n             if (!FULL_SEARCH) {\n               nice_match = configuration_table[compr_level].nice_length;\n             }\n             max_chain_length = configuration_table[compr_level].max_chain;\n\n             strstart = 0;\n             block_start = 0;\n\n             lookahead = read_buff(window, 0, 2 * WSIZE);\n             if (lookahead <= 0) {\n               eofile = true;\n               lookahead = 0;\n               return;\n             }\n             eofile = false;\n             // Make sure that we always have enough lookahead. This is important\n             // if input comes from a device such as a tty.\n             while (lookahead < MIN_LOOKAHEAD && !eofile) {\n               fill_window();\n             }\n\n             // If lookahead < MIN_MATCH, ins_h is garbage, but this is\n             // not important since only literal bytes will be emitted.\n             ins_h = 0;\n             for (j = 0; j < MIN_MATCH - 1; j++) {\n               // UPDATE_HASH(ins_h, window[j]);\n               ins_h = ((ins_h << H_SHIFT) ^ (window[j] & 0xff)) & HASH_MASK;\n             }\n           }\n\n           /* ==========================================================================\n            * Set match_start to the longest match starting at the given string and\n            * return its length. Matches shorter or equal to prev_length are discarded,\n            * in which case the result is equal to prev_length and match_start is\n            * garbage.\n            * IN assertions: cur_match is the head of the hash chain for the current\n            *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n            */\n           function longest_match(cur_match) {\n             var chain_length = max_chain_length; // max hash chain length\n             var scanp = strstart; // current string\n             var matchp; // matched string\n             var len; // length of current match\n             var best_len = prev_length; // best match length so far\n\n             // Stop when cur_match becomes <= limit. To simplify the code,\n             // we prevent matches with the string of window index 0.\n             var limit = (strstart > MAX_DIST ? strstart - MAX_DIST : NIL);\n\n             var strendp = strstart + MAX_MATCH;\n             var scan_end1 = window[scanp + best_len - 1];\n             var scan_end = window[scanp + best_len];\n\n             var i, broke;\n\n             // Do not waste too much time if we already have a good match: */\n             if (prev_length >= good_match) {\n               chain_length >>= 2;\n             }\n\n             // Assert(encoder->strstart <= window_size-MIN_LOOKAHEAD, \"insufficient lookahead\");\n\n             do {\n               // Assert(cur_match < encoder->strstart, \"no future\");\n               matchp = cur_match;\n\n               // Skip to next match if the match length cannot increase\n               // or if the match length is less than 2:\n               if (window[matchp + best_len] !== scan_end ||\n                 window[matchp + best_len - 1] !== scan_end1 ||\n                 window[matchp] !== window[scanp] ||\n                 window[++matchp] !== window[scanp + 1]) {\n                 continue;\n               }\n\n               // The check at best_len-1 can be removed because it will be made\n               // again later. (This heuristic is not always a win.)\n               // It is not necessary to compare scan[2] and match[2] since they\n               // are always equal when the other bytes match, given that\n               // the hash keys are equal and that HASH_BITS >= 8.\n               scanp += 2;\n               matchp++;\n\n               // We check for insufficient lookahead only every 8th comparison;\n               // the 256th check will be made at strstart+258.\n               while (scanp < strendp) {\n                 broke = false;\n                 for (i = 0; i < 8; i += 1) {\n                   scanp += 1;\n                   matchp += 1;\n                   if (window[scanp] !== window[matchp]) {\n                     broke = true;\n                     break;\n                   }\n                 }\n\n                 if (broke) {\n                   break;\n                 }\n               }\n\n               len = MAX_MATCH - (strendp - scanp);\n               scanp = strendp - MAX_MATCH;\n\n               if (len > best_len) {\n                 match_start = cur_match;\n                 best_len = len;\n                 if (FULL_SEARCH) {\n                   if (len >= MAX_MATCH) {\n                     break;\n                   }\n                 } else {\n                   if (len >= nice_match) {\n                     break;\n                   }\n                 }\n\n                 scan_end1 = window[scanp + best_len - 1];\n                 scan_end = window[scanp + best_len];\n               }\n             } while ((cur_match = prev[cur_match & WMASK]) > limit && --chain_length !== 0);\n\n             return best_len;\n           }\n\n           /* ==========================================================================\n            * Fill the window when the lookahead becomes insufficient.\n            * Updates strstart and lookahead, and sets eofile if end of input file.\n            * IN assertion: lookahead < MIN_LOOKAHEAD && strstart + lookahead > 0\n            * OUT assertions: at least one byte has been read, or eofile is set;\n            *    file reads are performed for at least two bytes (required for the\n            *    translate_eol option).\n            */\n           function fill_window() {\n             var n, m;\n\n             // Amount of free space at the end of the window.\n             var more = window_size - lookahead - strstart;\n\n             // If the window is almost full and there is insufficient lookahead,\n             // move the upper half to the lower one to make room in the upper half.\n             if (more === -1) {\n               // Very unlikely, but possible on 16 bit machine if strstart == 0\n               // and lookahead == 1 (input done one byte at time)\n               more--;\n             } else if (strstart >= WSIZE + MAX_DIST) {\n               // By the IN assertion, the window is not empty so we can't confuse\n               // more == 0 with more == 64K on a 16 bit machine.\n               // Assert(window_size == (ulg)2*WSIZE, \"no sliding with BIG_MEM\");\n\n               // System.arraycopy(window, WSIZE, window, 0, WSIZE);\n               for (n = 0; n < WSIZE; n++) {\n                 window[n] = window[n + WSIZE];\n               }\n\n               match_start -= WSIZE;\n               strstart -= WSIZE;\n               /* we now have strstart >= MAX_DIST: */\n               block_start -= WSIZE;\n\n               for (n = 0; n < HASH_SIZE; n++) {\n                 m = head1(n);\n                 head2(n, m >= WSIZE ? m - WSIZE : NIL);\n               }\n               for (n = 0; n < WSIZE; n++) {\n                 // If n is not on any hash chain, prev[n] is garbage but\n                 // its value will never be used.\n                 m = prev[n];\n                 prev[n] = (m >= WSIZE ? m - WSIZE : NIL);\n               }\n               more += WSIZE;\n             }\n             // At this point, more >= 2\n             if (!eofile) {\n               n = read_buff(window, strstart + lookahead, more);\n               if (n <= 0) {\n                 eofile = true;\n               } else {\n                 lookahead += n;\n               }\n             }\n           }\n\n           /* ==========================================================================\n            * Processes a new input file and return its compressed length. This\n            * function does not perform lazy evaluationof matches and inserts\n            * new strings in the dictionary only for unmatched strings or for short\n            * matches. It is used only for the fast compression options.\n            */\n           function deflate_fast() {\n             while (lookahead !== 0 && qhead === null) {\n               var flush; // set if current block must be flushed\n\n               // Insert the string window[strstart .. strstart+2] in the\n               // dictionary, and set hash_head to the head of the hash chain:\n               INSERT_STRING();\n\n               // Find the longest match, discarding those <= prev_length.\n               // At this point we have always match_length < MIN_MATCH\n               if (hash_head !== NIL && strstart - hash_head <= MAX_DIST) {\n                 // To simplify the code, we prevent matches with the string\n                 // of window index 0 (in particular we have to avoid a match\n                 // of the string with itself at the start of the input file).\n                 match_length = longest_match(hash_head);\n                 // longest_match() sets match_start */\n                 if (match_length > lookahead) {\n                   match_length = lookahead;\n                 }\n               }\n               if (match_length >= MIN_MATCH) {\n                 // check_match(strstart, match_start, match_length);\n\n                 flush = ct_tally(strstart - match_start, match_length - MIN_MATCH);\n                 lookahead -= match_length;\n\n                 // Insert new strings in the hash table only if the match length\n                 // is not too large. This saves time but degrades compression.\n                 if (match_length <= max_lazy_match) {\n                   match_length--; // string at strstart already in hash table\n                   do {\n                     strstart++;\n                     INSERT_STRING();\n                     // strstart never exceeds WSIZE-MAX_MATCH, so there are\n                     // always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH\n                     // these bytes are garbage, but it does not matter since\n                     // the next lookahead bytes will be emitted as literals.\n                   } while (--match_length !== 0);\n                   strstart++;\n                 } else {\n                   strstart += match_length;\n                   match_length = 0;\n                   ins_h = window[strstart] & 0xff;\n                   // UPDATE_HASH(ins_h, window[strstart + 1]);\n                   ins_h = ((ins_h << H_SHIFT) ^ (window[strstart + 1] & 0xff)) & HASH_MASK;\n\n                   //#if MIN_MATCH !== 3\n                   //\t\tCall UPDATE_HASH() MIN_MATCH-3 more times\n                   //#endif\n\n                 }\n               } else {\n                 // No match, output a literal byte */\n                 flush = ct_tally(0, window[strstart] & 0xff);\n                 lookahead--;\n                 strstart++;\n               }\n               if (flush) {\n                 flush_block(0);\n                 block_start = strstart;\n               }\n\n               // Make sure that we always have enough lookahead, except\n               // at the end of the input file. We need MAX_MATCH bytes\n               // for the next match, plus MIN_MATCH bytes to insert the\n               // string following the next match.\n               while (lookahead < MIN_LOOKAHEAD && !eofile) {\n                 fill_window();\n               }\n             }\n           }\n\n           function deflate_better() {\n             // Process the input block. */\n             while (lookahead !== 0 && qhead === null) {\n               // Insert the string window[strstart .. strstart+2] in the\n               // dictionary, and set hash_head to the head of the hash chain:\n               INSERT_STRING();\n\n               // Find the longest match, discarding those <= prev_length.\n               prev_length = match_length;\n               prev_match = match_start;\n               match_length = MIN_MATCH - 1;\n\n               if (hash_head !== NIL && prev_length < max_lazy_match && strstart - hash_head <= MAX_DIST) {\n                 // To simplify the code, we prevent matches with the string\n                 // of window index 0 (in particular we have to avoid a match\n                 // of the string with itself at the start of the input file).\n                 match_length = longest_match(hash_head);\n                 // longest_match() sets match_start */\n                 if (match_length > lookahead) {\n                   match_length = lookahead;\n                 }\n\n                 // Ignore a length 3 match if it is too distant: */\n                 if (match_length === MIN_MATCH && strstart - match_start > TOO_FAR) {\n                   // If prev_match is also MIN_MATCH, match_start is garbage\n                   // but we will ignore the current match anyway.\n                   match_length--;\n                 }\n               }\n               // If there was a match at the previous step and the current\n               // match is not better, output the previous match:\n               if (prev_length >= MIN_MATCH && match_length <= prev_length) {\n                 var flush; // set if current block must be flushed\n\n                 // check_match(strstart - 1, prev_match, prev_length);\n                 flush = ct_tally(strstart - 1 - prev_match, prev_length - MIN_MATCH);\n\n                 // Insert in hash table all strings up to the end of the match.\n                 // strstart-1 and strstart are already inserted.\n                 lookahead -= prev_length - 1;\n                 prev_length -= 2;\n                 do {\n                   strstart++;\n                   INSERT_STRING();\n                   // strstart never exceeds WSIZE-MAX_MATCH, so there are\n                   // always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH\n                   // these bytes are garbage, but it does not matter since the\n                   // next lookahead bytes will always be emitted as literals.\n                 } while (--prev_length !== 0);\n                 match_available = false;\n                 match_length = MIN_MATCH - 1;\n                 strstart++;\n                 if (flush) {\n                   flush_block(0);\n                   block_start = strstart;\n                 }\n               } else if (match_available) {\n                 // If there was no match at the previous position, output a\n                 // single literal. If there was a match but the current match\n                 // is longer, truncate the previous match to a single literal.\n                 if (ct_tally(0, window[strstart - 1] & 0xff)) {\n                   flush_block(0);\n                   block_start = strstart;\n                 }\n                 strstart++;\n                 lookahead--;\n               } else {\n                 // There is no previous match to compare with, wait for\n                 // the next step to decide.\n                 match_available = true;\n                 strstart++;\n                 lookahead--;\n               }\n\n               // Make sure that we always have enough lookahead, except\n               // at the end of the input file. We need MAX_MATCH bytes\n               // for the next match, plus MIN_MATCH bytes to insert the\n               // string following the next match.\n               while (lookahead < MIN_LOOKAHEAD && !eofile) {\n                 fill_window();\n               }\n             }\n           }\n\n           function init_deflate() {\n             if (eofile) {\n               return;\n             }\n             bi_buf = 0;\n             bi_valid = 0;\n             ct_init();\n             lm_init();\n\n             qhead = null;\n             outcnt = 0;\n             outoff = 0;\n\n             if (compr_level <= 3) {\n               prev_length = MIN_MATCH - 1;\n               match_length = 0;\n             } else {\n               match_length = MIN_MATCH - 1;\n               match_available = false;\n             }\n\n             complete = false;\n           }\n\n           /* ==========================================================================\n            * Same as above, but achieves better compression. We use a lazy\n            * evaluation for matches: a match is finally adopted only if there is\n            * no better match at the next window position.\n            */\n           function deflate_internal(buff, off, buff_size) {\n             var n;\n\n             if (!initflag) {\n               init_deflate();\n               initflag = true;\n               if (lookahead === 0) { // empty\n                 complete = true;\n                 return 0;\n               }\n             }\n\n             n = qcopy(buff, off, buff_size);\n             if (n === buff_size) {\n               return buff_size;\n             }\n\n             if (complete) {\n               return n;\n             }\n\n             if (compr_level <= 3) {\n               // optimized for speed\n               deflate_fast();\n             } else {\n               deflate_better();\n             }\n\n             if (lookahead === 0) {\n               if (match_available) {\n                 ct_tally(0, window[strstart - 1] & 0xff);\n               }\n               flush_block(1);\n               complete = true;\n             }\n\n             return n + qcopy(buff, n + off, buff_size - n);\n           }\n\n           function qcopy(buff, off, buff_size) {\n             var n, i, j;\n\n             n = 0;\n             while (qhead !== null && n < buff_size) {\n               i = buff_size - n;\n               if (i > qhead.len) {\n                 i = qhead.len;\n               }\n               // System.arraycopy(qhead.ptr, qhead.off, buff, off + n, i);\n               for (j = 0; j < i; j++) {\n                 buff[off + n + j] = qhead.ptr[qhead.off + j];\n               }\n\n               qhead.off += i;\n               qhead.len -= i;\n               n += i;\n               if (qhead.len === 0) {\n                 var p;\n                 p = qhead;\n                 qhead = qhead.next;\n                 reuse_queue(p);\n               }\n             }\n\n             if (n === buff_size) {\n               return n;\n             }\n\n             if (outoff < outcnt) {\n               i = buff_size - n;\n               if (i > outcnt - outoff) {\n                 i = outcnt - outoff;\n               }\n               // System.arraycopy(outbuf, outoff, buff, off + n, i);\n               for (j = 0; j < i; j++) {\n                 buff[off + n + j] = outbuf[outoff + j];\n               }\n               outoff += i;\n               n += i;\n               if (outcnt === outoff) {\n                 outcnt = outoff = 0;\n               }\n             }\n             return n;\n           }\n\n           /* ==========================================================================\n            * Allocate the match buffer, initialize the various tables and save the\n            * location of the internal file attribute (ascii/binary) and method\n            * (DEFLATE/STORE).\n            */\n           function ct_init() {\n             var n; // iterates over tree elements\n             var bits; // bit counter\n             var length; // length value\n             var code; // code value\n             var dist; // distance index\n\n             if (static_dtree[0].dl !== 0) {\n               return; // ct_init already called\n             }\n\n             l_desc.dyn_tree = dyn_ltree;\n             l_desc.static_tree = static_ltree;\n             l_desc.extra_bits = extra_lbits;\n             l_desc.extra_base = LITERALS + 1;\n             l_desc.elems = L_CODES;\n             l_desc.max_length = MAX_BITS;\n             l_desc.max_code = 0;\n\n             d_desc.dyn_tree = dyn_dtree;\n             d_desc.static_tree = static_dtree;\n             d_desc.extra_bits = extra_dbits;\n             d_desc.extra_base = 0;\n             d_desc.elems = D_CODES;\n             d_desc.max_length = MAX_BITS;\n             d_desc.max_code = 0;\n\n             bl_desc.dyn_tree = bl_tree;\n             bl_desc.static_tree = null;\n             bl_desc.extra_bits = extra_blbits;\n             bl_desc.extra_base = 0;\n             bl_desc.elems = BL_CODES;\n             bl_desc.max_length = MAX_BL_BITS;\n             bl_desc.max_code = 0;\n\n             // Initialize the mapping length (0..255) -> length code (0..28)\n             length = 0;\n             for (code = 0; code < LENGTH_CODES - 1; code++) {\n               base_length[code] = length;\n               for (n = 0; n < (1 << extra_lbits[code]); n++) {\n                 length_code[length++] = code;\n               }\n             }\n             // Assert (length === 256, \"ct_init: length !== 256\");\n\n             // Note that the length 255 (match length 258) can be represented\n             // in two different ways: code 284 + 5 bits or code 285, so we\n             // overwrite length_code[255] to use the best encoding:\n             length_code[length - 1] = code;\n\n             // Initialize the mapping dist (0..32K) -> dist code (0..29) */\n             dist = 0;\n             for (code = 0; code < 16; code++) {\n               base_dist[code] = dist;\n               for (n = 0; n < (1 << extra_dbits[code]); n++) {\n                 dist_code[dist++] = code;\n               }\n             }\n             // Assert (dist === 256, \"ct_init: dist !== 256\");\n             // from now on, all distances are divided by 128\n             for (dist >>= 7; code < D_CODES; code++) {\n               base_dist[code] = dist << 7;\n               for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n                 dist_code[256 + dist++] = code;\n               }\n             }\n             // Assert (dist === 256, \"ct_init: 256+dist !== 512\");\n\n             // Construct the codes of the static literal tree\n             for (bits = 0; bits <= MAX_BITS; bits++) {\n               bl_count[bits] = 0;\n             }\n             n = 0;\n             while (n <= 143) {\n               static_ltree[n++].dl = 8;\n               bl_count[8]++;\n             }\n             while (n <= 255) {\n               static_ltree[n++].dl = 9;\n               bl_count[9]++;\n             }\n             while (n <= 279) {\n               static_ltree[n++].dl = 7;\n               bl_count[7]++;\n             }\n             while (n <= 287) {\n               static_ltree[n++].dl = 8;\n               bl_count[8]++;\n             }\n             // Codes 286 and 287 do not exist, but we must include them in the\n             // tree construction to get a canonical Huffman tree (longest code\n             // all ones)\n             gen_codes(static_ltree, L_CODES + 1);\n\n             // The static distance tree is trivial: */\n             for (n = 0; n < D_CODES; n++) {\n               static_dtree[n].dl = 5;\n               static_dtree[n].fc = bi_reverse(n, 5);\n             }\n\n             // Initialize the first block of the first file:\n             init_block();\n           }\n\n           /* ==========================================================================\n            * Initialize a new block.\n            */\n           function init_block() {\n             var n; // iterates over tree elements\n\n             // Initialize the trees.\n             for (n = 0; n < L_CODES; n++) {\n               dyn_ltree[n].fc = 0;\n             }\n             for (n = 0; n < D_CODES; n++) {\n               dyn_dtree[n].fc = 0;\n             }\n             for (n = 0; n < BL_CODES; n++) {\n               bl_tree[n].fc = 0;\n             }\n\n             dyn_ltree[END_BLOCK].fc = 1;\n             opt_len = static_len = 0;\n             last_lit = last_dist = last_flags = 0;\n             flags = 0;\n             flag_bit = 1;\n           }\n\n           /* ==========================================================================\n            * Restore the heap property by moving down the tree starting at node k,\n            * exchanging a node with the smallest of its two sons if necessary, stopping\n            * when the heap property is re-established (each father smaller than its\n            * two sons).\n            *\n            * @param tree- tree to restore\n            * @param k- node to move down\n            */\n           function pqdownheap(tree, k) {\n             var v = heap[k],\n               j = k << 1; // left son of k\n\n             while (j <= heap_len) {\n               // Set j to the smallest of the two sons:\n               if (j < heap_len && SMALLER(tree, heap[j + 1], heap[j])) {\n                 j++;\n               }\n\n               // Exit if v is smaller than both sons\n               if (SMALLER(tree, v, heap[j])) {\n                 break;\n               }\n\n               // Exchange v with the smallest son\n               heap[k] = heap[j];\n               k = j;\n\n               // And continue down the tree, setting j to the left son of k\n               j <<= 1;\n             }\n             heap[k] = v;\n           }\n\n           /* ==========================================================================\n            * Compute the optimal bit lengths for a tree and update the total bit length\n            * for the current block.\n            * IN assertion: the fields freq and dad are set, heap[heap_max] and\n            *    above are the tree nodes sorted by increasing frequency.\n            * OUT assertions: the field len is set to the optimal bit length, the\n            *     array bl_count contains the frequencies for each bit length.\n            *     The length opt_len is updated; static_len is also updated if stree is\n            *     not null.\n            */\n           function gen_bitlen(desc) { // the tree descriptor\n             var tree = desc.dyn_tree;\n             var extra = desc.extra_bits;\n             var base = desc.extra_base;\n             var max_code = desc.max_code;\n             var max_length = desc.max_length;\n             var stree = desc.static_tree;\n             var h; // heap index\n             var n, m; // iterate over the tree elements\n             var bits; // bit length\n             var xbits; // extra bits\n             var f; // frequency\n             var overflow = 0; // number of elements with bit length too large\n\n             for (bits = 0; bits <= MAX_BITS; bits++) {\n               bl_count[bits] = 0;\n             }\n\n             // In a first pass, compute the optimal bit lengths (which may\n             // overflow in the case of the bit length tree).\n             tree[heap[heap_max]].dl = 0; // root of the heap\n\n             for (h = heap_max + 1; h < HEAP_SIZE; h++) {\n               n = heap[h];\n               bits = tree[tree[n].dl].dl + 1;\n               if (bits > max_length) {\n                 bits = max_length;\n                 overflow++;\n               }\n               tree[n].dl = bits;\n               // We overwrite tree[n].dl which is no longer needed\n\n               if (n > max_code) {\n                 continue; // not a leaf node\n               }\n\n               bl_count[bits]++;\n               xbits = 0;\n               if (n >= base) {\n                 xbits = extra[n - base];\n               }\n               f = tree[n].fc;\n               opt_len += f * (bits + xbits);\n               if (stree !== null) {\n                 static_len += f * (stree[n].dl + xbits);\n               }\n             }\n             if (overflow === 0) {\n               return;\n             }\n\n             // This happens for example on obj2 and pic of the Calgary corpus\n\n             // Find the first bit length which could increase:\n             do {\n               bits = max_length - 1;\n               while (bl_count[bits] === 0) {\n                 bits--;\n               }\n               bl_count[bits]--; // move one leaf down the tree\n               bl_count[bits + 1] += 2; // move one overflow item as its brother\n               bl_count[max_length]--;\n               // The brother of the overflow item also moves one step up,\n               // but this does not affect bl_count[max_length]\n               overflow -= 2;\n             } while (overflow > 0);\n\n             // Now recompute all bit lengths, scanning in increasing frequency.\n             // h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n             // lengths instead of fixing only the wrong ones. This idea is taken\n             // from 'ar' written by Haruhiko Okumura.)\n             for (bits = max_length; bits !== 0; bits--) {\n               n = bl_count[bits];\n               while (n !== 0) {\n                 m = heap[--h];\n                 if (m > max_code) {\n                   continue;\n                 }\n                 if (tree[m].dl !== bits) {\n                   opt_len += (bits - tree[m].dl) * tree[m].fc;\n                   tree[m].fc = bits;\n                 }\n                 n--;\n               }\n             }\n           }\n\n           /* ==========================================================================\n            * Generate the codes for a given tree and bit counts (which need not be\n            * optimal).\n            * IN assertion: the array bl_count contains the bit length statistics for\n            * the given tree and the field len is set for all tree elements.\n            * OUT assertion: the field code is set for all tree elements of non\n            *     zero code length.\n            * @param tree- the tree to decorate\n            * @param max_code- largest code with non-zero frequency\n            */\n           function gen_codes(tree, max_code) {\n             var next_code = []; // new Array(MAX_BITS + 1); // next code value for each bit length\n             var code = 0; // running code value\n             var bits; // bit index\n             var n; // code index\n\n             // The distribution counts are first used to generate the code values\n             // without bit reversal.\n             for (bits = 1; bits <= MAX_BITS; bits++) {\n               code = ((code + bl_count[bits - 1]) << 1);\n               next_code[bits] = code;\n             }\n\n             // Check that the bit counts in bl_count are consistent. The last code\n             // must be all ones.\n             // Assert (code + encoder->bl_count[MAX_BITS]-1 === (1<<MAX_BITS)-1, \"inconsistent bit counts\");\n             // Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n             for (n = 0; n <= max_code; n++) {\n               var len = tree[n].dl;\n               if (len === 0) {\n                 continue;\n               }\n               // Now reverse the bits\n               tree[n].fc = bi_reverse(next_code[len]++, len);\n\n               // Tracec(tree !== static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \", n, (isgraph(n) ? n : ' '), len, tree[n].fc, next_code[len]-1));\n             }\n           }\n\n           /* ==========================================================================\n            * Construct one Huffman tree and assigns the code bit strings and lengths.\n            * Update the total bit length for the current block.\n            * IN assertion: the field freq is set for all tree elements.\n            * OUT assertions: the fields len and code are set to the optimal bit length\n            *     and corresponding code. The length opt_len is updated; static_len is\n            *     also updated if stree is not null. The field max_code is set.\n            */\n           function build_tree(desc) { // the tree descriptor\n             var tree = desc.dyn_tree;\n             var stree = desc.static_tree;\n             var elems = desc.elems;\n             var n, m; // iterate over heap elements\n             var max_code = -1; // largest code with non zero frequency\n             var node = elems; // next internal node of the tree\n\n             // Construct the initial heap, with least frequent element in\n             // heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n             // heap[0] is not used.\n             heap_len = 0;\n             heap_max = HEAP_SIZE;\n\n             for (n = 0; n < elems; n++) {\n               if (tree[n].fc !== 0) {\n                 heap[++heap_len] = max_code = n;\n                 depth[n] = 0;\n               } else {\n                 tree[n].dl = 0;\n               }\n             }\n\n             // The pkzip format requires that at least one distance code exists,\n             // and that at least one bit should be sent even if there is only one\n             // possible code. So to avoid special checks later on we force at least\n             // two codes of non zero frequency.\n             while (heap_len < 2) {\n               var xnew = heap[++heap_len] = (max_code < 2 ? ++max_code : 0);\n               tree[xnew].fc = 1;\n               depth[xnew] = 0;\n               opt_len--;\n               if (stree !== null) {\n                 static_len -= stree[xnew].dl;\n               }\n               // new is 0 or 1 so it does not have extra bits\n             }\n             desc.max_code = max_code;\n\n             // The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n             // establish sub-heaps of increasing lengths:\n             for (n = heap_len >> 1; n >= 1; n--) {\n               pqdownheap(tree, n);\n             }\n\n             // Construct the Huffman tree by repeatedly combining the least two\n             // frequent nodes.\n             do {\n               n = heap[SMALLEST];\n               heap[SMALLEST] = heap[heap_len--];\n               pqdownheap(tree, SMALLEST);\n\n               m = heap[SMALLEST]; // m = node of next least frequency\n\n               // keep the nodes sorted by frequency\n               heap[--heap_max] = n;\n               heap[--heap_max] = m;\n\n               // Create a new node father of n and m\n               tree[node].fc = tree[n].fc + tree[m].fc;\n               //\tdepth[node] = (char)(MAX(depth[n], depth[m]) + 1);\n               if (depth[n] > depth[m] + 1) {\n                 depth[node] = depth[n];\n               } else {\n                 depth[node] = depth[m] + 1;\n               }\n               tree[n].dl = tree[m].dl = node;\n\n               // and insert the new node in the heap\n               heap[SMALLEST] = node++;\n               pqdownheap(tree, SMALLEST);\n\n             } while (heap_len >= 2);\n\n             heap[--heap_max] = heap[SMALLEST];\n\n             // At this point, the fields freq and dad are set. We can now\n             // generate the bit lengths.\n             gen_bitlen(desc);\n\n             // The field len is now set, we can generate the bit codes\n             gen_codes(tree, max_code);\n           }\n\n           /* ==========================================================================\n            * Scan a literal or distance tree to determine the frequencies of the codes\n            * in the bit length tree. Updates opt_len to take into account the repeat\n            * counts. (The contribution of the bit length codes will be added later\n            * during the construction of bl_tree.)\n            *\n            * @param tree- the tree to be scanned\n            * @param max_code- and its largest code of non zero frequency\n            */\n           function scan_tree(tree, max_code) {\n             var n, // iterates over all tree elements\n               prevlen = -1, // last emitted length\n               curlen, // length of current code\n               nextlen = tree[0].dl, // length of next code\n               count = 0, // repeat count of the current code\n               max_count = 7, // max repeat count\n               min_count = 4; // min repeat count\n\n             if (nextlen === 0) {\n               max_count = 138;\n               min_count = 3;\n             }\n             tree[max_code + 1].dl = 0xffff; // guard\n\n             for (n = 0; n <= max_code; n++) {\n               curlen = nextlen;\n               nextlen = tree[n + 1].dl;\n               if (++count < max_count && curlen === nextlen) {\n                 continue;\n               } else if (count < min_count) {\n                 bl_tree[curlen].fc += count;\n               } else if (curlen !== 0) {\n                 if (curlen !== prevlen) {\n                   bl_tree[curlen].fc++;\n                 }\n                 bl_tree[REP_3_6].fc++;\n               } else if (count <= 10) {\n                 bl_tree[REPZ_3_10].fc++;\n               } else {\n                 bl_tree[REPZ_11_138].fc++;\n               }\n               count = 0;\n               prevlen = curlen;\n               if (nextlen === 0) {\n                 max_count = 138;\n                 min_count = 3;\n               } else if (curlen === nextlen) {\n                 max_count = 6;\n                 min_count = 3;\n               } else {\n                 max_count = 7;\n                 min_count = 4;\n               }\n             }\n           }\n\n           /* ==========================================================================\n            * Send a literal or distance tree in compressed form, using the codes in\n            * bl_tree.\n            *\n            * @param tree- the tree to be scanned\n            * @param max_code- and its largest code of non zero frequency\n            */\n           function send_tree(tree, max_code) {\n             var n; // iterates over all tree elements\n             var prevlen = -1; // last emitted length\n             var curlen; // length of current code\n             var nextlen = tree[0].dl; // length of next code\n             var count = 0; // repeat count of the current code\n             var max_count = 7; // max repeat count\n             var min_count = 4; // min repeat count\n\n             // tree[max_code+1].dl = -1; */  /* guard already set */\n             if (nextlen === 0) {\n               max_count = 138;\n               min_count = 3;\n             }\n\n             for (n = 0; n <= max_code; n++) {\n               curlen = nextlen;\n               nextlen = tree[n + 1].dl;\n               if (++count < max_count && curlen === nextlen) {\n                 continue;\n               } else if (count < min_count) {\n                 do {\n                   SEND_CODE(curlen, bl_tree);\n                 } while (--count !== 0);\n               } else if (curlen !== 0) {\n                 if (curlen !== prevlen) {\n                   SEND_CODE(curlen, bl_tree);\n                   count--;\n                 }\n                 // Assert(count >= 3 && count <= 6, \" 3_6?\");\n                 SEND_CODE(REP_3_6, bl_tree);\n                 send_bits(count - 3, 2);\n               } else if (count <= 10) {\n                 SEND_CODE(REPZ_3_10, bl_tree);\n                 send_bits(count - 3, 3);\n               } else {\n                 SEND_CODE(REPZ_11_138, bl_tree);\n                 send_bits(count - 11, 7);\n               }\n               count = 0;\n               prevlen = curlen;\n               if (nextlen === 0) {\n                 max_count = 138;\n                 min_count = 3;\n               } else if (curlen === nextlen) {\n                 max_count = 6;\n                 min_count = 3;\n               } else {\n                 max_count = 7;\n                 min_count = 4;\n               }\n             }\n           }\n\n           /* ==========================================================================\n            * Construct the Huffman tree for the bit lengths and return the index in\n            * bl_order of the last bit length code to send.\n            */\n           function build_bl_tree() {\n             var max_blindex; // index of last bit length code of non zero freq\n\n             // Determine the bit length frequencies for literal and distance trees\n             scan_tree(dyn_ltree, l_desc.max_code);\n             scan_tree(dyn_dtree, d_desc.max_code);\n\n             // Build the bit length tree:\n             build_tree(bl_desc);\n             // opt_len now includes the length of the tree representations, except\n             // the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n\n             // Determine the number of bit length codes to send. The pkzip format\n             // requires that at least 4 bit length codes be sent. (appnote.txt says\n             // 3 but the actual value used is 4.)\n             for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n               if (bl_tree[bl_order[max_blindex]].dl !== 0) {\n                 break;\n               }\n             }\n             // Update opt_len to include the bit length tree and counts */\n             opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n             // Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n             // encoder->opt_len, encoder->static_len));\n\n             return max_blindex;\n           }\n\n           /* ==========================================================================\n            * Send the header for a block using dynamic Huffman trees: the counts, the\n            * lengths of the bit length codes, the literal tree and the distance tree.\n            * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n            */\n           function send_all_trees(lcodes, dcodes, blcodes) { // number of codes for each tree\n             var rank; // index in bl_order\n\n             // Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n             // Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES, \"too many codes\");\n             // Tracev((stderr, \"\\nbl counts: \"));\n             send_bits(lcodes - 257, 5); // not +255 as stated in appnote.txt\n             send_bits(dcodes - 1, 5);\n             send_bits(blcodes - 4, 4); // not -3 as stated in appnote.txt\n             for (rank = 0; rank < blcodes; rank++) {\n               // Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n               send_bits(bl_tree[bl_order[rank]].dl, 3);\n             }\n\n             // send the literal tree\n             send_tree(dyn_ltree, lcodes - 1);\n\n             // send the distance tree\n             send_tree(dyn_dtree, dcodes - 1);\n           }\n\n           /* ==========================================================================\n            * Determine the best encoding for the current block: dynamic trees, static\n            * trees or store, and output the encoded block to the zip file.\n            */\n           function flush_block(eof) { // true if this is the last block for a file\n             var opt_lenb, static_lenb, // opt_len and static_len in bytes\n               max_blindex, // index of last bit length code of non zero freq\n               stored_len, // length of input block\n               i;\n\n             stored_len = strstart - block_start;\n             flag_buf[last_flags] = flags; // Save the flags for the last 8 items\n\n             // Construct the literal and distance trees\n             build_tree(l_desc);\n             // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\",\n             // encoder->opt_len, encoder->static_len));\n\n             build_tree(d_desc);\n             // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\",\n             // encoder->opt_len, encoder->static_len));\n             // At this point, opt_len and static_len are the total bit lengths of\n             // the compressed block data, excluding the tree representations.\n\n             // Build the bit length tree for the above two trees, and get the index\n             // in bl_order of the last bit length code to send.\n             max_blindex = build_bl_tree();\n\n             // Determine the best encoding. Compute first the block length in bytes\n             opt_lenb = (opt_len + 3 + 7) >> 3;\n             static_lenb = (static_len + 3 + 7) >> 3;\n\n             //  Trace((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u dist %u \", opt_lenb, encoder->opt_len, static_lenb, encoder->static_len, stored_len, encoder->last_lit, encoder->last_dist));\n\n             if (static_lenb <= opt_lenb) {\n               opt_lenb = static_lenb;\n             }\n             if (stored_len + 4 <= opt_lenb && block_start >= 0) { // 4: two words for the lengths\n               // The test buf !== NULL is only necessary if LIT_BUFSIZE > WSIZE.\n               // Otherwise we can't have processed more than WSIZE input bytes since\n               // the last block flush, because compression would have been\n               // successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n               // transform a block into a stored block.\n               send_bits((STORED_BLOCK << 1) + eof, 3);\n               /* send block type */\n               bi_windup();\n               /* align on byte boundary */\n               put_short(stored_len);\n               put_short(~stored_len);\n\n               // copy block\n               /*\n                p = &window[block_start];\n                for (i = 0; i < stored_len; i++) {\n                put_byte(p[i]);\n                }\n                */\n               for (i = 0; i < stored_len; i++) {\n                 put_byte(window[block_start + i]);\n               }\n             } else if (static_lenb === opt_lenb) {\n               send_bits((STATIC_TREES << 1) + eof, 3);\n               compress_block(static_ltree, static_dtree);\n             } else {\n               send_bits((DYN_TREES << 1) + eof, 3);\n               send_all_trees(l_desc.max_code + 1, d_desc.max_code + 1, max_blindex + 1);\n               compress_block(dyn_ltree, dyn_dtree);\n             }\n\n             init_block();\n\n             if (eof !== 0) {\n               bi_windup();\n             }\n           }\n\n           /* ==========================================================================\n            * Save the match info and tally the frequency counts. Return true if\n            * the current block must be flushed.\n            *\n            * @param dist- distance of matched string\n            * @param lc- (match length - MIN_MATCH) or unmatched char (if dist === 0)\n            */\n           function ct_tally(dist, lc) {\n             l_buf[last_lit++] = lc;\n             if (dist === 0) {\n               // lc is the unmatched char\n               dyn_ltree[lc].fc++;\n             } else {\n               // Here, lc is the match length - MIN_MATCH\n               dist--; // dist = match distance - 1\n               // Assert((ush)dist < (ush)MAX_DIST && (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) && (ush)D_CODE(dist) < (ush)D_CODES,  \"ct_tally: bad match\");\n\n               dyn_ltree[length_code[lc] + LITERALS + 1].fc++;\n               dyn_dtree[D_CODE(dist)].fc++;\n\n               d_buf[last_dist++] = dist;\n               flags |= flag_bit;\n             }\n             flag_bit <<= 1;\n\n             // Output the flags if they fill a byte\n             if ((last_lit & 7) === 0) {\n               flag_buf[last_flags++] = flags;\n               flags = 0;\n               flag_bit = 1;\n             }\n             // Try to guess if it is profitable to stop the current block here\n             if (compr_level > 2 && (last_lit & 0xfff) === 0) {\n               // Compute an upper bound for the compressed length\n               var out_length = last_lit * 8;\n               var in_length = strstart - block_start;\n               var dcode;\n\n               for (dcode = 0; dcode < D_CODES; dcode++) {\n                 out_length += dyn_dtree[dcode].fc * (5 + extra_dbits[dcode]);\n               }\n               out_length >>= 3;\n               // Trace((stderr,\"\\nlast_lit %u, last_dist %u, in %ld, out ~%ld(%ld%%) \", encoder->last_lit, encoder->last_dist, in_length, out_length, 100L - out_length*100L/in_length));\n               if (last_dist < parseInt(last_lit / 2, 10) && out_length < parseInt(in_length / 2, 10)) {\n                 return true;\n               }\n             }\n             return (last_lit === LIT_BUFSIZE - 1 || last_dist === DIST_BUFSIZE);\n             // We avoid equality with LIT_BUFSIZE because of wraparound at 64K\n             // on 16 bit machines and because stored blocks are restricted to\n             // 64K-1 bytes.\n           }\n\n           /* ==========================================================================\n            * Send the block data compressed using the given Huffman trees\n            *\n            * @param ltree- literal tree\n            * @param dtree- distance tree\n            */\n           function compress_block(ltree, dtree) {\n             var dist; // distance of matched string\n             var lc; // match length or unmatched char (if dist === 0)\n             var lx = 0; // running index in l_buf\n             var dx = 0; // running index in d_buf\n             var fx = 0; // running index in flag_buf\n             var flag = 0; // current flags\n             var code; // the code to send\n             var extra; // number of extra bits to send\n\n             if (last_lit !== 0) {\n               do {\n                 if ((lx & 7) === 0) {\n                   flag = flag_buf[fx++];\n                 }\n                 lc = l_buf[lx++] & 0xff;\n                 if ((flag & 1) === 0) {\n                   SEND_CODE(lc, ltree);\n                   /* send a literal byte */\n                   //\tTracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n                 } else {\n                   // Here, lc is the match length - MIN_MATCH\n                   code = length_code[lc];\n                   SEND_CODE(code + LITERALS + 1, ltree); // send the length code\n                   extra = extra_lbits[code];\n                   if (extra !== 0) {\n                     lc -= base_length[code];\n                     send_bits(lc, extra); // send the extra length bits\n                   }\n                   dist = d_buf[dx++];\n                   // Here, dist is the match distance - 1\n                   code = D_CODE(dist);\n                   //\tAssert (code < D_CODES, \"bad d_code\");\n\n                   SEND_CODE(code, dtree); // send the distance code\n                   extra = extra_dbits[code];\n                   if (extra !== 0) {\n                     dist -= base_dist[code];\n                     send_bits(dist, extra); // send the extra distance bits\n                   }\n                 } // literal or match pair ?\n                 flag >>= 1;\n               } while (lx < last_lit);\n             }\n\n             SEND_CODE(END_BLOCK, ltree);\n           }\n\n           /* ==========================================================================\n            * Send a value on a given number of bits.\n            * IN assertion: length <= 16 and value fits in length bits.\n            *\n            * @param value- value to send\n            * @param length- number of bits\n            */\n           var Buf_size = 16; // bit size of bi_buf\n           function send_bits(value, length) {\n             // If not enough room in bi_buf, use (valid) bits from bi_buf and\n             // (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))\n             // unused bits in value.\n             if (bi_valid > Buf_size - length) {\n               bi_buf |= (value << bi_valid);\n               put_short(bi_buf);\n               bi_buf = (value >> (Buf_size - bi_valid));\n               bi_valid += length - Buf_size;\n             } else {\n               bi_buf |= value << bi_valid;\n               bi_valid += length;\n             }\n           }\n\n           /* ==========================================================================\n            * Reverse the first len bits of a code, using straightforward code (a faster\n            * method would use a table)\n            * IN assertion: 1 <= len <= 15\n            *\n            * @param code- the value to invert\n            * @param len- its bit length\n            */\n           function bi_reverse(code, len) {\n             var res = 0;\n             do {\n               res |= code & 1;\n               code >>= 1;\n               res <<= 1;\n             } while (--len > 0);\n             return res >> 1;\n           }\n\n           /* ==========================================================================\n            * Write out any remaining bits in an incomplete byte.\n            */\n           function bi_windup() {\n             if (bi_valid > 8) {\n               put_short(bi_buf);\n             } else if (bi_valid > 0) {\n               put_byte(bi_buf);\n             }\n             bi_buf = 0;\n             bi_valid = 0;\n           }\n\n           function qoutbuf() {\n             var q, i;\n             if (outcnt !== 0) {\n               q = new_queue();\n               if (qhead === null) {\n                 qhead = qtail = q;\n               } else {\n                 qtail = qtail.next = q;\n               }\n               q.len = outcnt - outoff;\n               // System.arraycopy(outbuf, outoff, q.ptr, 0, q.len);\n               for (i = 0; i < q.len; i++) {\n                 q.ptr[i] = outbuf[outoff + i];\n               }\n               outcnt = outoff = 0;\n             }\n           }\n\n           function deflate(arr, level) {\n             var i, j, buff;\n\n             deflate_data = arr;\n             deflate_pos = 0;\n             if (typeof level === \"undefined\") {\n               level = DEFAULT_LEVEL;\n             }\n             deflate_start(level);\n\n             buff = [];\n\n             do {\n               i = deflate_internal(buff, buff.length, 1024);\n             } while (i > 0);\n\n             deflate_data = null; // G.C.\n             return buff;\n           }\n\n           deflate.DEFAULT_LEVEL = DEFAULT_LEVEL;\n           return deflate;\n         })();\n         var inflate = (function () {\n           /* constant parameters */\n           var WSIZE = 32768, // Sliding Window size\n             STORED_BLOCK = 0,\n             STATIC_TREES = 1,\n             DYN_TREES = 2,\n\n           /* for inflate */\n             lbits = 9, // bits in base literal/length lookup table\n             dbits = 6, // bits in base distance lookup table\n\n           /* variables (inflate) */\n             slide,\n             wp, // current position in slide\n             fixed_tl = null, // inflate static\n             fixed_td, // inflate static\n             fixed_bl, // inflate static\n             fixed_bd, // inflate static\n             bit_buf, // bit buffer\n             bit_len, // bits in bit buffer\n             method,\n             eof,\n             copy_leng,\n             copy_dist,\n             tl, // literal length decoder table\n             td, // literal distance decoder table\n             bl, // number of bits decoded by tl\n             bd, // number of bits decoded by td\n\n             inflate_data,\n             inflate_pos,\n\n\n           /* constant tables (inflate) */\n             MASK_BITS = [\n               0x0000,\n               0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,\n               0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff\n             ],\n           // Tables for deflate from PKZIP's appnote.txt.\n           // Copy lengths for literal codes 257..285\n             cplens = [\n               3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n               35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n             ],\n           /* note: see note #13 above about the 258 in this list. */\n           // Extra bits for literal codes 257..285\n             cplext = [\n               0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n               3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99 // 99==invalid\n             ],\n           // Copy offsets for distance codes 0..29\n             cpdist = [\n               1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n               257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n               8193, 12289, 16385, 24577\n             ],\n           // Extra bits for distance codes\n             cpdext = [\n               0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\n               7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\n               12, 12, 13, 13\n             ],\n           // Order of the bit length code lengths\n             border = [\n               16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15\n             ];\n           /* objects (inflate) */\n\n           function HuftList() {\n             this.next = null;\n             this.list = null;\n           }\n\n           function HuftNode() {\n             this.e = 0; // number of extra bits or operation\n             this.b = 0; // number of bits in this code or subcode\n\n             // union\n             this.n = 0; // literal, length base, or distance base\n             this.t = null; // (HuftNode) pointer to next level of table\n           }\n\n           /*\n            * @param b-  code lengths in bits (all assumed <= BMAX)\n            * @param n- number of codes (assumed <= N_MAX)\n            * @param s- number of simple-valued codes (0..s-1)\n            * @param d- list of base values for non-simple codes\n            * @param e- list of extra bits for non-simple codes\n            * @param mm- maximum lookup bits\n            */\n           function HuftBuild(b, n, s, d, e, mm) {\n             this.BMAX = 16; // maximum bit length of any code\n             this.N_MAX = 288; // maximum number of codes in any set\n             this.status = 0; // 0: success, 1: incomplete table, 2: bad input\n             this.root = null; // (HuftList) starting table\n             this.m = 0; // maximum lookup bits, returns actual\n\n             /* Given a list of code lengths and a maximum table size, make a set of\n              tables to decode that set of codes. Return zero on success, one if\n              the given code set is incomplete (the tables are still built in this\n              case), two if the input is invalid (all zero length codes or an\n              oversubscribed set of lengths), and three if not enough memory.\n              The code with value 256 is special, and the tables are constructed\n              so that no bits beyond that code are fetched when that code is\n              decoded. */\n             var a; // counter for codes of length k\n             var c = [];\n             var el; // length of EOB code (value 256)\n             var f; // i repeats in table every f entries\n             var g; // maximum code length\n             var h; // table level\n             var i; // counter, current code\n             var j; // counter\n             var k; // number of bits in current code\n             var lx = [];\n             var p; // pointer into c[], b[], or v[]\n             var pidx; // index of p\n             var q; // (HuftNode) points to current table\n             var r = new HuftNode(); // table entry for structure assignment\n             var u = [];\n             var v = [];\n             var w;\n             var x = [];\n             var xp; // pointer into x or c\n             var y; // number of dummy codes added\n             var z; // number of entries in current table\n             var o;\n             var tail; // (HuftList)\n\n             tail = this.root = null;\n\n             // bit length count table\n             for (i = 0; i < this.BMAX + 1; i++) {\n               c[i] = 0;\n             }\n             // stack of bits per table\n             for (i = 0; i < this.BMAX + 1; i++) {\n               lx[i] = 0;\n             }\n             // HuftNode[BMAX][]  table stack\n             for (i = 0; i < this.BMAX; i++) {\n               u[i] = null;\n             }\n             // values in order of bit length\n             for (i = 0; i < this.N_MAX; i++) {\n               v[i] = 0;\n             }\n             // bit offsets, then code stack\n             for (i = 0; i < this.BMAX + 1; i++) {\n               x[i] = 0;\n             }\n\n             // Generate counts for each bit length\n             el = n > 256 ? b[256] : this.BMAX; // set length of EOB code, if any\n             p = b;\n             pidx = 0;\n             i = n;\n             do {\n               c[p[pidx]]++; // assume all entries <= BMAX\n               pidx++;\n             } while (--i > 0);\n             if (c[0] === n) { // null input--all zero length codes\n               this.root = null;\n               this.m = 0;\n               this.status = 0;\n               return;\n             }\n\n             // Find minimum and maximum length, bound *m by those\n             for (j = 1; j <= this.BMAX; j++) {\n               if (c[j] !== 0) {\n                 break;\n               }\n             }\n             k = j; // minimum code length\n             if (mm < j) {\n               mm = j;\n             }\n             for (i = this.BMAX; i !== 0; i--) {\n               if (c[i] !== 0) {\n                 break;\n               }\n             }\n             g = i; // maximum code length\n             if (mm > i) {\n               mm = i;\n             }\n\n             // Adjust last length count to fill out codes, if needed\n             for (y = 1 << j; j < i; j++, y <<= 1) {\n               if ((y -= c[j]) < 0) {\n                 this.status = 2; // bad input: more codes than bits\n                 this.m = mm;\n                 return;\n               }\n             }\n             if ((y -= c[i]) < 0) {\n               this.status = 2;\n               this.m = mm;\n               return;\n             }\n             c[i] += y;\n\n             // Generate starting offsets into the value table for each length\n             x[1] = j = 0;\n             p = c;\n             pidx = 1;\n             xp = 2;\n             while (--i > 0) { // note that i == g from above\n               x[xp++] = (j += p[pidx++]);\n             }\n\n             // Make a table of values in order of bit lengths\n             p = b;\n             pidx = 0;\n             i = 0;\n             do {\n               if ((j = p[pidx++]) !== 0) {\n                 v[x[j]++] = i;\n               }\n             } while (++i < n);\n             n = x[g]; // set n to length of v\n\n             // Generate the Huffman codes and for each, make the table entries\n             x[0] = i = 0; // first Huffman code is zero\n             p = v;\n             pidx = 0; // grab values in bit order\n             h = -1; // no tables yet--level -1\n             w = lx[0] = 0; // no bits decoded yet\n             q = null; // ditto\n             z = 0; // ditto\n\n             // go through the bit lengths (k already is bits in shortest code)\n             for (null; k <= g; k++) {\n               a = c[k];\n               while (a-- > 0) {\n                 // here i is the Huffman code of length k bits for value p[pidx]\n                 // make tables up to required level\n                 while (k > w + lx[1 + h]) {\n                   w += lx[1 + h]; // add bits already decoded\n                   h++;\n\n                   // compute minimum size table less than or equal to *m bits\n                   z = (z = g - w) > mm ? mm : z; // upper limit\n                   if ((f = 1 << (j = k - w)) > a + 1) { // try a k-w bit table\n                     // too few codes for k-w bit table\n                     f -= a + 1; // deduct codes from patterns left\n                     xp = k;\n                     while (++j < z) { // try smaller tables up to z bits\n                       if ((f <<= 1) <= c[++xp]) {\n                         break; // enough codes to use up j bits\n                       }\n                       f -= c[xp]; // else deduct codes from patterns\n                     }\n                   }\n                   if (w + j > el && w < el) {\n                     j = el - w; // make EOB code end at table\n                   }\n                   z = 1 << j; // table entries for j-bit table\n                   lx[1 + h] = j; // set table size in stack\n\n                   // allocate and link in new table\n                   q = [];\n                   for (o = 0; o < z; o++) {\n                     q[o] = new HuftNode();\n                   }\n\n                   if (!tail) {\n                     tail = this.root = new HuftList();\n                   } else {\n                     tail = tail.next = new HuftList();\n                   }\n                   tail.next = null;\n                   tail.list = q;\n                   u[h] = q; // table starts after link\n\n                   /* connect to last table, if there is one */\n                   if (h > 0) {\n                     x[h] = i; // save pattern for backing up\n                     r.b = lx[h]; // bits to dump before this table\n                     r.e = 16 + j; // bits in this table\n                     r.t = q; // pointer to this table\n                     j = (i & ((1 << w) - 1)) >> (w - lx[h]);\n                     u[h - 1][j].e = r.e;\n                     u[h - 1][j].b = r.b;\n                     u[h - 1][j].n = r.n;\n                     u[h - 1][j].t = r.t;\n                   }\n                 }\n\n                 // set up table entry in r\n                 r.b = k - w;\n                 if (pidx >= n) {\n                   r.e = 99; // out of values--invalid code\n                 } else if (p[pidx] < s) {\n                   r.e = (p[pidx] < 256 ? 16 : 15); // 256 is end-of-block code\n                   r.n = p[pidx++]; // simple code is just the value\n                 } else {\n                   r.e = e[p[pidx] - s]; // non-simple--look up in lists\n                   r.n = d[p[pidx++] - s];\n                 }\n\n                 // fill code-like entries with r //\n                 f = 1 << (k - w);\n                 for (j = i >> w; j < z; j += f) {\n                   q[j].e = r.e;\n                   q[j].b = r.b;\n                   q[j].n = r.n;\n                   q[j].t = r.t;\n                 }\n\n                 // backwards increment the k-bit code i\n                 for (j = 1 << (k - 1); (i & j) !== 0; j >>= 1) {\n                   i ^= j;\n                 }\n                 i ^= j;\n\n                 // backup over finished tables\n                 while ((i & ((1 << w) - 1)) !== x[h]) {\n                   w -= lx[h]; // don't need to update q\n                   h--;\n                 }\n               }\n             }\n\n             /* return actual size of base table */\n             this.m = lx[1];\n\n             /* Return true (1) if we were given an incomplete table */\n             this.status = ((y !== 0 && g !== 1) ? 1 : 0);\n           }\n\n\n           /* routines (inflate) */\n\n           function GET_BYTE() {\n             if (inflate_data.length === inflate_pos) {\n               return -1;\n             }\n             return inflate_data[inflate_pos++] & 0xff;\n           }\n\n           function NEEDBITS(n) {\n             while (bit_len < n) {\n               bit_buf |= GET_BYTE() << bit_len;\n               bit_len += 8;\n             }\n           }\n\n           function GETBITS(n) {\n             return bit_buf & MASK_BITS[n];\n           }\n\n           function DUMPBITS(n) {\n             bit_buf >>= n;\n             bit_len -= n;\n           }\n\n           function inflate_codes(buff, off, size) {\n             // inflate (decompress) the codes in a deflated (compressed) block.\n             // Return an error code or zero if it all goes ok.\n             var e; // table entry flag/number of extra bits\n             var t; // (HuftNode) pointer to table entry\n             var n;\n\n             if (size === 0) {\n               return 0;\n             }\n\n             // inflate the coded data\n             n = 0;\n             for (; ;) { // do until end of block\n               NEEDBITS(bl);\n               t = tl.list[GETBITS(bl)];\n               e = t.e;\n               while (e > 16) {\n                 if (e === 99) {\n                   return -1;\n                 }\n                 DUMPBITS(t.b);\n                 e -= 16;\n                 NEEDBITS(e);\n                 t = t.t[GETBITS(e)];\n                 e = t.e;\n               }\n               DUMPBITS(t.b);\n\n               if (e === 16) { // then it's a literal\n                 wp &= WSIZE - 1;\n                 buff[off + n++] = slide[wp++] = t.n;\n                 if (n === size) {\n                   return size;\n                 }\n                 continue;\n               }\n\n               // exit if end of block\n               if (e === 15) {\n                 break;\n               }\n\n               // it's an EOB or a length\n\n               // get length of block to copy\n               NEEDBITS(e);\n               copy_leng = t.n + GETBITS(e);\n               DUMPBITS(e);\n\n               // decode distance of block to copy\n               NEEDBITS(bd);\n               t = td.list[GETBITS(bd)];\n               e = t.e;\n\n               while (e > 16) {\n                 if (e === 99) {\n                   return -1;\n                 }\n                 DUMPBITS(t.b);\n                 e -= 16;\n                 NEEDBITS(e);\n                 t = t.t[GETBITS(e)];\n                 e = t.e;\n               }\n               DUMPBITS(t.b);\n               NEEDBITS(e);\n               copy_dist = wp - t.n - GETBITS(e);\n               DUMPBITS(e);\n\n               // do the copy\n               while (copy_leng > 0 && n < size) {\n                 copy_leng--;\n                 copy_dist &= WSIZE - 1;\n                 wp &= WSIZE - 1;\n                 buff[off + n++] = slide[wp++] = slide[copy_dist++];\n               }\n\n               if (n === size) {\n                 return size;\n               }\n             }\n\n             method = -1; // done\n             return n;\n           }\n\n           function inflate_stored(buff, off, size) {\n             /* \"decompress\" an inflated type 0 (stored) block. */\n             var n;\n\n             // go to byte boundary\n             n = bit_len & 7;\n             DUMPBITS(n);\n\n             // get the length and its complement\n             NEEDBITS(16);\n             n = GETBITS(16);\n             DUMPBITS(16);\n             NEEDBITS(16);\n             if (n !== ((~bit_buf) & 0xffff)) {\n               return -1; // error in compressed data\n             }\n             DUMPBITS(16);\n\n             // read and output the compressed data\n             copy_leng = n;\n\n             n = 0;\n             while (copy_leng > 0 && n < size) {\n               copy_leng--;\n               wp &= WSIZE - 1;\n               NEEDBITS(8);\n               buff[off + n++] = slide[wp++] = GETBITS(8);\n               DUMPBITS(8);\n             }\n\n             if (copy_leng === 0) {\n               method = -1; // done\n             }\n             return n;\n           }\n\n           function inflate_fixed(buff, off, size) {\n             // decompress an inflated type 1 (fixed Huffman codes) block.  We should\n             // either replace this with a custom decoder, or at least precompute the\n             // Huffman tables.\n\n             // if first time, set up tables for fixed blocks\n             if (!fixed_tl) {\n               var i; // temporary variable\n               var l = []; // 288 length list for huft_build (initialized below)\n               var h; // HuftBuild\n\n               // literal table\n               for (i = 0; i < 144; i++) {\n                 l[i] = 8;\n               }\n               for (null; i < 256; i++) {\n                 l[i] = 9;\n               }\n               for (null; i < 280; i++) {\n                 l[i] = 7;\n               }\n               for (null; i < 288; i++) { // make a complete, but wrong code set\n                 l[i] = 8;\n               }\n               fixed_bl = 7;\n\n               h = new HuftBuild(l, 288, 257, cplens, cplext, fixed_bl);\n               if (h.status !== 0) {\n                 console.error(\"HufBuild error: \" + h.status);\n                 return -1;\n               }\n               fixed_tl = h.root;\n               fixed_bl = h.m;\n\n               // distance table\n               for (i = 0; i < 30; i++) { // make an incomplete code set\n                 l[i] = 5;\n               }\n               fixed_bd = 5;\n\n               h = new HuftBuild(l, 30, 0, cpdist, cpdext, fixed_bd);\n               if (h.status > 1) {\n                 fixed_tl = null;\n                 console.error(\"HufBuild error: \" + h.status);\n                 return -1;\n               }\n               fixed_td = h.root;\n               fixed_bd = h.m;\n             }\n\n             tl = fixed_tl;\n             td = fixed_td;\n             bl = fixed_bl;\n             bd = fixed_bd;\n             return inflate_codes(buff, off, size);\n           }\n\n           function inflate_dynamic(buff, off, size) {\n             // decompress an inflated type 2 (dynamic Huffman codes) block.\n             var i; // temporary variables\n             var j;\n             var l; // last length\n             var n; // number of lengths to get\n             var t; // (HuftNode) literal/length code table\n             var nb; // number of bit length codes\n             var nl; // number of literal/length codes\n             var nd; // number of distance codes\n             var ll = [];\n             var h; // (HuftBuild)\n\n             // literal/length and distance code lengths\n             for (i = 0; i < 286 + 30; i++) {\n               ll[i] = 0;\n             }\n\n             // read in table lengths\n             NEEDBITS(5);\n             nl = 257 + GETBITS(5); // number of literal/length codes\n             DUMPBITS(5);\n             NEEDBITS(5);\n             nd = 1 + GETBITS(5); // number of distance codes\n             DUMPBITS(5);\n             NEEDBITS(4);\n             nb = 4 + GETBITS(4); // number of bit length codes\n             DUMPBITS(4);\n             if (nl > 286 || nd > 30) {\n               return -1; // bad lengths\n             }\n\n             // read in bit-length-code lengths\n             for (j = 0; j < nb; j++) {\n               NEEDBITS(3);\n               ll[border[j]] = GETBITS(3);\n               DUMPBITS(3);\n             }\n             for (null; j < 19; j++) {\n               ll[border[j]] = 0;\n             }\n\n             // build decoding table for trees--single level, 7 bit lookup\n             bl = 7;\n             h = new HuftBuild(ll, 19, 19, null, null, bl);\n             if (h.status !== 0) {\n               return -1; // incomplete code set\n             }\n\n             tl = h.root;\n             bl = h.m;\n\n             // read in literal and distance code lengths\n             n = nl + nd;\n             i = l = 0;\n             while (i < n) {\n               NEEDBITS(bl);\n               t = tl.list[GETBITS(bl)];\n               j = t.b;\n               DUMPBITS(j);\n               j = t.n;\n               if (j < 16) { // length of code in bits (0..15)\n                 ll[i++] = l = j; // save last length in l\n               } else if (j === 16) { // repeat last length 3 to 6 times\n                 NEEDBITS(2);\n                 j = 3 + GETBITS(2);\n                 DUMPBITS(2);\n                 if (i + j > n) {\n                   return -1;\n                 }\n                 while (j-- > 0) {\n                   ll[i++] = l;\n                 }\n               } else if (j === 17) { // 3 to 10 zero length codes\n                 NEEDBITS(3);\n                 j = 3 + GETBITS(3);\n                 DUMPBITS(3);\n                 if (i + j > n) {\n                   return -1;\n                 }\n                 while (j-- > 0) {\n                   ll[i++] = 0;\n                 }\n                 l = 0;\n               } else { // j === 18: 11 to 138 zero length codes\n                 NEEDBITS(7);\n                 j = 11 + GETBITS(7);\n                 DUMPBITS(7);\n                 if (i + j > n) {\n                   return -1;\n                 }\n                 while (j-- > 0) {\n                   ll[i++] = 0;\n                 }\n                 l = 0;\n               }\n             }\n\n             // build the decoding tables for literal/length and distance codes\n             bl = lbits;\n             h = new HuftBuild(ll, nl, 257, cplens, cplext, bl);\n             if (bl === 0) { // no literals or lengths\n               h.status = 1;\n             }\n             if (h.status !== 0) {\n               if (h.status !== 1) {\n                 return -1; // incomplete code set\n               }\n               // **incomplete literal tree**\n             }\n             tl = h.root;\n             bl = h.m;\n\n             for (i = 0; i < nd; i++) {\n               ll[i] = ll[i + nl];\n             }\n             bd = dbits;\n             h = new HuftBuild(ll, nd, 0, cpdist, cpdext, bd);\n             td = h.root;\n             bd = h.m;\n\n             if (bd === 0 && nl > 257) { // lengths but no distances\n               // **incomplete distance tree**\n               return -1;\n             }\n             /*\n              if (h.status === 1) {\n              // **incomplete distance tree**\n              }\n              */\n             if (h.status !== 0) {\n               return -1;\n             }\n\n             // decompress until an end-of-block code\n             return inflate_codes(buff, off, size);\n           }\n\n           function inflate_start() {\n             if (!slide) {\n               slide = []; // new Array(2 * WSIZE); // slide.length is never called\n             }\n             wp = 0;\n             bit_buf = 0;\n             bit_len = 0;\n             method = -1;\n             eof = false;\n             copy_leng = copy_dist = 0;\n             tl = null;\n           }\n\n           function inflate_internal(buff, off, size) {\n             // decompress an inflated entry\n             var n, i;\n\n             n = 0;\n             while (n < size) {\n               if (eof && method === -1) {\n                 return n;\n               }\n\n               if (copy_leng > 0) {\n                 if (method !== STORED_BLOCK) {\n                   // STATIC_TREES or DYN_TREES\n                   while (copy_leng > 0 && n < size) {\n                     copy_leng--;\n                     copy_dist &= WSIZE - 1;\n                     wp &= WSIZE - 1;\n                     buff[off + n++] = slide[wp++] = slide[copy_dist++];\n                   }\n                 } else {\n                   while (copy_leng > 0 && n < size) {\n                     copy_leng--;\n                     wp &= WSIZE - 1;\n                     NEEDBITS(8);\n                     buff[off + n++] = slide[wp++] = GETBITS(8);\n                     DUMPBITS(8);\n                   }\n                   if (copy_leng === 0) {\n                     method = -1; // done\n                   }\n                 }\n                 if (n === size) {\n                   return n;\n                 }\n               }\n\n               if (method === -1) {\n                 if (eof) {\n                   break;\n                 }\n\n                 // read in last block bit\n                 NEEDBITS(1);\n                 if (GETBITS(1) !== 0) {\n                   eof = true;\n                 }\n                 DUMPBITS(1);\n\n                 // read in block type\n                 NEEDBITS(2);\n                 method = GETBITS(2);\n                 DUMPBITS(2);\n                 tl = null;\n                 copy_leng = 0;\n               }\n\n               switch (method) {\n                 case STORED_BLOCK:\n                   i = inflate_stored(buff, off + n, size - n);\n                   break;\n\n                 case STATIC_TREES:\n                   if (tl) {\n                     i = inflate_codes(buff, off + n, size - n);\n                   } else {\n                     i = inflate_fixed(buff, off + n, size - n);\n                   }\n                   break;\n\n                 case DYN_TREES:\n                   if (tl) {\n                     i = inflate_codes(buff, off + n, size - n);\n                   } else {\n                     i = inflate_dynamic(buff, off + n, size - n);\n                   }\n                   break;\n\n                 default: // error\n                   i = -1;\n                   break;\n               }\n\n               if (i === -1) {\n                 if (eof) {\n                   return 0;\n                 }\n                 return -1;\n               }\n               n += i;\n             }\n             return n;\n           }\n\n           function inflate(arr) {\n             var buff = [], i;\n\n             inflate_start();\n             inflate_data = arr;\n             inflate_pos = 0;\n\n             do {\n               i = inflate_internal(buff, buff.length, 1024);\n             } while (i > 0);\n             inflate_data = null; // G.C.\n             return buff;\n           }\n\n           return inflate;\n         })();\n         return {\n           inflate: inflate,\n           deflate: deflate\n         }\n       })(),\n      ID1 = 0x1F,\n      ID2 = 0x8B,\n      compressionMethods = {\n        'deflate': 8\n      },\n      possibleFlags = {\n        'FTEXT': 0x01,\n        'FHCRC': 0x02,\n        'FEXTRA': 0x04,\n        'FNAME': 0x08,\n        'FCOMMENT': 0x10\n      },\n      osMap = {\n        'fat': 0, // FAT file system (DOS, OS/2, NT) + PKZIPW 2.50 VFAT, NTFS\n        'amiga': 1, // Amiga\n        'vmz': 2, // VMS (VAX or Alpha AXP)\n        'unix': 3, // Unix\n        'vm/cms': 4, // VM/CMS\n        'atari': 5, // Atari\n        'hpfs': 6, // HPFS file system (OS/2, NT 3.x)\n        'macintosh': 7, // Macintosh\n        'z-system': 8, // Z-System\n        'cplm': 9, // CP/M\n        'tops-20': 10, // TOPS-20\n        'ntfs': 11, // NTFS file system (NT)\n        'qdos': 12, // SMS/QDOS\n        'acorn': 13, // Acorn RISC OS\n        'vfat': 14, // VFAT file system (Win95, NT)\n        'vms': 15, // MVS (code also taken for PRIMOS)\n        'beos': 16, // BeOS (BeBox or PowerMac)\n        'tandem': 17, // Tandem/NSK\n        'theos': 18 // THEOS\n      },\n      os = 'unix',\n      DEFAULT_LEVEL = 6;\n\n    function putByte(n, arr) {\n      arr.push(n & 0xFF);\n    }\n\n    // LSB first\n    function putShort(n, arr) {\n      arr.push(n & 0xFF);\n      arr.push(n >>> 8);\n    }\n\n    // LSB first\n    function putLong(n, arr) {\n      putShort(n & 0xffff, arr);\n      putShort(n >>> 16, arr);\n    }\n\n    function putString(s, arr) {\n      var i, len = s.length;\n      for (i = 0; i < len; i += 1) {\n        putByte(s.charCodeAt(i), arr);\n      }\n    }\n\n    function readByte(arr) {\n      return arr.shift();\n    }\n\n    function readShort(arr) {\n      return arr.shift() | (arr.shift() << 8);\n    }\n\n    function readLong(arr) {\n      var n1 = readShort(arr),\n        n2 = readShort(arr);\n\n      // JavaScript can't handle bits in the position 32\n      // we'll emulate this by removing the left-most bit (if it exists)\n      // and add it back in via multiplication, which does work\n      if (n2 > 32768) {\n        n2 -= 32768;\n\n        return ((n2 << 16) | n1) + 32768 * Math.pow(2, 16);\n      }\n\n      return (n2 << 16) | n1;\n    }\n\n    function readString(arr) {\n      var charArr = [];\n\n      // turn all bytes into chars until the terminating null\n      while (arr[0] !== 0) {\n        charArr.push(String.fromCharCode(arr.shift()));\n      }\n\n      // throw away terminating null\n      arr.shift();\n\n      // join all characters into a cohesive string\n      return charArr.join('');\n    }\n\n    /*\n     * Reads n number of bytes and return as an array.\n     *\n     * @param arr- Array of bytes to read from\n     * @param n- Number of bytes to read\n     */\n    function readBytes(arr, n) {\n      var i, ret = [];\n      for (i = 0; i < n; i += 1) {\n        ret.push(arr.shift());\n      }\n\n      return ret;\n    }\n\n    /*\n     * ZIPs a file in GZIP format. The format is as given by the spec, found at:\n     * http://www.gzip.org/zlib/rfc-gzip.html\n     *\n     * Omitted parts in this implementation:\n     */\n    function zip(data, options) {\n      var flags = 0,\n        level,\n        crc, out = [];\n\n      if (!options) {\n        options = {};\n      }\n      level = options.level || DEFAULT_LEVEL;\n\n      if (typeof data === 'string') {\n        data = Array.prototype.map.call(data, function (char) {\n          return char.charCodeAt(0);\n        });\n      }\n\n      // magic number marking this file as GZIP\n      putByte(ID1, out);\n      putByte(ID2, out);\n\n      putByte(compressionMethods['deflate'], out);\n\n      if (options.name) {\n        flags |= possibleFlags['FNAME'];\n      }\n\n      putByte(flags, out);\n      putLong(options.timestamp || parseInt(Date.now() / 1000, 10), out);\n\n      // put deflate args (extra flags)\n      if (level === 1) {\n        // fastest algorithm\n        putByte(4, out);\n      } else if (level === 9) {\n        // maximum compression (fastest algorithm)\n        putByte(2, out);\n      } else {\n        putByte(0, out);\n      }\n\n      // OS identifier\n      putByte(osMap[os], out);\n\n      if (options.name) {\n        // ignore the directory part\n        putString(options.name.substring(options.name.lastIndexOf('/') + 1), out);\n\n        // terminating null\n        putByte(0, out);\n      }\n\n      deflate.deflate(data, level).forEach(function (byte) {\n        putByte(byte, out);\n      });\n\n      putLong(parseInt(crc32(data), 16), out);\n      putLong(data.length, out);\n\n      return out;\n    }\n\n    function unzip(data, options) {\n      // start with a copy of the array\n      var arr = Array.prototype.slice.call(data, 0),\n        t,\n        compressionMethod,\n        flags,\n        mtime,\n        xFlags,\n        key,\n        os,\n        crc,\n        size,\n        res;\n\n      // check the first two bytes for the magic numbers\n      if (readByte(arr) !== ID1 || readByte(arr) !== ID2) {\n        throw 'Not a GZIP file';\n      }\n\n      t = readByte(arr);\n      t = Object.keys(compressionMethods).some(function (key) {\n        compressionMethod = key;\n        return compressionMethods[key] === t;\n      });\n\n      if (!t) {\n        throw 'Unsupported compression method';\n      }\n\n      flags = readByte(arr);\n      mtime = readLong(arr);\n      xFlags = readByte(arr);\n      t = readByte(arr);\n      Object.keys(osMap).some(function (key) {\n        if (osMap[key] === t) {\n          os = key;\n          return true;\n        }\n      });\n\n      // just throw away the bytes for now\n      if (flags & possibleFlags['FEXTRA']) {\n        t = readShort(arr);\n        readBytes(arr, t);\n      }\n\n      // just throw away for now\n      if (flags & possibleFlags['FNAME']) {\n        readString(arr);\n      }\n\n      // just throw away for now\n      if (flags & possibleFlags['FCOMMENT']) {\n        readString(arr);\n      }\n\n      // just throw away for now\n      if (flags & possibleFlags['FHCRC']) {\n        readShort(arr);\n      }\n\n      if (compressionMethod === 'deflate') {\n        // give deflate everything but the last 8 bytes\n        // the last 8 bytes are for the CRC32 checksum and filesize\n        res = deflate.inflate(arr.splice(0, arr.length - 8));\n      }\n\n      if (flags & possibleFlags['FTEXT']) {\n        res = Array.prototype.map.call(res, function (byte) {\n          return String.fromCharCode(byte);\n        }).join('');\n      }\n\n      crc = readLong(arr);\n      if (crc !== parseInt(crc32(res), 16)) {\n        throw 'Checksum does not match';\n      }\n\n      size = readLong(arr);\n      if (size !== res.length) {\n        throw 'Size of decompressed file not correct';\n      }\n\n      return res;\n    }\n\n    r.Gzip = {\n      zip:zip,\n      unzip: unzip,\n      get DEFAULT_LEVEL() {\n        return DEFAULT_LEVEL;\n      }\n    }\n})(window.R = (window.R||{}));\n"},1480:function(e,n){e.exports='/*! jQuery v3.1.1 | (c) jQuery Foundation | jquery.org/license */\n!function(a,b){"use strict";"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){"use strict";var c=[],d=a.document,e=Object.getPrototypeOf,f=c.slice,g=c.concat,h=c.push,i=c.indexOf,j={},k=j.toString,l=j.hasOwnProperty,m=l.toString,n=m.call(Object),o={};function p(a,b){b=b||d;var c=b.createElement("script");c.text=a,b.head.appendChild(c).parentNode.removeChild(c)}var q="3.1.1",r=function(a,b){return new r.fn.init(a,b)},s=/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,t=/^-ms-/,u=/-([a-z])/g,v=function(a,b){return b.toUpperCase()};r.fn=r.prototype={jquery:q,constructor:r,length:0,toArray:function(){return f.call(this)},get:function(a){return null==a?f.call(this):a<0?this[a+this.length]:this[a]},pushStack:function(a){var b=r.merge(this.constructor(),a);return b.prevObject=this,b},each:function(a){return r.each(this,a)},map:function(a){return this.pushStack(r.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(f.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(a<0?b:0);return this.pushStack(c>=0&&c<b?[this[c]]:[])},end:function(){return this.prevObject||this.constructor()},push:h,sort:c.sort,splice:c.splice},r.extend=r.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||r.isFunction(g)||(g={}),h===i&&(g=this,h--);h<i;h++)if(null!=(a=arguments[h]))for(b in a)c=g[b],d=a[b],g!==d&&(j&&d&&(r.isPlainObject(d)||(e=r.isArray(d)))?(e?(e=!1,f=c&&r.isArray(c)?c:[]):f=c&&r.isPlainObject(c)?c:{},g[b]=r.extend(j,f,d)):void 0!==d&&(g[b]=d));return g},r.extend({expando:"jQuery"+(q+Math.random()).replace(/\\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===r.type(a)},isArray:Array.isArray,isWindow:function(a){return null!=a&&a===a.window},isNumeric:function(a){var b=r.type(a);return("number"===b||"string"===b)&&!isNaN(a-parseFloat(a))},isPlainObject:function(a){var b,c;return!(!a||"[object Object]"!==k.call(a))&&(!(b=e(a))||(c=l.call(b,"constructor")&&b.constructor,"function"==typeof c&&m.call(c)===n))},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?j[k.call(a)]||"object":typeof a},globalEval:function(a){p(a)},camelCase:function(a){return a.replace(t,"ms-").replace(u,v)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b){var c,d=0;if(w(a)){for(c=a.length;d<c;d++)if(b.call(a[d],d,a[d])===!1)break}else for(d in a)if(b.call(a[d],d,a[d])===!1)break;return a},trim:function(a){return null==a?"":(a+"").replace(s,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(w(Object(a))?r.merge(c,"string"==typeof a?[a]:a):h.call(c,a)),c},inArray:function(a,b,c){return null==b?-1:i.call(b,a,c)},merge:function(a,b){for(var c=+b.length,d=0,e=a.length;d<c;d++)a[e++]=b[d];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;f<g;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,e,f=0,h=[];if(w(a))for(d=a.length;f<d;f++)e=b(a[f],f,c),null!=e&&h.push(e);else for(f in a)e=b(a[f],f,c),null!=e&&h.push(e);return g.apply([],h)},guid:1,proxy:function(a,b){var c,d,e;if("string"==typeof b&&(c=a[b],b=a,a=c),r.isFunction(a))return d=f.call(arguments,2),e=function(){return a.apply(b||this,d.concat(f.call(arguments)))},e.guid=a.guid=a.guid||r.guid++,e},now:Date.now,support:o}),"function"==typeof Symbol&&(r.fn[Symbol.iterator]=c[Symbol.iterator]),r.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(a,b){j["[object "+b+"]"]=b.toLowerCase()});function w(a){var b=!!a&&"length"in a&&a.length,c=r.type(a);return"function"!==c&&!r.isWindow(a)&&("array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a)}var x=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+1*new Date,v=a.document,w=0,x=0,y=ha(),z=ha(),A=ha(),B=function(a,b){return a===b&&(l=!0),0},C={}.hasOwnProperty,D=[],E=D.pop,F=D.push,G=D.push,H=D.slice,I=function(a,b){for(var c=0,d=a.length;c<d;c++)if(a[c]===b)return c;return-1},J="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",K="[\\\\x20\\\\t\\\\r\\\\n\\\\f]",L="(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+",M="\\\\["+K+"*("+L+")(?:"+K+"*([*^$|!~]?=)"+K+"*(?:\'((?:\\\\\\\\.|[^\\\\\\\\\'])*)\'|\\"((?:\\\\\\\\.|[^\\\\\\\\\\"])*)\\"|("+L+"))|)"+K+"*\\\\]",N=":("+L+")(?:\\\\(((\'((?:\\\\\\\\.|[^\\\\\\\\\'])*)\'|\\"((?:\\\\\\\\.|[^\\\\\\\\\\"])*)\\")|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|"+M+")*)|.*)\\\\)|)",O=new RegExp(K+"+","g"),P=new RegExp("^"+K+"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)"+K+"+$","g"),Q=new RegExp("^"+K+"*,"+K+"*"),R=new RegExp("^"+K+"*([>+~]|"+K+")"+K+"*"),S=new RegExp("="+K+"*([^\\\\]\'\\"]*?)"+K+"*\\\\]","g"),T=new RegExp(N),U=new RegExp("^"+L+"$"),V={ID:new RegExp("^#("+L+")"),CLASS:new RegExp("^\\\\.("+L+")"),TAG:new RegExp("^("+L+"|[*])"),ATTR:new RegExp("^"+M),PSEUDO:new RegExp("^"+N),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\("+K+"*(even|odd|(([+-]|)(\\\\d*)n|)"+K+"*(?:([+-]|)"+K+"*(\\\\d+)|))"+K+"*\\\\)|)","i"),bool:new RegExp("^(?:"+J+")$","i"),needsContext:new RegExp("^"+K+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\("+K+"*((?:-\\\\d)?\\\\d*)"+K+"*\\\\)|)(?=[^-]|$)","i")},W=/^(?:input|select|textarea|button)$/i,X=/^h\\d$/i,Y=/^[^{]+\\{\\s*\\[native \\w/,Z=/^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,$=/[+~]/,_=new RegExp("\\\\\\\\([\\\\da-f]{1,6}"+K+"?|("+K+")|.)","ig"),aa=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:d<0?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)},ba=/([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,ca=function(a,b){return b?"\\0"===a?"\\ufffd":a.slice(0,-1)+"\\\\"+a.charCodeAt(a.length-1).toString(16)+" ":"\\\\"+a},da=function(){m()},ea=ta(function(a){return a.disabled===!0&&("form"in a||"label"in a)},{dir:"parentNode",next:"legend"});try{G.apply(D=H.call(v.childNodes),v.childNodes),D[v.childNodes.length].nodeType}catch(fa){G={apply:D.length?function(a,b){F.apply(a,H.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function ga(a,b,d,e){var f,h,j,k,l,o,r,s=b&&b.ownerDocument,w=b?b.nodeType:9;if(d=d||[],"string"!=typeof a||!a||1!==w&&9!==w&&11!==w)return d;if(!e&&((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,p)){if(11!==w&&(l=Z.exec(a)))if(f=l[1]){if(9===w){if(!(j=b.getElementById(f)))return d;if(j.id===f)return d.push(j),d}else if(s&&(j=s.getElementById(f))&&t(b,j)&&j.id===f)return d.push(j),d}else{if(l[2])return G.apply(d,b.getElementsByTagName(a)),d;if((f=l[3])&&c.getElementsByClassName&&b.getElementsByClassName)return G.apply(d,b.getElementsByClassName(f)),d}if(c.qsa&&!A[a+" "]&&(!q||!q.test(a))){if(1!==w)s=b,r=a;else if("object"!==b.nodeName.toLowerCase()){(k=b.getAttribute("id"))?k=k.replace(ba,ca):b.setAttribute("id",k=u),o=g(a),h=o.length;while(h--)o[h]="#"+k+" "+sa(o[h]);r=o.join(","),s=$.test(a)&&qa(b.parentNode)||b}if(r)try{return G.apply(d,s.querySelectorAll(r)),d}catch(x){}finally{k===u&&b.removeAttribute("id")}}}return i(a.replace(P,"$1"),b,d,e)}function ha(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function ia(a){return a[u]=!0,a}function ja(a){var b=n.createElement("fieldset");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function ka(a,b){var c=a.split("|"),e=c.length;while(e--)d.attrHandle[c[e]]=b}function la(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&a.sourceIndex-b.sourceIndex;if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function ma(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function na(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function oa(a){return function(b){return"form"in b?b.parentNode&&b.disabled===!1?"label"in b?"label"in b.parentNode?b.parentNode.disabled===a:b.disabled===a:b.isDisabled===a||b.isDisabled!==!a&&ea(b)===a:b.disabled===a:"label"in b&&b.disabled===a}}function pa(a){return ia(function(b){return b=+b,ia(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function qa(a){return a&&"undefined"!=typeof a.getElementsByTagName&&a}c=ga.support={},f=ga.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return!!b&&"HTML"!==b.nodeName},m=ga.setDocument=function(a){var b,e,g=a?a.ownerDocument||a:v;return g!==n&&9===g.nodeType&&g.documentElement?(n=g,o=n.documentElement,p=!f(n),v!==n&&(e=n.defaultView)&&e.top!==e&&(e.addEventListener?e.addEventListener("unload",da,!1):e.attachEvent&&e.attachEvent("onunload",da)),c.attributes=ja(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=ja(function(a){return a.appendChild(n.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=Y.test(n.getElementsByClassName),c.getById=ja(function(a){return o.appendChild(a).id=u,!n.getElementsByName||!n.getElementsByName(u).length}),c.getById?(d.filter.ID=function(a){var b=a.replace(_,aa);return function(a){return a.getAttribute("id")===b}},d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c=b.getElementById(a);return c?[c]:[]}}):(d.filter.ID=function(a){var b=a.replace(_,aa);return function(a){var c="undefined"!=typeof a.getAttributeNode&&a.getAttributeNode("id");return c&&c.value===b}},d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c,d,e,f=b.getElementById(a);if(f){if(c=f.getAttributeNode("id"),c&&c.value===a)return[f];e=b.getElementsByName(a),d=0;while(f=e[d++])if(c=f.getAttributeNode("id"),c&&c.value===a)return[f]}return[]}}),d.find.TAG=c.getElementsByTagName?function(a,b){return"undefined"!=typeof b.getElementsByTagName?b.getElementsByTagName(a):c.qsa?b.querySelectorAll(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){if("undefined"!=typeof b.getElementsByClassName&&p)return b.getElementsByClassName(a)},r=[],q=[],(c.qsa=Y.test(n.querySelectorAll))&&(ja(function(a){o.appendChild(a).innerHTML="<a id=\'"+u+"\'></a><select id=\'"+u+"-\\r\\\\\' msallowcapture=\'\'><option selected=\'\'></option></select>",a.querySelectorAll("[msallowcapture^=\'\']").length&&q.push("[*^$]="+K+"*(?:\'\'|\\"\\")"),a.querySelectorAll("[selected]").length||q.push("\\\\["+K+"*(?:value|"+J+")"),a.querySelectorAll("[id~="+u+"-]").length||q.push("~="),a.querySelectorAll(":checked").length||q.push(":checked"),a.querySelectorAll("a#"+u+"+*").length||q.push(".#.+[+~]")}),ja(function(a){a.innerHTML="<a href=\'\' disabled=\'disabled\'></a><select disabled=\'disabled\'><option/></select>";var b=n.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&q.push("name"+K+"*[*^$|!~]?="),2!==a.querySelectorAll(":enabled").length&&q.push(":enabled",":disabled"),o.appendChild(a).disabled=!0,2!==a.querySelectorAll(":disabled").length&&q.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),q.push(",.*:")})),(c.matchesSelector=Y.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ja(function(a){c.disconnectedMatch=s.call(a,"*"),s.call(a,"[s!=\'\']:x"),r.push("!=",N)}),q=q.length&&new RegExp(q.join("|")),r=r.length&&new RegExp(r.join("|")),b=Y.test(o.compareDocumentPosition),t=b||Y.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===n||a.ownerDocument===v&&t(v,a)?-1:b===n||b.ownerDocument===v&&t(v,b)?1:k?I(k,a)-I(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,e=a.parentNode,f=b.parentNode,g=[a],h=[b];if(!e||!f)return a===n?-1:b===n?1:e?-1:f?1:k?I(k,a)-I(k,b):0;if(e===f)return la(a,b);c=a;while(c=c.parentNode)g.unshift(c);c=b;while(c=c.parentNode)h.unshift(c);while(g[d]===h[d])d++;return d?la(g[d],h[d]):g[d]===v?-1:h[d]===v?1:0},n):n},ga.matches=function(a,b){return ga(a,null,null,b)},ga.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(S,"=\'$1\']"),c.matchesSelector&&p&&!A[b+" "]&&(!r||!r.test(b))&&(!q||!q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return ga(b,n,null,[a]).length>0},ga.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},ga.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&C.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},ga.escape=function(a){return(a+"").replace(ba,ca)},ga.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},ga.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=ga.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=ga.selectors={cacheLength:50,createPseudo:ia,match:V,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(_,aa),a[3]=(a[3]||a[4]||a[5]||"").replace(_,aa),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||ga.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&ga.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return V.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||"":c&&T.test(c)&&(b=g(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(_,aa).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+" "];return b||(b=new RegExp("(^|"+K+")"+a+"("+K+"|$)"))&&y(a,function(a){return b.test("string"==typeof a.className&&a.className||"undefined"!=typeof a.getAttribute&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=ga.attr(d,a);return null==e?"!="===b:!b||(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e.replace(O," ")+" ").indexOf(c)>-1:"|="===b&&(e===c||e.slice(0,c.length+1)===c+"-"))}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h,t=!1;if(q){if(f){while(p){m=b;while(m=m[p])if(h?m.nodeName.toLowerCase()===r:1===m.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){m=q,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n&&j[2],m=n&&q.childNodes[n];while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if(1===m.nodeType&&++t&&m===b){k[a]=[w,n,t];break}}else if(s&&(m=b,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n),t===!1)while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if((h?m.nodeName.toLowerCase()===r:1===m.nodeType)&&++t&&(s&&(l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),k[a]=[w,t]),m===b))break;return t-=e,t===d||t%d===0&&t/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||ga.error("unsupported pseudo: "+a);return e[u]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?ia(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=I(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:ia(function(a){var b=[],c=[],d=h(a.replace(P,"$1"));return d[u]?ia(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),b[0]=null,!c.pop()}}),has:ia(function(a){return function(b){return ga(a,b).length>0}}),contains:ia(function(a){return a=a.replace(_,aa),function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:ia(function(a){return U.test(a||"")||ga.error("unsupported lang: "+a),a=a.replace(_,aa).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:oa(!1),disabled:oa(!0),checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return X.test(a.nodeName)},input:function(a){return W.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:pa(function(){return[0]}),last:pa(function(a,b){return[b-1]}),eq:pa(function(a,b,c){return[c<0?c+b:c]}),even:pa(function(a,b){for(var c=0;c<b;c+=2)a.push(c);return a}),odd:pa(function(a,b){for(var c=1;c<b;c+=2)a.push(c);return a}),lt:pa(function(a,b,c){for(var d=c<0?c+b:c;--d>=0;)a.push(d);return a}),gt:pa(function(a,b,c){for(var d=c<0?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=ma(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=na(b);function ra(){}ra.prototype=d.filters=d.pseudos,d.setFilters=new ra,g=ga.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){c&&!(e=Q.exec(h))||(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=R.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(P," ")}),h=h.slice(c.length));for(g in d.filter)!(e=V[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?ga.error(a):z(a,i).slice(0)};function sa(a){for(var b=0,c=a.length,d="";b<c;b++)d+=a[b].value;return d}function ta(a,b,c){var d=b.dir,e=b.next,f=e||d,g=c&&"parentNode"===f,h=x++;return b.first?function(b,c,e){while(b=b[d])if(1===b.nodeType||g)return a(b,c,e);return!1}:function(b,c,i){var j,k,l,m=[w,h];if(i){while(b=b[d])if((1===b.nodeType||g)&&a(b,c,i))return!0}else while(b=b[d])if(1===b.nodeType||g)if(l=b[u]||(b[u]={}),k=l[b.uniqueID]||(l[b.uniqueID]={}),e&&e===b.nodeName.toLowerCase())b=b[d]||b;else{if((j=k[f])&&j[0]===w&&j[1]===h)return m[2]=j[2];if(k[f]=m,m[2]=a(b,c,i))return!0}return!1}}function ua(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function va(a,b,c){for(var d=0,e=b.length;d<e;d++)ga(a,b[d],c);return c}function wa(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;h<i;h++)(f=a[h])&&(c&&!c(f,d,e)||(g.push(f),j&&b.push(h)));return g}function xa(a,b,c,d,e,f){return d&&!d[u]&&(d=xa(d)),e&&!e[u]&&(e=xa(e,f)),ia(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||va(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:wa(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=wa(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?I(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=wa(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):G.apply(g,r)})}function ya(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[" "],i=g?1:0,k=ta(function(a){return a===b},h,!0),l=ta(function(a){return I(b,a)>-1},h,!0),m=[function(a,c,d){var e=!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d));return b=null,e}];i<f;i++)if(c=d.relative[a[i].type])m=[ta(ua(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;e<f;e++)if(d.relative[a[e].type])break;return xa(i>1&&ua(m),i>1&&sa(a.slice(0,i-1).concat({value:" "===a[i-2].type?"*":""})).replace(P,"$1"),c,i<e&&ya(a.slice(i,e)),e<f&&ya(a=a.slice(e)),e<f&&sa(a))}m.push(c)}return ua(m)}function za(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,o,q,r=0,s="0",t=f&&[],u=[],v=j,x=f||e&&d.find.TAG("*",k),y=w+=null==v?1:Math.random()||.1,z=x.length;for(k&&(j=g===n||g||k);s!==z&&null!=(l=x[s]);s++){if(e&&l){o=0,g||l.ownerDocument===n||(m(l),h=!p);while(q=a[o++])if(q(l,g||n,h)){i.push(l);break}k&&(w=y)}c&&((l=!q&&l)&&r--,f&&t.push(l))}if(r+=s,c&&s!==r){o=0;while(q=b[o++])q(t,u,g,h);if(f){if(r>0)while(s--)t[s]||u[s]||(u[s]=E.call(i));u=wa(u)}G.apply(i,u),k&&!f&&u.length>0&&r+b.length>1&&ga.uniqueSort(i)}return k&&(w=y,j=v),t};return c?ia(f):f}return h=ga.compile=function(a,b){var c,d=[],e=[],f=A[a+" "];if(!f){b||(b=g(a)),c=b.length;while(c--)f=ya(b[c]),f[u]?d.push(f):e.push(f);f=A(a,za(e,d)),f.selector=a}return f},i=ga.select=function(a,b,c,e){var f,i,j,k,l,m="function"==typeof a&&a,n=!e&&g(a=m.selector||a);if(c=c||[],1===n.length){if(i=n[0]=n[0].slice(0),i.length>2&&"ID"===(j=i[0]).type&&9===b.nodeType&&p&&d.relative[i[1].type]){if(b=(d.find.ID(j.matches[0].replace(_,aa),b)||[])[0],!b)return c;m&&(b=b.parentNode),a=a.slice(i.shift().value.length)}f=V.needsContext.test(a)?0:i.length;while(f--){if(j=i[f],d.relative[k=j.type])break;if((l=d.find[k])&&(e=l(j.matches[0].replace(_,aa),$.test(i[0].type)&&qa(b.parentNode)||b))){if(i.splice(f,1),a=e.length&&sa(i),!a)return G.apply(c,e),c;break}}}return(m||h(a,n))(e,b,!p,c,!b||$.test(a)&&qa(b.parentNode)||b),c},c.sortStable=u.split("").sort(B).join("")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ja(function(a){return 1&a.compareDocumentPosition(n.createElement("fieldset"))}),ja(function(a){return a.innerHTML="<a href=\'#\'></a>","#"===a.firstChild.getAttribute("href")})||ka("type|href|height|width",function(a,b,c){if(!c)return a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&ja(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||ka("value",function(a,b,c){if(!c&&"input"===a.nodeName.toLowerCase())return a.defaultValue}),ja(function(a){return null==a.getAttribute("disabled")})||ka(J,function(a,b,c){var d;if(!c)return a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),ga}(a);r.find=x,r.expr=x.selectors,r.expr[":"]=r.expr.pseudos,r.uniqueSort=r.unique=x.uniqueSort,r.text=x.getText,r.isXMLDoc=x.isXML,r.contains=x.contains,r.escapeSelector=x.escape;var y=function(a,b,c){var d=[],e=void 0!==c;while((a=a[b])&&9!==a.nodeType)if(1===a.nodeType){if(e&&r(a).is(c))break;d.push(a)}return d},z=function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c},A=r.expr.match.needsContext,B=/^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i,C=/^.[^:#\\[\\.,]*$/;function D(a,b,c){return r.isFunction(b)?r.grep(a,function(a,d){return!!b.call(a,d,a)!==c}):b.nodeType?r.grep(a,function(a){return a===b!==c}):"string"!=typeof b?r.grep(a,function(a){return i.call(b,a)>-1!==c}):C.test(b)?r.filter(b,a,c):(b=r.filter(b,a),r.grep(a,function(a){return i.call(b,a)>-1!==c&&1===a.nodeType}))}r.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?r.find.matchesSelector(d,a)?[d]:[]:r.find.matches(a,r.grep(b,function(a){return 1===a.nodeType}))},r.fn.extend({find:function(a){var b,c,d=this.length,e=this;if("string"!=typeof a)return this.pushStack(r(a).filter(function(){for(b=0;b<d;b++)if(r.contains(e[b],this))return!0}));for(c=this.pushStack([]),b=0;b<d;b++)r.find(a,e[b],c);return d>1?r.uniqueSort(c):c},filter:function(a){return this.pushStack(D(this,a||[],!1))},not:function(a){return this.pushStack(D(this,a||[],!0))},is:function(a){return!!D(this,"string"==typeof a&&A.test(a)?r(a):a||[],!1).length}});var E,F=/^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,G=r.fn.init=function(a,b,c){var e,f;if(!a)return this;if(c=c||E,"string"==typeof a){if(e="<"===a[0]&&">"===a[a.length-1]&&a.length>=3?[null,a,null]:F.exec(a),!e||!e[1]&&b)return!b||b.jquery?(b||c).find(a):this.constructor(b).find(a);if(e[1]){if(b=b instanceof r?b[0]:b,r.merge(this,r.parseHTML(e[1],b&&b.nodeType?b.ownerDocument||b:d,!0)),B.test(e[1])&&r.isPlainObject(b))for(e in b)r.isFunction(this[e])?this[e](b[e]):this.attr(e,b[e]);return this}return f=d.getElementById(e[2]),f&&(this[0]=f,this.length=1),this}return a.nodeType?(this[0]=a,this.length=1,this):r.isFunction(a)?void 0!==c.ready?c.ready(a):a(r):r.makeArray(a,this)};G.prototype=r.fn,E=r(d);var H=/^(?:parents|prev(?:Until|All))/,I={children:!0,contents:!0,next:!0,prev:!0};r.fn.extend({has:function(a){var b=r(a,this),c=b.length;return this.filter(function(){for(var a=0;a<c;a++)if(r.contains(this,b[a]))return!0})},closest:function(a,b){var c,d=0,e=this.length,f=[],g="string"!=typeof a&&r(a);if(!A.test(a))for(;d<e;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&r.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?r.uniqueSort(f):f)},index:function(a){return a?"string"==typeof a?i.call(r(a),this[0]):i.call(this,a.jquery?a[0]:a):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(r.uniqueSort(r.merge(this.get(),r(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function J(a,b){while((a=a[b])&&1!==a.nodeType);return a}r.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return y(a,"parentNode")},parentsUntil:function(a,b,c){return y(a,"parentNode",c)},next:function(a){return J(a,"nextSibling")},prev:function(a){return J(a,"previousSibling")},nextAll:function(a){return y(a,"nextSibling")},prevAll:function(a){return y(a,"previousSibling")},nextUntil:function(a,b,c){return y(a,"nextSibling",c)},prevUntil:function(a,b,c){return y(a,"previousSibling",c)},siblings:function(a){return z((a.parentNode||{}).firstChild,a)},children:function(a){return z(a.firstChild)},contents:function(a){return a.contentDocument||r.merge([],a.childNodes)}},function(a,b){r.fn[a]=function(c,d){var e=r.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=r.filter(d,e)),this.length>1&&(I[a]||r.uniqueSort(e),H.test(a)&&e.reverse()),this.pushStack(e)}});var K=/[^\\x20\\t\\r\\n\\f]+/g;function L(a){var b={};return r.each(a.match(K)||[],function(a,c){b[c]=!0}),b}r.Callbacks=function(a){a="string"==typeof a?L(a):r.extend({},a);var b,c,d,e,f=[],g=[],h=-1,i=function(){for(e=a.once,d=b=!0;g.length;h=-1){c=g.shift();while(++h<f.length)f[h].apply(c[0],c[1])===!1&&a.stopOnFalse&&(h=f.length,c=!1)}a.memory||(c=!1),b=!1,e&&(f=c?[]:"")},j={add:function(){return f&&(c&&!b&&(h=f.length-1,g.push(c)),function d(b){r.each(b,function(b,c){r.isFunction(c)?a.unique&&j.has(c)||f.push(c):c&&c.length&&"string"!==r.type(c)&&d(c)})}(arguments),c&&!b&&i()),this},remove:function(){return r.each(arguments,function(a,b){var c;while((c=r.inArray(b,f,c))>-1)f.splice(c,1),c<=h&&h--}),this},has:function(a){return a?r.inArray(a,f)>-1:f.length>0},empty:function(){return f&&(f=[]),this},disable:function(){return e=g=[],f=c="",this},disabled:function(){return!f},lock:function(){return e=g=[],c||b||(f=c=""),this},locked:function(){return!!e},fireWith:function(a,c){return e||(c=c||[],c=[a,c.slice?c.slice():c],g.push(c),b||i()),this},fire:function(){return j.fireWith(this,arguments),this},fired:function(){return!!d}};return j};function M(a){return a}function N(a){throw a}function O(a,b,c){var d;try{a&&r.isFunction(d=a.promise)?d.call(a).done(b).fail(c):a&&r.isFunction(d=a.then)?d.call(a,b,c):b.call(void 0,a)}catch(a){c.call(void 0,a)}}r.extend({Deferred:function(b){var c=[["notify","progress",r.Callbacks("memory"),r.Callbacks("memory"),2],["resolve","done",r.Callbacks("once memory"),r.Callbacks("once memory"),0,"resolved"],["reject","fail",r.Callbacks("once memory"),r.Callbacks("once memory"),1,"rejected"]],d="pending",e={state:function(){return d},always:function(){return f.done(arguments).fail(arguments),this},"catch":function(a){return e.then(null,a)},pipe:function(){var a=arguments;return r.Deferred(function(b){r.each(c,function(c,d){var e=r.isFunction(a[d[4]])&&a[d[4]];f[d[1]](function(){var a=e&&e.apply(this,arguments);a&&r.isFunction(a.promise)?a.promise().progress(b.notify).done(b.resolve).fail(b.reject):b[d[0]+"With"](this,e?[a]:arguments)})}),a=null}).promise()},then:function(b,d,e){var f=0;function g(b,c,d,e){return function(){var h=this,i=arguments,j=function(){var a,j;if(!(b<f)){if(a=d.apply(h,i),a===c.promise())throw new TypeError("Thenable self-resolution");j=a&&("object"==typeof a||"function"==typeof a)&&a.then,r.isFunction(j)?e?j.call(a,g(f,c,M,e),g(f,c,N,e)):(f++,j.call(a,g(f,c,M,e),g(f,c,N,e),g(f,c,M,c.notifyWith))):(d!==M&&(h=void 0,i=[a]),(e||c.resolveWith)(h,i))}},k=e?j:function(){try{j()}catch(a){r.Deferred.exceptionHook&&r.Deferred.exceptionHook(a,k.stackTrace),b+1>=f&&(d!==N&&(h=void 0,i=[a]),c.rejectWith(h,i))}};b?k():(r.Deferred.getStackHook&&(k.stackTrace=r.Deferred.getStackHook()),a.setTimeout(k))}}return r.Deferred(function(a){c[0][3].add(g(0,a,r.isFunction(e)?e:M,a.notifyWith)),c[1][3].add(g(0,a,r.isFunction(b)?b:M)),c[2][3].add(g(0,a,r.isFunction(d)?d:N))}).promise()},promise:function(a){return null!=a?r.extend(a,e):e}},f={};return r.each(c,function(a,b){var g=b[2],h=b[5];e[b[1]]=g.add,h&&g.add(function(){d=h},c[3-a][2].disable,c[0][2].lock),g.add(b[3].fire),f[b[0]]=function(){return f[b[0]+"With"](this===f?void 0:this,arguments),this},f[b[0]+"With"]=g.fireWith}),e.promise(f),b&&b.call(f,f),f},when:function(a){var b=arguments.length,c=b,d=Array(c),e=f.call(arguments),g=r.Deferred(),h=function(a){return function(c){d[a]=this,e[a]=arguments.length>1?f.call(arguments):c,--b||g.resolveWith(d,e)}};if(b<=1&&(O(a,g.done(h(c)).resolve,g.reject),"pending"===g.state()||r.isFunction(e[c]&&e[c].then)))return g.then();while(c--)O(e[c],h(c),g.reject);return g.promise()}});var P=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;r.Deferred.exceptionHook=function(b,c){a.console&&a.console.warn&&b&&P.test(b.name)&&a.console.warn("jQuery.Deferred exception: "+b.message,b.stack,c)},r.readyException=function(b){a.setTimeout(function(){throw b})};var Q=r.Deferred();r.fn.ready=function(a){return Q.then(a)["catch"](function(a){r.readyException(a)}),this},r.extend({isReady:!1,readyWait:1,holdReady:function(a){a?r.readyWait++:r.ready(!0)},ready:function(a){(a===!0?--r.readyWait:r.isReady)||(r.isReady=!0,a!==!0&&--r.readyWait>0||Q.resolveWith(d,[r]))}}),r.ready.then=Q.then;function R(){d.removeEventListener("DOMContentLoaded",R),\na.removeEventListener("load",R),r.ready()}"complete"===d.readyState||"loading"!==d.readyState&&!d.documentElement.doScroll?a.setTimeout(r.ready):(d.addEventListener("DOMContentLoaded",R),a.addEventListener("load",R));var S=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===r.type(c)){e=!0;for(h in c)S(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,r.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(r(a),c)})),b))for(;h<i;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f},T=function(a){return 1===a.nodeType||9===a.nodeType||!+a.nodeType};function U(){this.expando=r.expando+U.uid++}U.uid=1,U.prototype={cache:function(a){var b=a[this.expando];return b||(b={},T(a)&&(a.nodeType?a[this.expando]=b:Object.defineProperty(a,this.expando,{value:b,configurable:!0}))),b},set:function(a,b,c){var d,e=this.cache(a);if("string"==typeof b)e[r.camelCase(b)]=c;else for(d in b)e[r.camelCase(d)]=b[d];return e},get:function(a,b){return void 0===b?this.cache(a):a[this.expando]&&a[this.expando][r.camelCase(b)]},access:function(a,b,c){return void 0===b||b&&"string"==typeof b&&void 0===c?this.get(a,b):(this.set(a,b,c),void 0!==c?c:b)},remove:function(a,b){var c,d=a[this.expando];if(void 0!==d){if(void 0!==b){r.isArray(b)?b=b.map(r.camelCase):(b=r.camelCase(b),b=b in d?[b]:b.match(K)||[]),c=b.length;while(c--)delete d[b[c]]}(void 0===b||r.isEmptyObject(d))&&(a.nodeType?a[this.expando]=void 0:delete a[this.expando])}},hasData:function(a){var b=a[this.expando];return void 0!==b&&!r.isEmptyObject(b)}};var V=new U,W=new U,X=/^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,Y=/[A-Z]/g;function Z(a){return"true"===a||"false"!==a&&("null"===a?null:a===+a+""?+a:X.test(a)?JSON.parse(a):a)}function $(a,b,c){var d;if(void 0===c&&1===a.nodeType)if(d="data-"+b.replace(Y,"-$&").toLowerCase(),c=a.getAttribute(d),"string"==typeof c){try{c=Z(c)}catch(e){}W.set(a,b,c)}else c=void 0;return c}r.extend({hasData:function(a){return W.hasData(a)||V.hasData(a)},data:function(a,b,c){return W.access(a,b,c)},removeData:function(a,b){W.remove(a,b)},_data:function(a,b,c){return V.access(a,b,c)},_removeData:function(a,b){V.remove(a,b)}}),r.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=W.get(f),1===f.nodeType&&!V.get(f,"hasDataAttrs"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf("data-")&&(d=r.camelCase(d.slice(5)),$(f,d,e[d])));V.set(f,"hasDataAttrs",!0)}return e}return"object"==typeof a?this.each(function(){W.set(this,a)}):S(this,function(b){var c;if(f&&void 0===b){if(c=W.get(f,a),void 0!==c)return c;if(c=$(f,a),void 0!==c)return c}else this.each(function(){W.set(this,a,b)})},null,b,arguments.length>1,null,!0)},removeData:function(a){return this.each(function(){W.remove(this,a)})}}),r.extend({queue:function(a,b,c){var d;if(a)return b=(b||"fx")+"queue",d=V.get(a,b),c&&(!d||r.isArray(c)?d=V.access(a,b,r.makeArray(c)):d.push(c)),d||[]},dequeue:function(a,b){b=b||"fx";var c=r.queue(a,b),d=c.length,e=c.shift(),f=r._queueHooks(a,b),g=function(){r.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return V.get(a,c)||V.access(a,c,{empty:r.Callbacks("once memory").add(function(){V.remove(a,[b+"queue",c])})})}}),r.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?r.queue(this[0],a):void 0===b?this:this.each(function(){var c=r.queue(this,a,b);r._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&r.dequeue(this,a)})},dequeue:function(a){return this.each(function(){r.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=r.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=V.get(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var _=/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,aa=new RegExp("^(?:([+-])=|)("+_+")([a-z%]*)$","i"),ba=["Top","Right","Bottom","Left"],ca=function(a,b){return a=b||a,"none"===a.style.display||""===a.style.display&&r.contains(a.ownerDocument,a)&&"none"===r.css(a,"display")},da=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};function ea(a,b,c,d){var e,f=1,g=20,h=d?function(){return d.cur()}:function(){return r.css(a,b,"")},i=h(),j=c&&c[3]||(r.cssNumber[b]?"":"px"),k=(r.cssNumber[b]||"px"!==j&&+i)&&aa.exec(r.css(a,b));if(k&&k[3]!==j){j=j||k[3],c=c||[],k=+i||1;do f=f||".5",k/=f,r.style(a,b,k+j);while(f!==(f=h()/i)&&1!==f&&--g)}return c&&(k=+k||+i||0,e=c[1]?k+(c[1]+1)*c[2]:+c[2],d&&(d.unit=j,d.start=k,d.end=e)),e}var fa={};function ga(a){var b,c=a.ownerDocument,d=a.nodeName,e=fa[d];return e?e:(b=c.body.appendChild(c.createElement(d)),e=r.css(b,"display"),b.parentNode.removeChild(b),"none"===e&&(e="block"),fa[d]=e,e)}function ha(a,b){for(var c,d,e=[],f=0,g=a.length;f<g;f++)d=a[f],d.style&&(c=d.style.display,b?("none"===c&&(e[f]=V.get(d,"display")||null,e[f]||(d.style.display="")),""===d.style.display&&ca(d)&&(e[f]=ga(d))):"none"!==c&&(e[f]="none",V.set(d,"display",c)));for(f=0;f<g;f++)null!=e[f]&&(a[f].style.display=e[f]);return a}r.fn.extend({show:function(){return ha(this,!0)},hide:function(){return ha(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){ca(this)?r(this).show():r(this).hide()})}});var ia=/^(?:checkbox|radio)$/i,ja=/<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]+)/i,ka=/^$|\\/(?:java|ecma)script/i,la={option:[1,"<select multiple=\'multiple\'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};la.optgroup=la.option,la.tbody=la.tfoot=la.colgroup=la.caption=la.thead,la.th=la.td;function ma(a,b){var c;return c="undefined"!=typeof a.getElementsByTagName?a.getElementsByTagName(b||"*"):"undefined"!=typeof a.querySelectorAll?a.querySelectorAll(b||"*"):[],void 0===b||b&&r.nodeName(a,b)?r.merge([a],c):c}function na(a,b){for(var c=0,d=a.length;c<d;c++)V.set(a[c],"globalEval",!b||V.get(b[c],"globalEval"))}var oa=/<|&#?\\w+;/;function pa(a,b,c,d,e){for(var f,g,h,i,j,k,l=b.createDocumentFragment(),m=[],n=0,o=a.length;n<o;n++)if(f=a[n],f||0===f)if("object"===r.type(f))r.merge(m,f.nodeType?[f]:f);else if(oa.test(f)){g=g||l.appendChild(b.createElement("div")),h=(ja.exec(f)||["",""])[1].toLowerCase(),i=la[h]||la._default,g.innerHTML=i[1]+r.htmlPrefilter(f)+i[2],k=i[0];while(k--)g=g.lastChild;r.merge(m,g.childNodes),g=l.firstChild,g.textContent=""}else m.push(b.createTextNode(f));l.textContent="",n=0;while(f=m[n++])if(d&&r.inArray(f,d)>-1)e&&e.push(f);else if(j=r.contains(f.ownerDocument,f),g=ma(l.appendChild(f),"script"),j&&na(g),c){k=0;while(f=g[k++])ka.test(f.type||"")&&c.push(f)}return l}!function(){var a=d.createDocumentFragment(),b=a.appendChild(d.createElement("div")),c=d.createElement("input");c.setAttribute("type","radio"),c.setAttribute("checked","checked"),c.setAttribute("name","t"),b.appendChild(c),o.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,b.innerHTML="<textarea>x</textarea>",o.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue}();var qa=d.documentElement,ra=/^key/,sa=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,ta=/^([^.]*)(?:\\.(.+)|)/;function ua(){return!0}function va(){return!1}function wa(){try{return d.activeElement}catch(a){}}function xa(a,b,c,d,e,f){var g,h;if("object"==typeof b){"string"!=typeof c&&(d=d||c,c=void 0);for(h in b)xa(a,h,c,d,b[h],f);return a}if(null==d&&null==e?(e=c,d=c=void 0):null==e&&("string"==typeof c?(e=d,d=void 0):(e=d,d=c,c=void 0)),e===!1)e=va;else if(!e)return a;return 1===f&&(g=e,e=function(a){return r().off(a),g.apply(this,arguments)},e.guid=g.guid||(g.guid=r.guid++)),a.each(function(){r.event.add(this,b,e,d,c)})}r.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,n,o,p,q=V.get(a);if(q){c.handler&&(f=c,c=f.handler,e=f.selector),e&&r.find.matchesSelector(qa,e),c.guid||(c.guid=r.guid++),(i=q.events)||(i=q.events={}),(g=q.handle)||(g=q.handle=function(b){return"undefined"!=typeof r&&r.event.triggered!==b.type?r.event.dispatch.apply(a,arguments):void 0}),b=(b||"").match(K)||[""],j=b.length;while(j--)h=ta.exec(b[j])||[],n=p=h[1],o=(h[2]||"").split(".").sort(),n&&(l=r.event.special[n]||{},n=(e?l.delegateType:l.bindType)||n,l=r.event.special[n]||{},k=r.extend({type:n,origType:p,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&r.expr.match.needsContext.test(e),namespace:o.join(".")},f),(m=i[n])||(m=i[n]=[],m.delegateCount=0,l.setup&&l.setup.call(a,d,o,g)!==!1||a.addEventListener&&a.addEventListener(n,g)),l.add&&(l.add.call(a,k),k.handler.guid||(k.handler.guid=c.guid)),e?m.splice(m.delegateCount++,0,k):m.push(k),r.event.global[n]=!0)}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,n,o,p,q=V.hasData(a)&&V.get(a);if(q&&(i=q.events)){b=(b||"").match(K)||[""],j=b.length;while(j--)if(h=ta.exec(b[j])||[],n=p=h[1],o=(h[2]||"").split(".").sort(),n){l=r.event.special[n]||{},n=(d?l.delegateType:l.bindType)||n,m=i[n]||[],h=h[2]&&new RegExp("(^|\\\\.)"+o.join("\\\\.(?:.*\\\\.|)")+"(\\\\.|$)"),g=f=m.length;while(f--)k=m[f],!e&&p!==k.origType||c&&c.guid!==k.guid||h&&!h.test(k.namespace)||d&&d!==k.selector&&("**"!==d||!k.selector)||(m.splice(f,1),k.selector&&m.delegateCount--,l.remove&&l.remove.call(a,k));g&&!m.length&&(l.teardown&&l.teardown.call(a,o,q.handle)!==!1||r.removeEvent(a,n,q.handle),delete i[n])}else for(n in i)r.event.remove(a,n+b[j],c,d,!0);r.isEmptyObject(i)&&V.remove(a,"handle events")}},dispatch:function(a){var b=r.event.fix(a),c,d,e,f,g,h,i=new Array(arguments.length),j=(V.get(this,"events")||{})[b.type]||[],k=r.event.special[b.type]||{};for(i[0]=b,c=1;c<arguments.length;c++)i[c]=arguments[c];if(b.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,b)!==!1){h=r.event.handlers.call(this,b,j),c=0;while((f=h[c++])&&!b.isPropagationStopped()){b.currentTarget=f.elem,d=0;while((g=f.handlers[d++])&&!b.isImmediatePropagationStopped())b.rnamespace&&!b.rnamespace.test(g.namespace)||(b.handleObj=g,b.data=g.data,e=((r.event.special[g.origType]||{}).handle||g.handler).apply(f.elem,i),void 0!==e&&(b.result=e)===!1&&(b.preventDefault(),b.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,b),b.result}},handlers:function(a,b){var c,d,e,f,g,h=[],i=b.delegateCount,j=a.target;if(i&&j.nodeType&&!("click"===a.type&&a.button>=1))for(;j!==this;j=j.parentNode||this)if(1===j.nodeType&&("click"!==a.type||j.disabled!==!0)){for(f=[],g={},c=0;c<i;c++)d=b[c],e=d.selector+" ",void 0===g[e]&&(g[e]=d.needsContext?r(e,this).index(j)>-1:r.find(e,this,null,[j]).length),g[e]&&f.push(d);f.length&&h.push({elem:j,handlers:f})}return j=this,i<b.length&&h.push({elem:j,handlers:b.slice(i)}),h},addProp:function(a,b){Object.defineProperty(r.Event.prototype,a,{enumerable:!0,configurable:!0,get:r.isFunction(b)?function(){if(this.originalEvent)return b(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[a]},set:function(b){Object.defineProperty(this,a,{enumerable:!0,configurable:!0,writable:!0,value:b})}})},fix:function(a){return a[r.expando]?a:new r.Event(a)},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==wa()&&this.focus)return this.focus(),!1},delegateType:"focusin"},blur:{trigger:function(){if(this===wa()&&this.blur)return this.blur(),!1},delegateType:"focusout"},click:{trigger:function(){if("checkbox"===this.type&&this.click&&r.nodeName(this,"input"))return this.click(),!1},_default:function(a){return r.nodeName(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}}},r.removeEvent=function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c)},r.Event=function(a,b){return this instanceof r.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?ua:va,this.target=a.target&&3===a.target.nodeType?a.target.parentNode:a.target,this.currentTarget=a.currentTarget,this.relatedTarget=a.relatedTarget):this.type=a,b&&r.extend(this,b),this.timeStamp=a&&a.timeStamp||r.now(),void(this[r.expando]=!0)):new r.Event(a,b)},r.Event.prototype={constructor:r.Event,isDefaultPrevented:va,isPropagationStopped:va,isImmediatePropagationStopped:va,isSimulated:!1,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=ua,a&&!this.isSimulated&&a.preventDefault()},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=ua,a&&!this.isSimulated&&a.stopPropagation()},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=ua,a&&!this.isSimulated&&a.stopImmediatePropagation(),this.stopPropagation()}},r.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,"char":!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:function(a){var b=a.button;return null==a.which&&ra.test(a.type)?null!=a.charCode?a.charCode:a.keyCode:!a.which&&void 0!==b&&sa.test(a.type)?1&b?1:2&b?3:4&b?2:0:a.which}},r.event.addProp),r.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(a,b){r.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return e&&(e===d||r.contains(d,e))||(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),r.fn.extend({on:function(a,b,c,d){return xa(this,a,b,c,d)},one:function(a,b,c,d){return xa(this,a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,r(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return b!==!1&&"function"!=typeof b||(c=b,b=void 0),c===!1&&(c=va),this.each(function(){r.event.remove(this,a,c,b)})}});var ya=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi,za=/<script|<style|<link/i,Aa=/checked\\s*(?:[^=]|=\\s*.checked.)/i,Ba=/^true\\/(.*)/,Ca=/^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;function Da(a,b){return r.nodeName(a,"table")&&r.nodeName(11!==b.nodeType?b:b.firstChild,"tr")?a.getElementsByTagName("tbody")[0]||a:a}function Ea(a){return a.type=(null!==a.getAttribute("type"))+"/"+a.type,a}function Fa(a){var b=Ba.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function Ga(a,b){var c,d,e,f,g,h,i,j;if(1===b.nodeType){if(V.hasData(a)&&(f=V.access(a),g=V.set(b,f),j=f.events)){delete g.handle,g.events={};for(e in j)for(c=0,d=j[e].length;c<d;c++)r.event.add(b,e,j[e][c])}W.hasData(a)&&(h=W.access(a),i=r.extend({},h),W.set(b,i))}}function Ha(a,b){var c=b.nodeName.toLowerCase();"input"===c&&ia.test(a.type)?b.checked=a.checked:"input"!==c&&"textarea"!==c||(b.defaultValue=a.defaultValue)}function Ia(a,b,c,d){b=g.apply([],b);var e,f,h,i,j,k,l=0,m=a.length,n=m-1,q=b[0],s=r.isFunction(q);if(s||m>1&&"string"==typeof q&&!o.checkClone&&Aa.test(q))return a.each(function(e){var f=a.eq(e);s&&(b[0]=q.call(this,e,f.html())),Ia(f,b,c,d)});if(m&&(e=pa(b,a[0].ownerDocument,!1,a,d),f=e.firstChild,1===e.childNodes.length&&(e=f),f||d)){for(h=r.map(ma(e,"script"),Ea),i=h.length;l<m;l++)j=e,l!==n&&(j=r.clone(j,!0,!0),i&&r.merge(h,ma(j,"script"))),c.call(a[l],j,l);if(i)for(k=h[h.length-1].ownerDocument,r.map(h,Fa),l=0;l<i;l++)j=h[l],ka.test(j.type||"")&&!V.access(j,"globalEval")&&r.contains(k,j)&&(j.src?r._evalUrl&&r._evalUrl(j.src):p(j.textContent.replace(Ca,""),k))}return a}function Ja(a,b,c){for(var d,e=b?r.filter(b,a):a,f=0;null!=(d=e[f]);f++)c||1!==d.nodeType||r.cleanData(ma(d)),d.parentNode&&(c&&r.contains(d.ownerDocument,d)&&na(ma(d,"script")),d.parentNode.removeChild(d));return a}r.extend({htmlPrefilter:function(a){return a.replace(ya,"<$1></$2>")},clone:function(a,b,c){var d,e,f,g,h=a.cloneNode(!0),i=r.contains(a.ownerDocument,a);if(!(o.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||r.isXMLDoc(a)))for(g=ma(h),f=ma(a),d=0,e=f.length;d<e;d++)Ha(f[d],g[d]);if(b)if(c)for(f=f||ma(a),g=g||ma(h),d=0,e=f.length;d<e;d++)Ga(f[d],g[d]);else Ga(a,h);return g=ma(h,"script"),g.length>0&&na(g,!i&&ma(a,"script")),h},cleanData:function(a){for(var b,c,d,e=r.event.special,f=0;void 0!==(c=a[f]);f++)if(T(c)){if(b=c[V.expando]){if(b.events)for(d in b.events)e[d]?r.event.remove(c,d):r.removeEvent(c,d,b.handle);c[V.expando]=void 0}c[W.expando]&&(c[W.expando]=void 0)}}}),r.fn.extend({detach:function(a){return Ja(this,a,!0)},remove:function(a){return Ja(this,a)},text:function(a){return S(this,function(a){return void 0===a?r.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=a)})},null,a,arguments.length)},append:function(){return Ia(this,arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=Da(this,a);b.appendChild(a)}})},prepend:function(){return Ia(this,arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=Da(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return Ia(this,arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return Ia(this,arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},empty:function(){for(var a,b=0;null!=(a=this[b]);b++)1===a.nodeType&&(r.cleanData(ma(a,!1)),a.textContent="");return this},clone:function(a,b){return a=null!=a&&a,b=null==b?a:b,this.map(function(){return r.clone(this,a,b)})},html:function(a){return S(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a&&1===b.nodeType)return b.innerHTML;if("string"==typeof a&&!za.test(a)&&!la[(ja.exec(a)||["",""])[1].toLowerCase()]){a=r.htmlPrefilter(a);try{for(;c<d;c++)b=this[c]||{},1===b.nodeType&&(r.cleanData(ma(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=[];return Ia(this,arguments,function(b){var c=this.parentNode;r.inArray(this,a)<0&&(r.cleanData(ma(this)),c&&c.replaceChild(b,this))},a)}}),r.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){r.fn[a]=function(a){for(var c,d=[],e=r(a),f=e.length-1,g=0;g<=f;g++)c=g===f?this:this.clone(!0),r(e[g])[b](c),h.apply(d,c.get());return this.pushStack(d)}});var Ka=/^margin/,La=new RegExp("^("+_+")(?!px)[a-z%]+$","i"),Ma=function(b){var c=b.ownerDocument.defaultView;return c&&c.opener||(c=a),c.getComputedStyle(b)};!function(){function b(){if(i){i.style.cssText="box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%",i.innerHTML="",qa.appendChild(h);var b=a.getComputedStyle(i);c="1%"!==b.top,g="2px"===b.marginLeft,e="4px"===b.width,i.style.marginRight="50%",f="4px"===b.marginRight,qa.removeChild(h),i=null}}var c,e,f,g,h=d.createElement("div"),i=d.createElement("div");i.style&&(i.style.backgroundClip="content-box",i.cloneNode(!0).style.backgroundClip="",o.clearCloneStyle="content-box"===i.style.backgroundClip,h.style.cssText="border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute",h.appendChild(i),r.extend(o,{pixelPosition:function(){return b(),c},boxSizingReliable:function(){return b(),e},pixelMarginRight:function(){return b(),f},reliableMarginLeft:function(){return b(),g}}))}();function Na(a,b,c){var d,e,f,g,h=a.style;return c=c||Ma(a),c&&(g=c.getPropertyValue(b)||c[b],""!==g||r.contains(a.ownerDocument,a)||(g=r.style(a,b)),!o.pixelMarginRight()&&La.test(g)&&Ka.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0!==g?g+"":g}function Oa(a,b){return{get:function(){return a()?void delete this.get:(this.get=b).apply(this,arguments)}}}var Pa=/^(none|table(?!-c[ea]).+)/,Qa={position:"absolute",visibility:"hidden",display:"block"},Ra={letterSpacing:"0",fontWeight:"400"},Sa=["Webkit","Moz","ms"],Ta=d.createElement("div").style;function Ua(a){if(a in Ta)return a;var b=a[0].toUpperCase()+a.slice(1),c=Sa.length;while(c--)if(a=Sa[c]+b,a in Ta)return a}function Va(a,b,c){var d=aa.exec(b);return d?Math.max(0,d[2]-(c||0))+(d[3]||"px"):b}function Wa(a,b,c,d,e){var f,g=0;for(f=c===(d?"border":"content")?4:"width"===b?1:0;f<4;f+=2)"margin"===c&&(g+=r.css(a,c+ba[f],!0,e)),d?("content"===c&&(g-=r.css(a,"padding"+ba[f],!0,e)),"margin"!==c&&(g-=r.css(a,"border"+ba[f]+"Width",!0,e))):(g+=r.css(a,"padding"+ba[f],!0,e),"padding"!==c&&(g+=r.css(a,"border"+ba[f]+"Width",!0,e)));return g}function Xa(a,b,c){var d,e=!0,f=Ma(a),g="border-box"===r.css(a,"boxSizing",!1,f);if(a.getClientRects().length&&(d=a.getBoundingClientRect()[b]),d<=0||null==d){if(d=Na(a,b,f),(d<0||null==d)&&(d=a.style[b]),La.test(d))return d;e=g&&(o.boxSizingReliable()||d===a.style[b]),d=parseFloat(d)||0}return d+Wa(a,b,c||(g?"border":"content"),e,f)+"px"}r.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=Na(a,"opacity");return""===c?"1":c}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":"cssFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=r.camelCase(b),i=a.style;return b=r.cssProps[h]||(r.cssProps[h]=Ua(h)||h),g=r.cssHooks[b]||r.cssHooks[h],void 0===c?g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:i[b]:(f=typeof c,"string"===f&&(e=aa.exec(c))&&e[1]&&(c=ea(a,b,e),f="number"),null!=c&&c===c&&("number"===f&&(c+=e&&e[3]||(r.cssNumber[h]?"":"px")),o.clearCloneStyle||""!==c||0!==b.indexOf("background")||(i[b]="inherit"),g&&"set"in g&&void 0===(c=g.set(a,c,d))||(i[b]=c)),void 0)}},css:function(a,b,c,d){var e,f,g,h=r.camelCase(b);return b=r.cssProps[h]||(r.cssProps[h]=Ua(h)||h),g=r.cssHooks[b]||r.cssHooks[h],g&&"get"in g&&(e=g.get(a,!0,c)),void 0===e&&(e=Na(a,b,d)),"normal"===e&&b in Ra&&(e=Ra[b]),""===c||c?(f=parseFloat(e),c===!0||isFinite(f)?f||0:e):e}}),r.each(["height","width"],function(a,b){r.cssHooks[b]={get:function(a,c,d){if(c)return!Pa.test(r.css(a,"display"))||a.getClientRects().length&&a.getBoundingClientRect().width?Xa(a,b,d):da(a,Qa,function(){return Xa(a,b,d)})},set:function(a,c,d){var e,f=d&&Ma(a),g=d&&Wa(a,b,d,"border-box"===r.css(a,"boxSizing",!1,f),f);return g&&(e=aa.exec(c))&&"px"!==(e[3]||"px")&&(a.style[b]=c,c=r.css(a,b)),Va(a,c,g)}}}),r.cssHooks.marginLeft=Oa(o.reliableMarginLeft,function(a,b){if(b)return(parseFloat(Na(a,"marginLeft"))||a.getBoundingClientRect().left-da(a,{marginLeft:0},function(){return a.getBoundingClientRect().left}))+"px"}),r.each({margin:"",padding:"",border:"Width"},function(a,b){r.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];d<4;d++)e[a+ba[d]+b]=f[d]||f[d-2]||f[0];return e}},Ka.test(a)||(r.cssHooks[a+b].set=Va)}),r.fn.extend({css:function(a,b){return S(this,function(a,b,c){var d,e,f={},g=0;if(r.isArray(b)){for(d=Ma(a),e=b.length;g<e;g++)f[b[g]]=r.css(a,b[g],!1,d);return f}return void 0!==c?r.style(a,b,c):r.css(a,b)},a,b,arguments.length>1)}});function Ya(a,b,c,d,e){return new Ya.prototype.init(a,b,c,d,e)}r.Tween=Ya,Ya.prototype={constructor:Ya,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||r.easing._default,this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(r.cssNumber[c]?"":"px")},cur:function(){var a=Ya.propHooks[this.prop];return a&&a.get?a.get(this):Ya.propHooks._default.get(this)},run:function(a){var b,c=Ya.propHooks[this.prop];return this.options.duration?this.pos=b=r.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):this.pos=b=a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):Ya.propHooks._default.set(this),this}},Ya.prototype.init.prototype=Ya.prototype,Ya.propHooks={_default:{get:function(a){var b;return 1!==a.elem.nodeType||null!=a.elem[a.prop]&&null==a.elem.style[a.prop]?a.elem[a.prop]:(b=r.css(a.elem,a.prop,""),b&&"auto"!==b?b:0)},set:function(a){r.fx.step[a.prop]?r.fx.step[a.prop](a):1!==a.elem.nodeType||null==a.elem.style[r.cssProps[a.prop]]&&!r.cssHooks[a.prop]?a.elem[a.prop]=a.now:r.style(a.elem,a.prop,a.now+a.unit)}}},Ya.propHooks.scrollTop=Ya.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},r.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2},_default:"swing"},r.fx=Ya.prototype.init,r.fx.step={};var Za,$a,_a=/^(?:toggle|show|hide)$/,ab=/queueHooks$/;function bb(){$a&&(a.requestAnimationFrame(bb),r.fx.tick())}function cb(){return a.setTimeout(function(){Za=void 0}),Za=r.now()}function db(a,b){var c,d=0,e={height:a};for(b=b?1:0;d<4;d+=2-b)c=ba[d],e["margin"+c]=e["padding"+c]=a;return b&&(e.opacity=e.width=a),e}function eb(a,b,c){for(var d,e=(hb.tweeners[b]||[]).concat(hb.tweeners["*"]),f=0,g=e.length;f<g;f++)if(d=e[f].call(c,b,a))return d}function fb(a,b,c){var d,e,f,g,h,i,j,k,l="width"in b||"height"in b,m=this,n={},o=a.style,p=a.nodeType&&ca(a),q=V.get(a,"fxshow");c.queue||(g=r._queueHooks(a,"fx"),null==g.unqueued&&(g.unqueued=0,h=g.empty.fire,g.empty.fire=function(){g.unqueued||h()}),g.unqueued++,m.always(function(){m.always(function(){g.unqueued--,r.queue(a,"fx").length||g.empty.fire()})}));for(d in b)if(e=b[d],_a.test(e)){if(delete b[d],f=f||"toggle"===e,e===(p?"hide":"show")){if("show"!==e||!q||void 0===q[d])continue;p=!0}n[d]=q&&q[d]||r.style(a,d)}if(i=!r.isEmptyObject(b),i||!r.isEmptyObject(n)){l&&1===a.nodeType&&(c.overflow=[o.overflow,o.overflowX,o.overflowY],j=q&&q.display,null==j&&(j=V.get(a,"display")),k=r.css(a,"display"),"none"===k&&(j?k=j:(ha([a],!0),j=a.style.display||j,k=r.css(a,"display"),ha([a]))),("inline"===k||"inline-block"===k&&null!=j)&&"none"===r.css(a,"float")&&(i||(m.done(function(){o.display=j}),null==j&&(k=o.display,j="none"===k?"":k)),o.display="inline-block")),c.overflow&&(o.overflow="hidden",m.always(function(){o.overflow=c.overflow[0],o.overflowX=c.overflow[1],o.overflowY=c.overflow[2]})),i=!1;for(d in n)i||(q?"hidden"in q&&(p=q.hidden):q=V.access(a,"fxshow",{display:j}),f&&(q.hidden=!p),p&&ha([a],!0),m.done(function(){p||ha([a]),V.remove(a,"fxshow");for(d in n)r.style(a,d,n[d])})),i=eb(p?q[d]:0,d,m),d in q||(q[d]=i.start,p&&(i.end=i.start,i.start=0))}}function gb(a,b){var c,d,e,f,g;for(c in a)if(d=r.camelCase(c),e=b[d],f=a[c],r.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=r.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function hb(a,b,c){var d,e,f=0,g=hb.prefilters.length,h=r.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=Za||cb(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;g<i;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),f<1&&i?c:(h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:r.extend({},b),opts:r.extend(!0,{specialEasing:{},easing:r.easing._default},c),originalProperties:b,originalOptions:c,startTime:Za||cb(),duration:c.duration,tweens:[],createTween:function(b,c){var d=r.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;c<d;c++)j.tweens[c].run(1);return b?(h.notifyWith(a,[j,1,0]),h.resolveWith(a,[j,b])):h.rejectWith(a,[j,b]),this}}),k=j.props;for(gb(k,j.opts.specialEasing);f<g;f++)if(d=hb.prefilters[f].call(j,a,k,j.opts))return r.isFunction(d.stop)&&(r._queueHooks(j.elem,j.opts.queue).stop=r.proxy(d.stop,d)),d;return r.map(k,eb,j),r.isFunction(j.opts.start)&&j.opts.start.call(a,j),r.fx.timer(r.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always)}r.Animation=r.extend(hb,{tweeners:{"*":[function(a,b){var c=this.createTween(a,b);return ea(c.elem,a,aa.exec(b),c),c}]},tweener:function(a,b){r.isFunction(a)?(b=a,a=["*"]):a=a.match(K);for(var c,d=0,e=a.length;d<e;d++)c=a[d],hb.tweeners[c]=hb.tweeners[c]||[],hb.tweeners[c].unshift(b)},prefilters:[fb],prefilter:function(a,b){b?hb.prefilters.unshift(a):hb.prefilters.push(a)}}),r.speed=function(a,b,c){var e=a&&"object"==typeof a?r.extend({},a):{complete:c||!c&&b||r.isFunction(a)&&a,duration:a,easing:c&&b||b&&!r.isFunction(b)&&b};return r.fx.off||d.hidden?e.duration=0:"number"!=typeof e.duration&&(e.duration in r.fx.speeds?e.duration=r.fx.speeds[e.duration]:e.duration=r.fx.speeds._default),null!=e.queue&&e.queue!==!0||(e.queue="fx"),e.old=e.complete,e.complete=function(){r.isFunction(e.old)&&e.old.call(this),e.queue&&r.dequeue(this,e.queue)},e},r.fn.extend({fadeTo:function(a,b,c,d){return this.filter(ca).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=r.isEmptyObject(a),f=r.speed(b,c,d),g=function(){var b=hb(this,r.extend({},a),f);(e||V.get(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=r.timers,g=V.get(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&ab.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));!b&&c||r.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=V.get(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=r.timers,g=d?d.length:0;for(c.finish=!0,r.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;b<g;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),r.each(["toggle","show","hide"],function(a,b){var c=r.fn[b];r.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(db(b,!0),a,d,e)}}),r.each({slideDown:db("show"),slideUp:db("hide"),slideToggle:db("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){r.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),r.timers=[],r.fx.tick=function(){var a,b=0,c=r.timers;for(Za=r.now();b<c.length;b++)a=c[b],a()||c[b]!==a||c.splice(b--,1);c.length||r.fx.stop(),Za=void 0},r.fx.timer=function(a){r.timers.push(a),a()?r.fx.start():r.timers.pop()},r.fx.interval=13,r.fx.start=function(){$a||($a=a.requestAnimationFrame?a.requestAnimationFrame(bb):a.setInterval(r.fx.tick,r.fx.interval))},r.fx.stop=function(){a.cancelAnimationFrame?a.cancelAnimationFrame($a):a.clearInterval($a),$a=null},r.fx.speeds={slow:600,fast:200,_default:400},r.fn.delay=function(b,c){return b=r.fx?r.fx.speeds[b]||b:b,c=c||"fx",this.queue(c,function(c,d){var e=a.setTimeout(c,b);d.stop=function(){a.clearTimeout(e)}})},function(){var a=d.createElement("input"),b=d.createElement("select"),c=b.appendChild(d.createElement("option"));a.type="checkbox",o.checkOn=""!==a.value,o.optSelected=c.selected,a=d.createElement("input"),a.value="t",a.type="radio",o.radioValue="t"===a.value}();var ib,jb=r.expr.attrHandle;r.fn.extend({attr:function(a,b){return S(this,r.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){r.removeAttr(this,a)})}}),r.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(3!==f&&8!==f&&2!==f)return"undefined"==typeof a.getAttribute?r.prop(a,b,c):(1===f&&r.isXMLDoc(a)||(e=r.attrHooks[b.toLowerCase()]||(r.expr.match.bool.test(b)?ib:void 0)),\nvoid 0!==c?null===c?void r.removeAttr(a,b):e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:(a.setAttribute(b,c+""),c):e&&"get"in e&&null!==(d=e.get(a,b))?d:(d=r.find.attr(a,b),null==d?void 0:d))},attrHooks:{type:{set:function(a,b){if(!o.radioValue&&"radio"===b&&r.nodeName(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}},removeAttr:function(a,b){var c,d=0,e=b&&b.match(K);if(e&&1===a.nodeType)while(c=e[d++])a.removeAttribute(c)}}),ib={set:function(a,b,c){return b===!1?r.removeAttr(a,c):a.setAttribute(c,c),c}},r.each(r.expr.match.bool.source.match(/\\w+/g),function(a,b){var c=jb[b]||r.find.attr;jb[b]=function(a,b,d){var e,f,g=b.toLowerCase();return d||(f=jb[g],jb[g]=e,e=null!=c(a,b,d)?g:null,jb[g]=f),e}});var kb=/^(?:input|select|textarea|button)$/i,lb=/^(?:a|area)$/i;r.fn.extend({prop:function(a,b){return S(this,r.prop,a,b,arguments.length>1)},removeProp:function(a){return this.each(function(){delete this[r.propFix[a]||a]})}}),r.extend({prop:function(a,b,c){var d,e,f=a.nodeType;if(3!==f&&8!==f&&2!==f)return 1===f&&r.isXMLDoc(a)||(b=r.propFix[b]||b,e=r.propHooks[b]),void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){var b=r.find.attr(a,"tabindex");return b?parseInt(b,10):kb.test(a.nodeName)||lb.test(a.nodeName)&&a.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),o.optSelected||(r.propHooks.selected={get:function(a){var b=a.parentNode;return b&&b.parentNode&&b.parentNode.selectedIndex,null},set:function(a){var b=a.parentNode;b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex)}}),r.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){r.propFix[this.toLowerCase()]=this});function mb(a){var b=a.match(K)||[];return b.join(" ")}function nb(a){return a.getAttribute&&a.getAttribute("class")||""}r.fn.extend({addClass:function(a){var b,c,d,e,f,g,h,i=0;if(r.isFunction(a))return this.each(function(b){r(this).addClass(a.call(this,b,nb(this)))});if("string"==typeof a&&a){b=a.match(K)||[];while(c=this[i++])if(e=nb(c),d=1===c.nodeType&&" "+mb(e)+" "){g=0;while(f=b[g++])d.indexOf(" "+f+" ")<0&&(d+=f+" ");h=mb(d),e!==h&&c.setAttribute("class",h)}}return this},removeClass:function(a){var b,c,d,e,f,g,h,i=0;if(r.isFunction(a))return this.each(function(b){r(this).removeClass(a.call(this,b,nb(this)))});if(!arguments.length)return this.attr("class","");if("string"==typeof a&&a){b=a.match(K)||[];while(c=this[i++])if(e=nb(c),d=1===c.nodeType&&" "+mb(e)+" "){g=0;while(f=b[g++])while(d.indexOf(" "+f+" ")>-1)d=d.replace(" "+f+" "," ");h=mb(d),e!==h&&c.setAttribute("class",h)}}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):r.isFunction(a)?this.each(function(c){r(this).toggleClass(a.call(this,c,nb(this),b),b)}):this.each(function(){var b,d,e,f;if("string"===c){d=0,e=r(this),f=a.match(K)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else void 0!==a&&"boolean"!==c||(b=nb(this),b&&V.set(this,"__className__",b),this.setAttribute&&this.setAttribute("class",b||a===!1?"":V.get(this,"__className__")||""))})},hasClass:function(a){var b,c,d=0;b=" "+a+" ";while(c=this[d++])if(1===c.nodeType&&(" "+mb(nb(c))+" ").indexOf(b)>-1)return!0;return!1}});var ob=/\\r/g;r.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=r.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,r(this).val()):a,null==e?e="":"number"==typeof e?e+="":r.isArray(e)&&(e=r.map(e,function(a){return null==a?"":a+""})),b=r.valHooks[this.type]||r.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=r.valHooks[e.type]||r.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(ob,""):null==c?"":c)}}}),r.extend({valHooks:{option:{get:function(a){var b=r.find.attr(a,"value");return null!=b?b:mb(r.text(a))}},select:{get:function(a){var b,c,d,e=a.options,f=a.selectedIndex,g="select-one"===a.type,h=g?null:[],i=g?f+1:e.length;for(d=f<0?i:g?f:0;d<i;d++)if(c=e[d],(c.selected||d===f)&&!c.disabled&&(!c.parentNode.disabled||!r.nodeName(c.parentNode,"optgroup"))){if(b=r(c).val(),g)return b;h.push(b)}return h},set:function(a,b){var c,d,e=a.options,f=r.makeArray(b),g=e.length;while(g--)d=e[g],(d.selected=r.inArray(r.valHooks.option.get(d),f)>-1)&&(c=!0);return c||(a.selectedIndex=-1),f}}}}),r.each(["radio","checkbox"],function(){r.valHooks[this]={set:function(a,b){if(r.isArray(b))return a.checked=r.inArray(r(a).val(),b)>-1}},o.checkOn||(r.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})});var pb=/^(?:focusinfocus|focusoutblur)$/;r.extend(r.event,{trigger:function(b,c,e,f){var g,h,i,j,k,m,n,o=[e||d],p=l.call(b,"type")?b.type:b,q=l.call(b,"namespace")?b.namespace.split("."):[];if(h=i=e=e||d,3!==e.nodeType&&8!==e.nodeType&&!pb.test(p+r.event.triggered)&&(p.indexOf(".")>-1&&(q=p.split("."),p=q.shift(),q.sort()),k=p.indexOf(":")<0&&"on"+p,b=b[r.expando]?b:new r.Event(p,"object"==typeof b&&b),b.isTrigger=f?2:3,b.namespace=q.join("."),b.rnamespace=b.namespace?new RegExp("(^|\\\\.)"+q.join("\\\\.(?:.*\\\\.|)")+"(\\\\.|$)"):null,b.result=void 0,b.target||(b.target=e),c=null==c?[b]:r.makeArray(c,[b]),n=r.event.special[p]||{},f||!n.trigger||n.trigger.apply(e,c)!==!1)){if(!f&&!n.noBubble&&!r.isWindow(e)){for(j=n.delegateType||p,pb.test(j+p)||(h=h.parentNode);h;h=h.parentNode)o.push(h),i=h;i===(e.ownerDocument||d)&&o.push(i.defaultView||i.parentWindow||a)}g=0;while((h=o[g++])&&!b.isPropagationStopped())b.type=g>1?j:n.bindType||p,m=(V.get(h,"events")||{})[b.type]&&V.get(h,"handle"),m&&m.apply(h,c),m=k&&h[k],m&&m.apply&&T(h)&&(b.result=m.apply(h,c),b.result===!1&&b.preventDefault());return b.type=p,f||b.isDefaultPrevented()||n._default&&n._default.apply(o.pop(),c)!==!1||!T(e)||k&&r.isFunction(e[p])&&!r.isWindow(e)&&(i=e[k],i&&(e[k]=null),r.event.triggered=p,e[p](),r.event.triggered=void 0,i&&(e[k]=i)),b.result}},simulate:function(a,b,c){var d=r.extend(new r.Event,c,{type:a,isSimulated:!0});r.event.trigger(d,null,b)}}),r.fn.extend({trigger:function(a,b){return this.each(function(){r.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];if(c)return r.event.trigger(a,b,c,!0)}}),r.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(a,b){r.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),r.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}}),o.focusin="onfocusin"in a,o.focusin||r.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){r.event.simulate(b,a.target,r.event.fix(a))};r.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=V.access(d,b);e||d.addEventListener(a,c,!0),V.access(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=V.access(d,b)-1;e?V.access(d,b,e):(d.removeEventListener(a,c,!0),V.remove(d,b))}}});var qb=a.location,rb=r.now(),sb=/\\?/;r.parseXML=function(b){var c;if(!b||"string"!=typeof b)return null;try{c=(new a.DOMParser).parseFromString(b,"text/xml")}catch(d){c=void 0}return c&&!c.getElementsByTagName("parsererror").length||r.error("Invalid XML: "+b),c};var tb=/\\[\\]$/,ub=/\\r?\\n/g,vb=/^(?:submit|button|image|reset|file)$/i,wb=/^(?:input|select|textarea|keygen)/i;function xb(a,b,c,d){var e;if(r.isArray(b))r.each(b,function(b,e){c||tb.test(a)?d(a,e):xb(a+"["+("object"==typeof e&&null!=e?b:"")+"]",e,c,d)});else if(c||"object"!==r.type(b))d(a,b);else for(e in b)xb(a+"["+e+"]",b[e],c,d)}r.param=function(a,b){var c,d=[],e=function(a,b){var c=r.isFunction(b)?b():b;d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(null==c?"":c)};if(r.isArray(a)||a.jquery&&!r.isPlainObject(a))r.each(a,function(){e(this.name,this.value)});else for(c in a)xb(c,a[c],b,e);return d.join("&")},r.fn.extend({serialize:function(){return r.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=r.prop(this,"elements");return a?r.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!r(this).is(":disabled")&&wb.test(this.nodeName)&&!vb.test(a)&&(this.checked||!ia.test(a))}).map(function(a,b){var c=r(this).val();return null==c?null:r.isArray(c)?r.map(c,function(a){return{name:b.name,value:a.replace(ub,"\\r\\n")}}):{name:b.name,value:c.replace(ub,"\\r\\n")}}).get()}});var yb=/%20/g,zb=/#.*$/,Ab=/([?&])_=[^&]*/,Bb=/^(.*?):[ \\t]*([^\\r\\n]*)$/gm,Cb=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Db=/^(?:GET|HEAD)$/,Eb=/^\\/\\//,Fb={},Gb={},Hb="*/".concat("*"),Ib=d.createElement("a");Ib.href=qb.href;function Jb(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(K)||[];if(r.isFunction(c))while(d=f[e++])"+"===d[0]?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function Kb(a,b,c,d){var e={},f=a===Gb;function g(h){var i;return e[h]=!0,r.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function Lb(a,b){var c,d,e=r.ajaxSettings.flatOptions||{};for(c in b)void 0!==b[c]&&((e[c]?a:d||(d={}))[c]=b[c]);return d&&r.extend(!0,a,d),a}function Mb(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===d&&(d=a.mimeType||b.getResponseHeader("Content-Type"));if(d)for(e in h)if(h[e]&&h[e].test(d)){i.unshift(e);break}if(i[0]in c)f=i[0];else{for(e in c){if(!i[0]||a.converters[e+" "+i[0]]){f=e;break}g||(g=e)}f=f||g}if(f)return f!==i[0]&&i.unshift(f),c[f]}function Nb(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}r.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:qb.href,type:"GET",isLocal:Cb.test(qb.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Hb,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\\bxml\\b/,html:/\\bhtml/,json:/\\bjson\\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":r.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?Lb(Lb(a,r.ajaxSettings),b):Lb(r.ajaxSettings,a)},ajaxPrefilter:Jb(Fb),ajaxTransport:Jb(Gb),ajax:function(b,c){"object"==typeof b&&(c=b,b=void 0),c=c||{};var e,f,g,h,i,j,k,l,m,n,o=r.ajaxSetup({},c),p=o.context||o,q=o.context&&(p.nodeType||p.jquery)?r(p):r.event,s=r.Deferred(),t=r.Callbacks("once memory"),u=o.statusCode||{},v={},w={},x="canceled",y={readyState:0,getResponseHeader:function(a){var b;if(k){if(!h){h={};while(b=Bb.exec(g))h[b[1].toLowerCase()]=b[2]}b=h[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return k?g:null},setRequestHeader:function(a,b){return null==k&&(a=w[a.toLowerCase()]=w[a.toLowerCase()]||a,v[a]=b),this},overrideMimeType:function(a){return null==k&&(o.mimeType=a),this},statusCode:function(a){var b;if(a)if(k)y.always(a[y.status]);else for(b in a)u[b]=[u[b],a[b]];return this},abort:function(a){var b=a||x;return e&&e.abort(b),A(0,b),this}};if(s.promise(y),o.url=((b||o.url||qb.href)+"").replace(Eb,qb.protocol+"//"),o.type=c.method||c.type||o.method||o.type,o.dataTypes=(o.dataType||"*").toLowerCase().match(K)||[""],null==o.crossDomain){j=d.createElement("a");try{j.href=o.url,j.href=j.href,o.crossDomain=Ib.protocol+"//"+Ib.host!=j.protocol+"//"+j.host}catch(z){o.crossDomain=!0}}if(o.data&&o.processData&&"string"!=typeof o.data&&(o.data=r.param(o.data,o.traditional)),Kb(Fb,o,c,y),k)return y;l=r.event&&o.global,l&&0===r.active++&&r.event.trigger("ajaxStart"),o.type=o.type.toUpperCase(),o.hasContent=!Db.test(o.type),f=o.url.replace(zb,""),o.hasContent?o.data&&o.processData&&0===(o.contentType||"").indexOf("application/x-www-form-urlencoded")&&(o.data=o.data.replace(yb,"+")):(n=o.url.slice(f.length),o.data&&(f+=(sb.test(f)?"&":"?")+o.data,delete o.data),o.cache===!1&&(f=f.replace(Ab,"$1"),n=(sb.test(f)?"&":"?")+"_="+rb++ +n),o.url=f+n),o.ifModified&&(r.lastModified[f]&&y.setRequestHeader("If-Modified-Since",r.lastModified[f]),r.etag[f]&&y.setRequestHeader("If-None-Match",r.etag[f])),(o.data&&o.hasContent&&o.contentType!==!1||c.contentType)&&y.setRequestHeader("Content-Type",o.contentType),y.setRequestHeader("Accept",o.dataTypes[0]&&o.accepts[o.dataTypes[0]]?o.accepts[o.dataTypes[0]]+("*"!==o.dataTypes[0]?", "+Hb+"; q=0.01":""):o.accepts["*"]);for(m in o.headers)y.setRequestHeader(m,o.headers[m]);if(o.beforeSend&&(o.beforeSend.call(p,y,o)===!1||k))return y.abort();if(x="abort",t.add(o.complete),y.done(o.success),y.fail(o.error),e=Kb(Gb,o,c,y)){if(y.readyState=1,l&&q.trigger("ajaxSend",[y,o]),k)return y;o.async&&o.timeout>0&&(i=a.setTimeout(function(){y.abort("timeout")},o.timeout));try{k=!1,e.send(v,A)}catch(z){if(k)throw z;A(-1,z)}}else A(-1,"No Transport");function A(b,c,d,h){var j,m,n,v,w,x=c;k||(k=!0,i&&a.clearTimeout(i),e=void 0,g=h||"",y.readyState=b>0?4:0,j=b>=200&&b<300||304===b,d&&(v=Mb(o,y,d)),v=Nb(o,v,y,j),j?(o.ifModified&&(w=y.getResponseHeader("Last-Modified"),w&&(r.lastModified[f]=w),w=y.getResponseHeader("etag"),w&&(r.etag[f]=w)),204===b||"HEAD"===o.type?x="nocontent":304===b?x="notmodified":(x=v.state,m=v.data,n=v.error,j=!n)):(n=x,!b&&x||(x="error",b<0&&(b=0))),y.status=b,y.statusText=(c||x)+"",j?s.resolveWith(p,[m,x,y]):s.rejectWith(p,[y,x,n]),y.statusCode(u),u=void 0,l&&q.trigger(j?"ajaxSuccess":"ajaxError",[y,o,j?m:n]),t.fireWith(p,[y,x]),l&&(q.trigger("ajaxComplete",[y,o]),--r.active||r.event.trigger("ajaxStop")))}return y},getJSON:function(a,b,c){return r.get(a,b,c,"json")},getScript:function(a,b){return r.get(a,void 0,b,"script")}}),r.each(["get","post"],function(a,b){r[b]=function(a,c,d,e){return r.isFunction(c)&&(e=e||d,d=c,c=void 0),r.ajax(r.extend({url:a,type:b,dataType:e,data:c,success:d},r.isPlainObject(a)&&a))}}),r._evalUrl=function(a){return r.ajax({url:a,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,"throws":!0})},r.fn.extend({wrapAll:function(a){var b;return this[0]&&(r.isFunction(a)&&(a=a.call(this[0])),b=r(a,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstElementChild)a=a.firstElementChild;return a}).append(this)),this},wrapInner:function(a){return r.isFunction(a)?this.each(function(b){r(this).wrapInner(a.call(this,b))}):this.each(function(){var b=r(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=r.isFunction(a);return this.each(function(c){r(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(a){return this.parent(a).not("body").each(function(){r(this).replaceWith(this.childNodes)}),this}}),r.expr.pseudos.hidden=function(a){return!r.expr.pseudos.visible(a)},r.expr.pseudos.visible=function(a){return!!(a.offsetWidth||a.offsetHeight||a.getClientRects().length)},r.ajaxSettings.xhr=function(){try{return new a.XMLHttpRequest}catch(b){}};var Ob={0:200,1223:204},Pb=r.ajaxSettings.xhr();o.cors=!!Pb&&"withCredentials"in Pb,o.ajax=Pb=!!Pb,r.ajaxTransport(function(b){var c,d;if(o.cors||Pb&&!b.crossDomain)return{send:function(e,f){var g,h=b.xhr();if(h.open(b.type,b.url,b.async,b.username,b.password),b.xhrFields)for(g in b.xhrFields)h[g]=b.xhrFields[g];b.mimeType&&h.overrideMimeType&&h.overrideMimeType(b.mimeType),b.crossDomain||e["X-Requested-With"]||(e["X-Requested-With"]="XMLHttpRequest");for(g in e)h.setRequestHeader(g,e[g]);c=function(a){return function(){c&&(c=d=h.onload=h.onerror=h.onabort=h.onreadystatechange=null,"abort"===a?h.abort():"error"===a?"number"!=typeof h.status?f(0,"error"):f(h.status,h.statusText):f(Ob[h.status]||h.status,h.statusText,"text"!==(h.responseType||"text")||"string"!=typeof h.responseText?{binary:h.response}:{text:h.responseText},h.getAllResponseHeaders()))}},h.onload=c(),d=h.onerror=c("error"),void 0!==h.onabort?h.onabort=d:h.onreadystatechange=function(){4===h.readyState&&a.setTimeout(function(){c&&d()})},c=c("abort");try{h.send(b.hasContent&&b.data||null)}catch(i){if(c)throw i}},abort:function(){c&&c()}}}),r.ajaxPrefilter(function(a){a.crossDomain&&(a.contents.script=!1)}),r.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\\b(?:java|ecma)script\\b/},converters:{"text script":function(a){return r.globalEval(a),a}}}),r.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET")}),r.ajaxTransport("script",function(a){if(a.crossDomain){var b,c;return{send:function(e,f){b=r("<script>").prop({charset:a.scriptCharset,src:a.url}).on("load error",c=function(a){b.remove(),c=null,a&&f("error"===a.type?404:200,a.type)}),d.head.appendChild(b[0])},abort:function(){c&&c()}}}});var Qb=[],Rb=/(=)\\?(?=&|$)|\\?\\?/;r.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=Qb.pop()||r.expando+"_"+rb++;return this[a]=!0,a}}),r.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(Rb.test(b.url)?"url":"string"==typeof b.data&&0===(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&Rb.test(b.data)&&"data");if(h||"jsonp"===b.dataTypes[0])return e=b.jsonpCallback=r.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(Rb,"$1"+e):b.jsonp!==!1&&(b.url+=(sb.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||r.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){void 0===f?r(a).removeProp(e):a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,Qb.push(e)),g&&r.isFunction(f)&&f(g[0]),g=f=void 0}),"script"}),o.createHTMLDocument=function(){var a=d.implementation.createHTMLDocument("").body;return a.innerHTML="<form></form><form></form>",2===a.childNodes.length}(),r.parseHTML=function(a,b,c){if("string"!=typeof a)return[];"boolean"==typeof b&&(c=b,b=!1);var e,f,g;return b||(o.createHTMLDocument?(b=d.implementation.createHTMLDocument(""),e=b.createElement("base"),e.href=d.location.href,b.head.appendChild(e)):b=d),f=B.exec(a),g=!c&&[],f?[b.createElement(f[1])]:(f=pa([a],b,g),g&&g.length&&r(g).remove(),r.merge([],f.childNodes))},r.fn.load=function(a,b,c){var d,e,f,g=this,h=a.indexOf(" ");return h>-1&&(d=mb(a.slice(h)),a=a.slice(0,h)),r.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(e="POST"),g.length>0&&r.ajax({url:a,type:e||"GET",dataType:"html",data:b}).done(function(a){f=arguments,g.html(d?r("<div>").append(r.parseHTML(a)).find(d):a)}).always(c&&function(a,b){g.each(function(){c.apply(this,f||[a.responseText,b,a])})}),this},r.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){r.fn[b]=function(a){return this.on(b,a)}}),r.expr.pseudos.animated=function(a){return r.grep(r.timers,function(b){return a===b.elem}).length};function Sb(a){return r.isWindow(a)?a:9===a.nodeType&&a.defaultView}r.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=r.css(a,"position"),l=r(a),m={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=r.css(a,"top"),i=r.css(a,"left"),j=("absolute"===k||"fixed"===k)&&(f+i).indexOf("auto")>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),r.isFunction(b)&&(b=b.call(a,c,r.extend({},h))),null!=b.top&&(m.top=b.top-h.top+g),null!=b.left&&(m.left=b.left-h.left+e),"using"in b?b.using.call(a,m):l.css(m)}},r.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){r.offset.setOffset(this,a,b)});var b,c,d,e,f=this[0];if(f)return f.getClientRects().length?(d=f.getBoundingClientRect(),d.width||d.height?(e=f.ownerDocument,c=Sb(e),b=e.documentElement,{top:d.top+c.pageYOffset-b.clientTop,left:d.left+c.pageXOffset-b.clientLeft}):d):{top:0,left:0}},position:function(){if(this[0]){var a,b,c=this[0],d={top:0,left:0};return"fixed"===r.css(c,"position")?b=c.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),r.nodeName(a[0],"html")||(d=a.offset()),d={top:d.top+r.css(a[0],"borderTopWidth",!0),left:d.left+r.css(a[0],"borderLeftWidth",!0)}),{top:b.top-d.top-r.css(c,"marginTop",!0),left:b.left-d.left-r.css(c,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent;while(a&&"static"===r.css(a,"position"))a=a.offsetParent;return a||qa})}}),r.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(a,b){var c="pageYOffset"===b;r.fn[a]=function(d){return S(this,function(a,d,e){var f=Sb(a);return void 0===e?f?f[b]:a[d]:void(f?f.scrollTo(c?f.pageXOffset:e,c?e:f.pageYOffset):a[d]=e)},a,d,arguments.length)}}),r.each(["top","left"],function(a,b){r.cssHooks[b]=Oa(o.pixelPosition,function(a,c){if(c)return c=Na(a,b),La.test(c)?r(a).position()[b]+"px":c})}),r.each({Height:"height",Width:"width"},function(a,b){r.each({padding:"inner"+a,content:b,"":"outer"+a},function(c,d){r.fn[d]=function(e,f){var g=arguments.length&&(c||"boolean"!=typeof e),h=c||(e===!0||f===!0?"margin":"border");return S(this,function(b,c,e){var f;return r.isWindow(b)?0===d.indexOf("outer")?b["inner"+a]:b.document.documentElement["client"+a]:9===b.nodeType?(f=b.documentElement,Math.max(b.body["scroll"+a],f["scroll"+a],b.body["offset"+a],f["offset"+a],f["client"+a])):void 0===e?r.css(b,c,h):r.style(b,c,e,h)},b,g?e:void 0,g)}})}),r.fn.extend({bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)}}),r.parseJSON=JSON.parse,"function"==typeof define&&define.amd&&define("jquery",[],function(){return r});var Tb=a.jQuery,Ub=a.$;return r.noConflict=function(b){return a.$===r&&(a.$=Ub),b&&a.jQuery===r&&(a.jQuery=Tb),r},b||(a.jQuery=a.$=r),r});\n'},1481:function(e,n){e.exports="(function (r) {\n  'use strict';\n\n\n    var Buffer = (function () {\n      var ieee754 = (function () {\n        return {\n          read: function (buffer, offset, isLE, mLen, nBytes) {\n            var e, m\n            var eLen = nBytes * 8 - mLen - 1\n            var eMax = (1 << eLen) - 1\n            var eBias = eMax >> 1\n            var nBits = -7\n            var i = isLE ? (nBytes - 1) : 0\n            var d = isLE ? -1 : 1\n            var s = buffer[offset + i]\n\n            i += d\n\n            e = s & ((1 << (-nBits)) - 1)\n            s >>= (-nBits)\n            nBits += eLen\n            for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {\n            }\n\n            m = e & ((1 << (-nBits)) - 1)\n            e >>= (-nBits)\n            nBits += mLen\n            for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {\n            }\n\n            if (e === 0) {\n              e = 1 - eBias\n            } else if (e === eMax) {\n              return m ? NaN : ((s ? -1 : 1) * Infinity)\n            } else {\n              m = m + Math.pow(2, mLen)\n              e = e - eBias\n            }\n            return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n          },\n          write: function (buffer, value, offset, isLE, mLen, nBytes) {\n            var e, m, c\n            var eLen = nBytes * 8 - mLen - 1\n            var eMax = (1 << eLen) - 1\n            var eBias = eMax >> 1\n            var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n            var i = isLE ? 0 : (nBytes - 1)\n            var d = isLE ? 1 : -1\n            var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n            value = Math.abs(value)\n\n            if (isNaN(value) || value === Infinity) {\n              m = isNaN(value) ? 1 : 0\n              e = eMax\n            } else {\n              e = Math.floor(Math.log(value) / Math.LN2)\n              if (value * (c = Math.pow(2, -e)) < 1) {\n                e--\n                c *= 2\n              }\n              if (e + eBias >= 1) {\n                value += rt / c\n              } else {\n                value += rt * Math.pow(2, 1 - eBias)\n              }\n              if (value * c >= 2) {\n                e++\n                c /= 2\n              }\n\n              if (e + eBias >= eMax) {\n                m = 0\n                e = eMax\n              } else if (e + eBias >= 1) {\n                m = (value * c - 1) * Math.pow(2, mLen)\n                e = e + eBias\n              } else {\n                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n                e = 0\n              }\n            }\n\n            for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {\n            }\n\n            e = (e << mLen) | m\n            eLen += mLen\n            for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {\n            }\n\n            buffer[offset + i - d] |= s * 128\n          }\n        }\n      })();\n\n      var BufferMethods;\n\n      function Buffer(length) {\n        var arr;\n        if (length && length.length) {\n          arr = length;\n          length = arr.length;\n        }\n        var buf = new Uint8Array(length || 0);\n        if (arr) buf.set(arr);\n\n        buf.readUInt32LE = BufferMethods.readUInt32LE;\n        buf.writeUInt32LE = BufferMethods.writeUInt32LE;\n        buf.readInt32LE = BufferMethods.readInt32LE;\n        buf.writeInt32LE = BufferMethods.writeInt32LE;\n        buf.readFloatLE = BufferMethods.readFloatLE;\n        buf.writeFloatLE = BufferMethods.writeFloatLE;\n        buf.readDoubleLE = BufferMethods.readDoubleLE;\n        buf.writeDoubleLE = BufferMethods.writeDoubleLE;\n        buf.toString = BufferMethods.toString;\n        buf.write = BufferMethods.write;\n        buf.slice = BufferMethods.slice;\n        buf.copy = BufferMethods.copy;\n\n        buf._isBuffer = true;\n        return buf;\n      }\n\n      var lastStr, lastStrEncoded;\n\n      BufferMethods = {\n        readUInt32LE: function(pos) {\n          return ((this[pos]) |\n            (this[pos + 1] << 8) |\n            (this[pos + 2] << 16)) +\n            (this[pos + 3] * 0x1000000);\n        },\n\n        writeUInt32LE: function(val, pos) {\n          this[pos] = val;\n          this[pos + 1] = (val >>> 8);\n          this[pos + 2] = (val >>> 16);\n          this[pos + 3] = (val >>> 24);\n        },\n\n        readInt32LE: function(pos) {\n          return ((this[pos]) |\n            (this[pos + 1] << 8) |\n            (this[pos + 2] << 16)) +\n            (this[pos + 3] << 24);\n        },\n\n        readFloatLE:  function(pos) { return ieee754.read(this, pos, true, 23, 4); },\n        readDoubleLE: function(pos) { return ieee754.read(this, pos, true, 52, 8); },\n\n        writeFloatLE:  function(val, pos) { return ieee754.write(this, val, pos, true, 23, 4); },\n        writeDoubleLE: function(val, pos) { return ieee754.write(this, val, pos, true, 52, 8); },\n\n        toString: function(encoding, start, end) {\n          var str = [],\n            tmp = '';\n\n          start = start || 0;\n          end = Math.min(this.length, end || this.length);\n\n          for (var i = start; i < end; i++) {\n            var ch = this[i];\n            if (ch <= 0x7F) {\n              str.push(String.fromCharCode(ch));\n              //str += decodeURIComponent(tmp) + String.fromCharCode(ch);\n              //tmp = '';\n            } else {\n              //tmp += '%' + ch.toString(16);\n            }\n          }\n\n          //str += decodeURIComponent(tmp);\n\n          return str.join('');\n        },\n\n        write: function(str, pos) {\n          var bytes = str === lastStr ? lastStrEncoded : encodeString(str);\n          for (var i = 0; i < bytes.length; i++) {\n            this[pos + i] = bytes[i];\n          }\n        },\n\n        slice: function(start, end) {\n          return this.subarray(start, end);\n        },\n\n        copy: function(buf, pos) {\n          pos = pos || 0;\n          for (var i = 0; i < this.length; i++) {\n            buf[pos + i] = this[i];\n          }\n        }\n      };\n\n      BufferMethods.writeInt32LE = BufferMethods.writeUInt32LE;\n\n      Buffer.byteLength = function(str) {\n        lastStr = str;\n        lastStrEncoded = encodeString(str);\n        return lastStrEncoded.length;\n      };\n\n      Buffer.isBuffer = function(buf) {\n        return !!(buf && buf._isBuffer);\n      };\n\n      function encodeString(str) {\n        var length = str.length,\n          bytes = [];\n\n        for (var i = 0, c, lead; i < length; i++) {\n          c = str.charCodeAt(i); // code point\n\n          if (c > 0xD7FF && c < 0xE000) {\n\n            if (lead) {\n              if (c < 0xDC00) {\n                bytes.push(0xEF, 0xBF, 0xBD);\n                lead = c;\n                continue;\n\n              } else {\n                c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;\n                lead = null;\n              }\n\n            } else {\n              if (c > 0xDBFF || (i + 1 === length)) bytes.push(0xEF, 0xBF, 0xBD);\n              else lead = c;\n\n              continue;\n            }\n\n          } else if (lead) {\n            bytes.push(0xEF, 0xBF, 0xBD);\n            lead = null;\n          }\n\n          if (c < 0x80) bytes.push(c);\n          else if (c < 0x800) bytes.push(c >> 0x6 | 0xC0, c & 0x3F | 0x80);\n          else if (c < 0x10000) bytes.push(c >> 0xC | 0xE0, c >> 0x6 & 0x3F | 0x80, c & 0x3F | 0x80);\n          else bytes.push(c >> 0x12 | 0xF0, c >> 0xC & 0x3F | 0x80, c >> 0x6 & 0x3F | 0x80, c & 0x3F | 0x80);\n        }\n        return bytes;\n      }\n      return Buffer;\n    })();\n\n    function Pbf(buf) {\n      this.buf = !Buffer.isBuffer(buf) ? new Buffer(buf || 0) : buf;\n      this.pos = 0;\n      this.length = this.buf.length;\n    }\n\n    Pbf.Varint  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum\n    Pbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64\n    Pbf.Bytes   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields\n    Pbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32\n\n    var SHIFT_LEFT_32 = (1 << 16) * (1 << 16),\n      SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32,\n      POW_2_63 = Math.pow(2, 63);\n\n    Pbf.prototype = {\n\n      destroy: function() {\n        this.buf = null;\n      },\n\n      // === READING =================================================================\n\n      readFields: function(readField, result, end) {\n        end = end || this.length;\n\n        while (this.pos < end) {\n          var val = this.readVarint(),\n            tag = val >> 3,\n            startPos = this.pos;\n\n          readField(tag, result, this);\n\n          if (this.pos === startPos) this.skip(val);\n        }\n        return result;\n      },\n\n      readMessage: function(readField, result) {\n        return this.readFields(readField, result, this.readVarint() + this.pos);\n      },\n\n      readFixed32: function() {\n        var val = this.buf.readUInt32LE(this.pos);\n        this.pos += 4;\n        return val;\n      },\n\n      readSFixed32: function() {\n        var val = this.buf.readInt32LE(this.pos);\n        this.pos += 4;\n        return val;\n      },\n\n      // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)\n\n      readFixed64: function() {\n        var val = this.buf.readUInt32LE(this.pos) + this.buf.readUInt32LE(this.pos + 4) * SHIFT_LEFT_32;\n        this.pos += 8;\n        return val;\n      },\n\n      readSFixed64: function() {\n        var val = this.buf.readUInt32LE(this.pos) + this.buf.readInt32LE(this.pos + 4) * SHIFT_LEFT_32;\n        this.pos += 8;\n        return val;\n      },\n\n      readFloat: function() {\n        var val = this.buf.readFloatLE(this.pos);\n        this.pos += 4;\n        return val;\n      },\n\n      readDouble: function() {\n        var val = this.buf.readDoubleLE(this.pos);\n        this.pos += 8;\n        return val;\n      },\n\n      readVarint: function() {\n        var buf = this.buf,\n          val, b;\n\n        b = buf[this.pos++]; val  =  b & 0x7f;        if (b < 0x80) return val;\n        b = buf[this.pos++]; val |= (b & 0x7f) << 7;  if (b < 0x80) return val;\n        b = buf[this.pos++]; val |= (b & 0x7f) << 14; if (b < 0x80) return val;\n        b = buf[this.pos++]; val |= (b & 0x7f) << 21; if (b < 0x80) return val;\n\n        return readVarintRemainder(val, this);\n      },\n\n      readVarint64: function() {\n        var startPos = this.pos,\n          val = this.readVarint();\n\n        if (val < POW_2_63) return val;\n\n        var pos = this.pos - 2;\n        while (this.buf[pos] === 0xff) pos--;\n        if (pos < startPos) pos = startPos;\n\n        val = 0;\n        for (var i = 0; i < pos - startPos + 1; i++) {\n          var b = ~this.buf[startPos + i] & 0x7f;\n          val += i < 4 ? b << i * 7 : b * Math.pow(2, i * 7);\n        }\n\n        return -val - 1;\n      },\n\n      readSVarint: function() {\n        var num = this.readVarint();\n        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding\n      },\n\n      readBoolean: function() {\n        return Boolean(this.readVarint());\n      },\n\n      readString: function() {\n        var end = this.readVarint() + this.pos,\n          str = this.buf.toString('utf8', this.pos, end);\n        this.pos = end;\n        return str;\n      },\n\n      readBytes: function() {\n        var end = this.readVarint() + this.pos,\n          buffer = this.buf.slice(this.pos, end);\n        this.pos = end;\n        return buffer;\n      },\n\n      // verbose for performance reasons; doesn't affect gzipped size\n\n      readPackedVarint: function() {\n        var end = this.readVarint() + this.pos, arr = [];\n        while (this.pos < end) arr.push(this.readVarint());\n        return arr;\n      },\n      readPackedSVarint: function() {\n        var end = this.readVarint() + this.pos, arr = [];\n        while (this.pos < end) arr.push(this.readSVarint());\n        return arr;\n      },\n      readPackedBoolean: function() {\n        var end = this.readVarint() + this.pos, arr = [];\n        while (this.pos < end) arr.push(this.readBoolean());\n        return arr;\n      },\n      readPackedFloat: function() {\n        var end = this.readVarint() + this.pos, arr = [];\n        while (this.pos < end) arr.push(this.readFloat());\n        return arr;\n      },\n      readPackedDouble: function() {\n        var end = this.readVarint() + this.pos, arr = [];\n        while (this.pos < end) arr.push(this.readDouble());\n        return arr;\n      },\n      readPackedFixed32: function() {\n        var end = this.readVarint() + this.pos, arr = [];\n        while (this.pos < end) arr.push(this.readFixed32());\n        return arr;\n      },\n      readPackedSFixed32: function() {\n        var end = this.readVarint() + this.pos, arr = [];\n        while (this.pos < end) arr.push(this.readSFixed32());\n        return arr;\n      },\n      readPackedFixed64: function() {\n        var end = this.readVarint() + this.pos, arr = [];\n        while (this.pos < end) arr.push(this.readFixed64());\n        return arr;\n      },\n      readPackedSFixed64: function() {\n        var end = this.readVarint() + this.pos, arr = [];\n        while (this.pos < end) arr.push(this.readSFixed64());\n        return arr;\n      },\n\n      skip: function(val) {\n        var type = val & 0x7;\n        if (type === Pbf.Varint) while (this.buf[this.pos++] > 0x7f) {}\n        else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;\n        else if (type === Pbf.Fixed32) this.pos += 4;\n        else if (type === Pbf.Fixed64) this.pos += 8;\n        else throw new Error('Unimplemented type: ' + type);\n      },\n\n      // === WRITING =================================================================\n\n      writeTag: function(tag, type) {\n        this.writeVarint((tag << 3) | type);\n      },\n\n      realloc: function(min) {\n        var length = this.length || 16;\n\n        while (length < this.pos + min) length *= 2;\n\n        if (length !== this.length) {\n          var buf = new Buffer(length);\n          this.buf.copy(buf);\n          this.buf = buf;\n          this.length = length;\n        }\n      },\n\n      finish: function() {\n        this.length = this.pos;\n        this.pos = 0;\n        return this.buf.slice(0, this.length);\n      },\n\n      writeFixed32: function(val) {\n        this.realloc(4);\n        this.buf.writeUInt32LE(val, this.pos);\n        this.pos += 4;\n      },\n\n      writeSFixed32: function(val) {\n        this.realloc(4);\n        this.buf.writeInt32LE(val, this.pos);\n        this.pos += 4;\n      },\n\n      writeFixed64: function(val) {\n        this.realloc(8);\n        this.buf.writeInt32LE(val & -1, this.pos);\n        this.buf.writeUInt32LE(Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);\n        this.pos += 8;\n      },\n\n      writeSFixed64: function(val) {\n        this.realloc(8);\n        this.buf.writeInt32LE(val & -1, this.pos);\n        this.buf.writeInt32LE(Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);\n        this.pos += 8;\n      },\n\n      writeVarint: function(val) {\n        val = +val;\n\n        if (val > 0xfffffff) {\n          writeBigVarint(val, this);\n          return;\n        }\n\n        this.realloc(4);\n\n        this.buf[this.pos++] =           val & 0x7f  | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n        this.buf[this.pos++] =   (val >>> 7) & 0x7f;\n      },\n\n      writeSVarint: function(val) {\n        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);\n      },\n\n      writeBoolean: function(val) {\n        this.writeVarint(Boolean(val));\n      },\n\n      writeString: function(str) {\n        str = String(str);\n        var bytes = Buffer.byteLength(str);\n        this.writeVarint(bytes);\n        this.realloc(bytes);\n        this.buf.write(str, this.pos);\n        this.pos += bytes;\n      },\n\n      writeFloat: function(val) {\n        this.realloc(4);\n        this.buf.writeFloatLE(val, this.pos);\n        this.pos += 4;\n      },\n\n      writeDouble: function(val) {\n        this.realloc(8);\n        this.buf.writeDoubleLE(val, this.pos);\n        this.pos += 8;\n      },\n\n      writeBytes: function(buffer) {\n        var len = buffer.length;\n        this.writeVarint(len);\n        this.realloc(len);\n        for (var i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];\n      },\n\n      writeRawMessage: function(fn, obj) {\n        this.pos++; // reserve 1 byte for short message length\n\n        // write the message directly to the buffer and see how much was written\n        var startPos = this.pos;\n        fn(obj, this);\n        var len = this.pos - startPos;\n\n        if (len >= 0x80) reallocForRawMessage(startPos, len, this);\n\n        // finally, write the message length in the reserved place and restore the position\n        this.pos = startPos - 1;\n        this.writeVarint(len);\n        this.pos += len;\n      },\n\n      writeMessage: function(tag, fn, obj) {\n        this.writeTag(tag, Pbf.Bytes);\n        this.writeRawMessage(fn, obj);\n      },\n\n      writePackedVarint:   function(tag, arr) { this.writeMessage(tag, writePackedVarint, arr);   },\n      writePackedSVarint:  function(tag, arr) { this.writeMessage(tag, writePackedSVarint, arr);  },\n      writePackedBoolean:  function(tag, arr) { this.writeMessage(tag, writePackedBoolean, arr);  },\n      writePackedFloat:    function(tag, arr) { this.writeMessage(tag, writePackedFloat, arr);    },\n      writePackedDouble:   function(tag, arr) { this.writeMessage(tag, writePackedDouble, arr);   },\n      writePackedFixed32:  function(tag, arr) { this.writeMessage(tag, writePackedFixed32, arr);  },\n      writePackedSFixed32: function(tag, arr) { this.writeMessage(tag, writePackedSFixed32, arr); },\n      writePackedFixed64:  function(tag, arr) { this.writeMessage(tag, writePackedFixed64, arr);  },\n      writePackedSFixed64: function(tag, arr) { this.writeMessage(tag, writePackedSFixed64, arr); },\n\n      writeBytesField: function(tag, buffer) {\n        this.writeTag(tag, Pbf.Bytes);\n        this.writeBytes(buffer);\n      },\n      writeFixed32Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed32);\n        this.writeFixed32(val);\n      },\n      writeSFixed32Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed32);\n        this.writeSFixed32(val);\n      },\n      writeFixed64Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed64);\n        this.writeFixed64(val);\n      },\n      writeSFixed64Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed64);\n        this.writeSFixed64(val);\n      },\n      writeVarintField: function(tag, val) {\n        this.writeTag(tag, Pbf.Varint);\n        this.writeVarint(val);\n      },\n      writeSVarintField: function(tag, val) {\n        this.writeTag(tag, Pbf.Varint);\n        this.writeSVarint(val);\n      },\n      writeStringField: function(tag, str) {\n        this.writeTag(tag, Pbf.Bytes);\n        this.writeString(str);\n      },\n      writeFloatField: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed32);\n        this.writeFloat(val);\n      },\n      writeDoubleField: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed64);\n        this.writeDouble(val);\n      },\n      writeBooleanField: function(tag, val) {\n        this.writeVarintField(tag, Boolean(val));\n      }\n    };\n\n    function readVarintRemainder(val, pbf) {\n      var buf = pbf.buf, b;\n\n      b = buf[pbf.pos++]; val += (b & 0x7f) * 0x10000000;         if (b < 0x80) return val;\n      b = buf[pbf.pos++]; val += (b & 0x7f) * 0x800000000;        if (b < 0x80) return val;\n      b = buf[pbf.pos++]; val += (b & 0x7f) * 0x40000000000;      if (b < 0x80) return val;\n      b = buf[pbf.pos++]; val += (b & 0x7f) * 0x2000000000000;    if (b < 0x80) return val;\n      b = buf[pbf.pos++]; val += (b & 0x7f) * 0x100000000000000;  if (b < 0x80) return val;\n      b = buf[pbf.pos++]; val += (b & 0x7f) * 0x8000000000000000; if (b < 0x80) return val;\n\n      throw new Error('Expected varint not more than 10 bytes');\n    }\n\n    function writeBigVarint(val, pbf) {\n      pbf.realloc(10);\n\n      var maxPos = pbf.pos + 10;\n\n      while (val >= 1) {\n        if (pbf.pos >= maxPos) throw new Error('Given varint doesn\\'t fit into 10 bytes');\n        var b = val & 0xff;\n        pbf.buf[pbf.pos++] = b | (val >= 0x80 ? 0x80 : 0);\n        val /= 0x80;\n      }\n    }\n\n    function reallocForRawMessage(startPos, len, pbf) {\n      var extraLen =\n        len <= 0x3fff ? 1 :\n          len <= 0x1fffff ? 2 :\n            len <= 0xfffffff ? 3 : Math.ceil(Math.log(len) / (Math.LN2 * 7));\n\n      // if 1 byte isn't enough for encoding message length, shift the data to the right\n      pbf.realloc(extraLen);\n      for (var i = pbf.pos - 1; i >= startPos; i--) pbf.buf[i + extraLen] = pbf.buf[i];\n    }\n\n    function writePackedVarint(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);   }\n    function writePackedSVarint(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);  }\n    function writePackedFloat(arr, pbf)    { for (var i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);    }\n    function writePackedDouble(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);   }\n    function writePackedBoolean(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);  }\n    function writePackedFixed32(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);  }\n    function writePackedSFixed32(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]); }\n    function writePackedFixed64(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);  }\n    function writePackedSFixed64(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]); }\n\n    r.Pbf = {\n      buffer:function (arr) {\n        return new Buffer(arr);\n      },\n      pbf:function (buf) {\n        return new Pbf(buf);\n      }\n    };\n})(window.R = (window.R||{}));\n"},1482:function(e,n){e.exports="/*!\n * Viewer.js v0.4.0\n * https://github.com/fengyuanchen/viewerjs\n *\n * Copyright (c) 2015-2016 Fengyuan Chen\n * Released under the MIT license\n *\n * Date: 2016-03-20T07:17:50.179Z\n */\n\n(function(global, factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        module.exports = global.document ? factory(global, true) : function(window) {\n            if (!window.document) {\n                throw new Error('Viewer requires a window with a document');\n            }\n\n            return factory(window);\n        };\n    } else {\n        factory(global);\n    }\n})(typeof window !== 'undefined' ? window : this, function(window, noGlobal) {\n\n    'use strict';\n\n    var document = window.document;\n    var Event = window.Event;\n\n    // Constants\n    var NAMESPACE = 'viewer';\n\n    // Classes\n    var CLASS_FIXED = NAMESPACE + '-fixed';\n    var CLASS_OPEN = NAMESPACE + '-open';\n    var CLASS_SHOW = NAMESPACE + '-show';\n    var CLASS_HIDE = NAMESPACE + '-hide';\n    var CLASS_HIDE_XS_DOWN = 'viewer-hide-xs-down';\n    var CLASS_HIDE_SM_DOWN = 'viewer-hide-sm-down';\n    var CLASS_HIDE_MD_DOWN = 'viewer-hide-md-down';\n    var CLASS_FADE = NAMESPACE + '-fade';\n    var CLASS_IN = NAMESPACE + '-in';\n    var CLASS_MOVE = NAMESPACE + '-move';\n    var CLASS_ACTIVE = NAMESPACE + '-active';\n    var CLASS_INVISIBLE = NAMESPACE + '-invisible';\n    var CLASS_TRANSITION = NAMESPACE + '-transition';\n    var CLASS_FULLSCREEN = NAMESPACE + '-fullscreen';\n    var CLASS_FULLSCREEN_EXIT = NAMESPACE + '-fullscreen-exit';\n    var CLASS_CLOSE = NAMESPACE + '-close';\n\n    // Events\n    var EVENT_MOUSEDOWN = 'mousedown touchstart pointerdown MSPointerDown';\n    var EVENT_MOUSEMOVE = 'mousemove touchmove pointermove MSPointerMove';\n    var EVENT_MOUSEUP = 'mouseup touchend touchcancel pointerup pointercancel MSPointerUp MSPointerCancel';\n    var EVENT_WHEEL = 'wheel mousewheel DOMMouseScroll';\n    var EVENT_TRANSITIONEND = 'transitionend';\n    var EVENT_LOAD = 'load';\n    var EVENT_KEYDOWN = 'keydown';\n    var EVENT_CLICK = 'click';\n    var EVENT_RESIZE = 'resize';\n    var EVENT_BUILD = 'build';\n    var EVENT_BUILT = 'built';\n    var EVENT_SHOW = 'show';\n    var EVENT_SHOWN = 'shown';\n    var EVENT_HIDE = 'hide';\n    var EVENT_HIDDEN = 'hidden';\n    var EVENT_VIEW = 'view';\n    var EVENT_VIEWED = 'viewed';\n\n    // RegExps\n    var REGEXP_SUFFIX = /width|height|left|top|marginLeft|marginTop/;\n    var REGEXP_TRIM = /^\\s+(.*)\\s+$/;\n    var REGEXP_SPACES = /\\s+/;\n\n    // Supports\n    var SUPPORT_TRANSITION = typeof document.createElement(NAMESPACE).style.transition !== 'undefined';\n\n    // Maths\n    var min = Math.min;\n    var max = Math.max;\n    var abs = Math.abs;\n    var sqrt = Math.sqrt;\n    var round = Math.round;\n\n    // Utilities\n    var objectProto = Object.prototype;\n    var toString = objectProto.toString;\n    var hasOwnProperty = objectProto.hasOwnProperty;\n    var slice = Array.prototype.slice;\n\n    function typeOf(obj) {\n        return toString.call(obj).slice(8, -1).toLowerCase();\n    }\n\n    function isString(str) {\n        return typeof str === 'string';\n    }\n\n    function isNumber(num) {\n        return typeof num === 'number' && !isNaN(num);\n    }\n\n    function isUndefined(obj) {\n        return typeof obj === 'undefined';\n    }\n\n    function isObject(obj) {\n        return typeof obj === 'object' && obj !== null;\n    }\n\n    function isPlainObject(obj) {\n        var constructor;\n        var prototype;\n\n        if (!isObject(obj)) {\n            return false;\n        }\n\n        try {\n            constructor = obj.constructor;\n            prototype = constructor.prototype;\n\n            return constructor && prototype && hasOwnProperty.call(prototype, 'isPrototypeOf');\n        } catch (e) {\n            return false;\n        }\n    }\n\n    function isFunction(fn) {\n        return typeOf(fn) === 'function';\n    }\n\n    function isArray(arr) {\n        return Array.isArray ? Array.isArray(arr) : typeOf(arr) === 'array';\n    }\n\n    function toArray(obj, offset) {\n        offset = offset >= 0 ? offset : 0;\n\n        if (Array.from) {\n            return Array.from(obj).slice(offset);\n        }\n\n        return slice.call(obj, offset);\n    }\n\n    function inArray(value, arr) {\n        var index = -1;\n\n        if (arr.indexOf) {\n            return arr.indexOf(value);\n        } else {\n            each(arr, function(n, i) {\n                if (n === value) {\n                    index = i;\n                    return false;\n                }\n            });\n        }\n\n        return index;\n    }\n\n    function trim(str) {\n        if (isString(str)) {\n            str = str.trim ? str.trim() : str.replace(REGEXP_TRIM, '1');\n        }\n\n        return str;\n    }\n\n    function each(obj, callback) {\n        var length;\n        var i;\n\n        if (obj && isFunction(callback)) {\n            if (isArray(obj) || isNumber(obj.length) /* array-like */ ) {\n                for (i = 0, length = obj.length; i < length; i++) {\n                    if (callback.call(obj, obj[i], i, obj) === false) {\n                        break;\n                    }\n                }\n            } else if (isObject(obj)) {\n                for (i in obj) {\n                    if (obj.hasOwnProperty(i)) {\n                        if (callback.call(obj, obj[i], i, obj) === false) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        return obj;\n    }\n\n    function extend(obj) {\n        var args;\n\n        if (arguments.length > 1) {\n            args = toArray(arguments);\n\n            if (Object.assign) {\n                return Object.assign.apply(Object, args);\n            }\n\n            args.shift();\n\n            each(args, function(arg) {\n                each(arg, function(prop, i) {\n                    obj[i] = prop;\n                });\n            });\n        }\n\n        return obj;\n    }\n\n    function proxy(fn, context) {\n        var args = toArray(arguments, 2);\n\n        return function() {\n            return fn.apply(context, args.concat(toArray(arguments)));\n        };\n    }\n\n    function setStyle(element, styles) {\n        var style = element.style;\n\n        each(styles, function(value, property) {\n            if (REGEXP_SUFFIX.test(property) && isNumber(value)) {\n                value += 'px';\n            }\n\n            style[property] = value;\n        });\n    }\n\n    function getStyle(element) {\n        return window.getComputedStyle ?\n            window.getComputedStyle(element, null) :\n            element.currentStyle;\n    }\n\n    function hasClass(element, value) {\n        return element.classList ?\n            element.classList.contains(value) :\n            element.className.indexOf(value) > -1;\n    }\n\n    function addClass(element, value) {\n        var className;\n\n        if (!value) {\n            return;\n        }\n\n        if (isNumber(element.length)) {\n            return each(element, function(elem) {\n                addClass(elem, value);\n            });\n        }\n\n        if (element.classList) {\n            return element.classList.add(value);\n        }\n\n        className = trim(element.className);\n\n        if (!className) {\n            element.className = value;\n        } else if (className.indexOf(value) < 0) {\n            element.className = className + ' ' + value;\n        }\n    }\n\n    function removeClass(element, value) {\n        if (!value) {\n            return;\n        }\n\n        if (isNumber(element.length)) {\n            return each(element, function(elem) {\n                removeClass(elem, value);\n            });\n        }\n\n        if (element.classList) {\n            return element.classList.remove(value);\n        }\n\n        if (element.className.indexOf(value) >= 0) {\n            element.className = element.className.replace(value, '');\n        }\n    }\n\n    function toggleClass(element, value, added) {\n        if (isNumber(element.length)) {\n            return each(element, function(elem) {\n                toggleClass(elem, value, added);\n            });\n        }\n\n        // IE10-11 doesn't support the second parameter of `classList.toggle`\n        if (added) {\n            addClass(element, value);\n        } else {\n            removeClass(element, value);\n        }\n    }\n\n    function getData(element, name) {\n        return isObject(element[name]) ?\n            element[name] :\n            element.dataset ?\n            element.dataset[name] :\n            element.getAttribute('data-' + name);\n    }\n\n    function setData(element, name, data) {\n        if (isObject(data) && isUndefined(element[name])) {\n            element[name] = data;\n        } else if (element.dataset) {\n            element.dataset[name] = data;\n        } else {\n            element.setAttribute('data-' + name, data);\n        }\n    }\n\n    function removeData(element, name) {\n        if (isObject(element[name])) {\n            delete element[name];\n        } else if (element.dataset) {\n            delete element.dataset[name];\n        } else {\n            element.removeAttribute('data-' + name);\n        }\n    }\n\n    function addListener(element, type, handler, once) {\n        var types = trim(type).split(REGEXP_SPACES);\n        var originalHandler = handler;\n\n        if (types.length > 1) {\n            return each(types, function(type) {\n                addListener(element, type, handler);\n            });\n        }\n\n        if (once) {\n            handler = function() {\n                removeListener(element, type, handler);\n\n                return originalHandler.apply(element, arguments);\n            };\n        }\n\n        if (element.addEventListener) {\n            element.addEventListener(type, handler, false);\n        } else if (element.attachEvent) {\n            element.attachEvent('on' + type, handler);\n        }\n    }\n\n    function removeListener(element, type, handler) {\n        var types = trim(type).split(REGEXP_SPACES);\n\n        if (types.length > 1) {\n            return each(types, function(type) {\n                removeListener(element, type, handler);\n            });\n        }\n\n        if (element.removeEventListener) {\n            element.removeEventListener(type, handler, false);\n        } else if (element.detachEvent) {\n            element.detachEvent('on' + type, handler);\n        }\n    }\n\n    function dispatchEvent(element, type, data) {\n        var event;\n\n        if (element.dispatchEvent) {\n\n            // Event and CustomEvent on IE9-11 are global objects, not constructors\n            if (isFunction(Event) && isFunction(CustomEvent)) {\n                if (isUndefined(data)) {\n                    event = new Event(type, {\n                        bubbles: true,\n                        cancelable: true\n                    });\n                } else {\n                    event = new CustomEvent(type, {\n                        detail: data,\n                        bubbles: true,\n                        cancelable: true\n                    });\n                }\n            } else {\n                // IE9-11\n                if (isUndefined(data)) {\n                    event = document.createEvent('Event');\n                    event.initEvent(type, true, true);\n                } else {\n                    event = document.createEvent('CustomEvent');\n                    event.initCustomEvent(type, true, true, data);\n                }\n            }\n\n            // IE9+\n            return element.dispatchEvent(event);\n        } else if (element.fireEvent) {\n\n            // IE6-10 (native events only)\n            return element.fireEvent('on' + type);\n        }\n    }\n\n    function preventDefault(e) {\n        if (e.preventDefault) {\n            e.preventDefault();\n        } else {\n            e.returnValue = false;\n        }\n    }\n\n    function getEvent(event) {\n        var e = event || window.event;\n        var doc;\n\n        // Fix target property (IE8)\n        if (!e.target) {\n            e.target = e.srcElement || document;\n        }\n\n        if (!isNumber(e.pageX)) {\n            doc = document.documentElement;\n            e.pageX = e.clientX + (window.scrollX || doc && doc.scrollLeft || 0) - (doc && doc.clientLeft || 0);\n            e.pageY = e.clientY + (window.scrollY || doc && doc.scrollTop || 0) - (doc && doc.clientTop || 0);\n        }\n\n        return e;\n    }\n\n    function getOffset(element) {\n        var doc = document.documentElement;\n        var box = element.getBoundingClientRect();\n\n        return {\n            left: box.left + (window.scrollX || doc && doc.scrollLeft || 0) - (doc && doc.clientLeft || 0),\n            top: box.top + (window.scrollY || doc && doc.scrollTop || 0) - (doc && doc.clientTop || 0)\n        };\n    }\n\n    function getTouchesCenter(touches) {\n        var length = touches.length;\n        var pageX = 0;\n        var pageY = 0;\n\n        if (length) {\n            each(touches, function(touch) {\n                pageX += touch.pageX;\n                pageY += touch.pageY;\n            });\n\n            pageX /= length;\n            pageY /= length;\n        }\n\n        return {\n            pageX: pageX,\n            pageY: pageY\n        };\n    }\n\n    function getByTag(element, tagName) {\n        return element.getElementsByTagName(tagName);\n    }\n\n    function getByClass(element, className) {\n        return element.getElementsByClassName ?\n            element.getElementsByClassName(className) :\n            element.querySelectorAll('.' + className);\n    }\n\n    function appendChild(element, elem) {\n        if (elem.length) {\n            return each(elem, function(el) {\n                appendChild(element, el);\n            });\n        }\n\n        element.appendChild(elem);\n    }\n\n    function removeChild(element) {\n        if (element.parentNode) {\n            element.parentNode.removeChild(element);\n        }\n    }\n\n    function empty(element) {\n        while (element.firstChild) {\n            element.removeChild(element.firstChild);\n        }\n    }\n\n    function setText(element, text) {\n        if (!isUndefined(element.textContent)) {\n            element.textContent = text;\n        } else {\n            element.innerText = text;\n        }\n    }\n\n    // Force reflow to enable CSS3 transition\n    function forceReflow(element) {\n        return element.offsetWidth;\n    }\n\n    // e.g.: http://domain.com/path/to/picture.jpg?size=1280960 -> picture.jpg\n    function getImageName(url) {\n        return isString(url) ? url.replace(/^.*\\//, '').replace(/[\\?&#].*$/, '') : '';\n    }\n\n    function getImageSize(image, callback) {\n        var newImage;\n\n        // Modern browsers\n        if (image.naturalWidth) {\n            return callback(image.naturalWidth, image.naturalHeight);\n        }\n\n        // IE8: Don't use `new Image()` here\n        newImage = document.createElement('img');\n\n        newImage.onload = function() {\n            callback(this.width, this.height);\n        };\n\n        newImage.src = image.src;\n    }\n\n    function getTransform(data) {\n        var transforms = [];\n        var rotate = data.rotate;\n        var scaleX = data.scaleX;\n        var scaleY = data.scaleY;\n\n        if (isNumber(rotate)) {\n            transforms.push('rotate(' + rotate + 'deg)');\n        }\n\n        if (isNumber(scaleX) && isNumber(scaleY)) {\n            transforms.push('scale(' + scaleX + ',' + scaleY + ')');\n        }\n\n        return transforms.length ? transforms.join(' ') : 'none';\n    }\n\n    function getResponsiveClass(option) {\n        switch (option) {\n            case 2:\n                return CLASS_HIDE_XS_DOWN;\n\n            case 3:\n                return CLASS_HIDE_SM_DOWN;\n\n            case 4:\n                return CLASS_HIDE_MD_DOWN;\n        }\n    }\n\n    function Viewer(element, options) {\n        var _this = this;\n\n        _this.element = element;\n        _this.options = extend({}, Viewer.DEFAULTS, isPlainObject(options) && options);\n        _this.isImg = false;\n        _this.isBuilt = false;\n        _this.isShown = false;\n        _this.isViewed = false;\n        _this.isFulled = false;\n        _this.isPlayed = false;\n        _this.wheeling = false;\n        _this.playing = false;\n        _this.fading = false;\n        _this.tooltiping = false;\n        _this.transitioning = false;\n        _this.action = false;\n        _this.target = false;\n        _this.timeout = false;\n        _this.index = 0;\n        _this.length = 0;\n        _this.init();\n    }\n\n    Viewer.prototype = {\n        constructor: Viewer,\n\n        init: function() {\n            var _this = this;\n            var options = _this.options;\n            var element = _this.element;\n            var isImg = element.tagName.toLowerCase() === 'img';\n            var images = isImg ? [element] : getByTag(element, 'img');\n            var length = images.length;\n            var ready = proxy(_this.ready, _this);\n\n            if (getData(element, NAMESPACE)) {\n                return;\n            }\n\n            setData(element, NAMESPACE, _this);\n\n            if (!length) {\n                return;\n            }\n\n            if (isFunction(options.build)) {\n                addListener(element, EVENT_BUILD, options.build, true);\n            }\n\n            if (dispatchEvent(element, EVENT_BUILD) === false) {\n                return;\n            }\n\n            // Override `transition` option if it is not supported\n            if (!SUPPORT_TRANSITION) {\n                options.transition = false;\n            }\n\n            _this.isImg = isImg;\n            _this.length = length;\n            _this.count = 0;\n            _this.images = images;\n            _this.body = document.body;\n\n            if (options.inline) {\n                addListener(element, EVENT_BUILT, function() {\n                    _this.view();\n                }, true);\n\n                each(images, function(image) {\n                    if (image.complete) {\n                        ready();\n                    } else {\n                        addListener(image, EVENT_LOAD, ready, true);\n                    }\n                });\n            } else {\n                addListener(element, EVENT_CLICK, (_this._start = proxy(_this.start, _this)));\n            }\n        },\n\n        ready: function() {\n            var _this = this;\n\n            _this.count++;\n\n            if (_this.count === _this.length) {\n                _this.build();\n            }\n        },\n\n        build: function() {\n            var _this = this;\n            var options = _this.options;\n            var element = _this.element;\n            var template;\n            var parent;\n            var viewer;\n            var button;\n            var toolbar;\n            var navbar;\n            var title;\n            var rotate;\n\n            if (_this.isBuilt) {\n                return;\n            }\n\n            template = document.createElement('div');\n            template.innerHTML = Viewer.TEMPLATE;\n\n            _this.parent = parent = element.parentNode;\n            _this.viewer = viewer = getByClass(template, 'viewer-container')[0];\n            _this.canvas = getByClass(viewer, 'viewer-canvas')[0];\n            _this.footer = getByClass(viewer, 'viewer-footer')[0];\n            _this.title = title = getByClass(viewer, 'viewer-title')[0];\n            _this.toolbar = toolbar = getByClass(viewer, 'viewer-toolbar')[0];\n            _this.navbar = navbar = getByClass(viewer, 'viewer-navbar')[0];\n            _this.button = button = getByClass(viewer, 'viewer-button')[0];\n            _this.tooltipBox = getByClass(viewer, 'viewer-tooltip')[0];\n            _this.player = getByClass(viewer, 'viewer-player')[0];\n            _this.list = getByClass(viewer, 'viewer-list')[0];\n\n\n            addClass(title, !options.title ? CLASS_HIDE : getResponsiveClass(options.title));\n            addClass(toolbar, !options.toolbar ? CLASS_HIDE : getResponsiveClass(options.toolbar));\n            addClass(navbar, !options.navbar ? CLASS_HIDE : getResponsiveClass(options.navbar));\n            toggleClass(button, CLASS_HIDE, !options.button);\n\n            toggleClass(toolbar.querySelectorAll('li[class*=zoom]'), CLASS_INVISIBLE, !options.zoomable);\n            toggleClass(toolbar.querySelectorAll('li[class*=flip]'), CLASS_INVISIBLE, !options.scalable);\n\n            if (!options.rotatable) {\n                rotate = toolbar.querySelectorAll('li[class*=rotate]');\n                addClass(rotate, CLASS_INVISIBLE);\n                appendChild(toolbar, rotate);\n            }\n\n            if (options.inline) {\n                addClass(button, CLASS_FULLSCREEN);\n                setStyle(viewer, {\n                    zIndex: options.zIndexInline\n                });\n\n                if (getStyle(parent).position === 'static') {\n                    setStyle(parent, {\n                        position: 'relative'\n                    });\n                }\n            } else {\n                try {\n                    console.log('button', button);\n                    button.setAttribute('tappable', 'tappable');\n                } catch (ex) { console.log(ex); }\n                addClass(button, CLASS_CLOSE);\n                addClass(viewer, CLASS_FIXED);\n                addClass(viewer, CLASS_FADE);\n                addClass(viewer, CLASS_HIDE);\n\n                setStyle(viewer, {\n                    zIndex: options.zIndex\n                });\n            }\n\n            // Inserts the viewer after to the current element\n            parent.insertBefore(viewer, element.nextSibling);\n\n            if (options.inline) {\n                _this.render();\n                _this.bind();\n                _this.isShown = true;\n            }\n\n            _this.isBuilt = true;\n\n            if (isFunction(options.built)) {\n                addListener(element, EVENT_BUILT, options.built, true);\n            }\n\n            dispatchEvent(element, EVENT_BUILT);\n        },\n\n        unbuild: function() {\n            var _this = this;\n\n            if (!_this.isBuilt) {\n                return;\n            }\n\n            _this.isBuilt = false;\n            removeChild(_this.viewer);\n        },\n\n        bind: function() {\n            var _this = this;\n            var options = _this.options;\n            var element = _this.element;\n            var viewer = _this.viewer;\n\n            if (isFunction(options.view)) {\n                addListener(element, EVENT_VIEW, options.view);\n            }\n\n            if (isFunction(options.viewed)) {\n                addListener(element, EVENT_VIEWED, options.viewed);\n            }\n\n            addListener(viewer, EVENT_CLICK, (_this._click = proxy(_this.click, _this)));\n            addListener(viewer, EVENT_WHEEL, (_this._wheel = proxy(_this.wheel, _this)));\n            addListener(_this.canvas, EVENT_MOUSEDOWN, (_this._mousedown = proxy(_this.mousedown, _this)));\n            addListener(document, EVENT_MOUSEMOVE, (_this._mousemove = proxy(_this.mousemove, _this)));\n            addListener(document, EVENT_MOUSEUP, (_this._mouseup = proxy(_this.mouseup, _this)));\n            addListener(document, EVENT_KEYDOWN, (_this._keydown = proxy(_this.keydown, _this)));\n            addListener(window, EVENT_RESIZE, (_this._resize = proxy(_this.resize, _this)));\n        },\n\n        unbind: function() {\n            var _this = this;\n            var options = _this.options;\n            var element = _this.element;\n            var viewer = _this.viewer;\n\n            if (isFunction(options.view)) {\n                removeListener(element, EVENT_VIEW, options.view);\n            }\n\n            if (isFunction(options.viewed)) {\n                removeListener(element, EVENT_VIEWED, options.viewed);\n            }\n\n            removeListener(viewer, EVENT_CLICK, _this._click);\n            removeListener(viewer, EVENT_WHEEL, _this._wheel);\n            removeListener(_this.canvas, EVENT_MOUSEDOWN, _this._mousedown);\n            removeListener(document, EVENT_MOUSEMOVE, _this._mousemove);\n            removeListener(document, EVENT_MOUSEUP, _this._mouseup);\n            removeListener(document, EVENT_KEYDOWN, _this._keydown);\n            removeListener(window, EVENT_RESIZE, _this._resize);\n        },\n\n        render: function() {\n            var _this = this;\n\n            _this.initContainer();\n            _this.initViewer();\n            _this.initList();\n            _this.renderViewer();\n        },\n\n        initContainer: function() {\n            var _this = this;\n\n            _this.containerData = {\n                width: window.innerWidth,\n                height: window.innerHeight\n            };\n        },\n\n        initViewer: function() {\n            var _this = this;\n            var options = _this.options;\n            var parent = _this.parent;\n            var viewerData;\n\n            if (options.inline) {\n                _this.parentData = viewerData = {\n                    width: max(parent.offsetWidth, options.minWidth),\n                    height: max(parent.offsetHeight, options.minHeight)\n                };\n            }\n\n            if (_this.isFulled || !viewerData) {\n                viewerData = _this.containerData;\n            }\n\n            _this.viewerData = extend({}, viewerData);\n        },\n\n        renderViewer: function() {\n            var _this = this;\n\n            if (_this.options.inline && !_this.isFulled) {\n                setStyle(_this.viewer, _this.viewerData);\n            }\n        },\n\n        initList: function() {\n            var _this = this;\n            var options = _this.options;\n            var element = _this.element;\n            var list = _this.list;\n            var items = [];\n\n            each(_this.images, function(image, i) {\n                var src = image.src;\n                var alt = image.alt || getImageName(src);\n                var url = options.url;\n\n                if (!src) {\n                    return;\n                }\n\n                if (isString(url)) {\n                    url = image.getAttribute(url);\n                } else if (isFunction(url)) {\n                    url = url.call(image, image);\n                }\n\n                items.push(\n                    '<li>' +\n                    '<img' +\n                    ' src=\"' + src + '\"' +\n                    ' data-action=\"view\"' +\n                    ' data-index=\"' + i + '\"' +\n                    ' data-original-url=\"' + (url || src) + '\"' +\n                    ' alt=\"' + alt + '\"' +\n                    '>' +\n                    '</li>'\n                );\n            });\n\n            list.innerHTML = items.join('');\n\n            each(getByTag(list, 'img'), function(image) {\n                setData(image, 'filled', true);\n                addListener(image, EVENT_LOAD, proxy(_this.loadImage, _this), true);\n            });\n\n            _this.items = getByTag(list, 'li');\n\n            if (options.transition) {\n                addListener(element, EVENT_VIEWED, function() {\n                    addClass(list, CLASS_TRANSITION);\n                }, true);\n            }\n        },\n\n        renderList: function(index) {\n            var _this = this;\n            var i = index || _this.index;\n            var width = _this.items[i].offsetWidth || 30;\n            var outerWidth = width + 1; // 1 pixel of `margin-left` width\n\n            // Place the active item in the center of the screen\n            setStyle(_this.list, {\n                width: outerWidth * _this.length,\n                marginLeft: (_this.viewerData.width - width) / 2 - outerWidth * i\n            });\n        },\n\n        resetList: function() {\n            var _this = this;\n\n            empty(_this.list);\n            removeClass(_this.list, CLASS_TRANSITION);\n            setStyle({\n                marginLeft: 0\n            });\n        },\n\n        initImage: function(callback) {\n            var _this = this;\n            var options = _this.options;\n            var image = _this.image;\n            var viewerData = _this.viewerData;\n            var footerHeight = _this.footer.offsetHeight;\n            var viewerWidth = viewerData.width;\n            var viewerHeight = max(viewerData.height - footerHeight, footerHeight);\n            var oldImageData = _this.imageData || {};\n\n            getImageSize(image, function(naturalWidth, naturalHeight) {\n                var aspectRatio = naturalWidth / naturalHeight;\n                var width = viewerWidth;\n                var height = viewerHeight;\n                var initialImageData;\n                var imageData;\n\n                if (viewerHeight * aspectRatio > viewerWidth) {\n                    height = viewerWidth / aspectRatio;\n                } else {\n                    width = viewerHeight * aspectRatio;\n                }\n\n                width = min(width * 0.9, naturalWidth);\n                height = min(height * 0.9, naturalHeight);\n\n                imageData = {\n                    naturalWidth: naturalWidth,\n                    naturalHeight: naturalHeight,\n                    aspectRatio: aspectRatio,\n                    ratio: width / naturalWidth,\n                    width: width,\n                    height: height,\n                    left: (viewerWidth - width) / 2,\n                    top: (viewerHeight - height) / 2\n                };\n\n                initialImageData = extend({}, imageData);\n\n                if (options.rotatable) {\n                    imageData.rotate = oldImageData.rotate || 0;\n                    initialImageData.rotate = 0;\n                }\n\n                if (options.scalable) {\n                    imageData.scaleX = oldImageData.scaleX || 1;\n                    imageData.scaleY = oldImageData.scaleY || 1;\n                    initialImageData.scaleX = 1;\n                    initialImageData.scaleY = 1;\n                }\n\n                _this.imageData = imageData;\n                _this.initialImageData = initialImageData;\n\n                if (isFunction(callback)) {\n                    callback();\n                }\n            });\n        },\n\n        renderImage: function(callback) {\n            var _this = this;\n            var image = _this.image;\n            var imageData = _this.imageData;\n            var transform = getTransform(imageData);\n\n            setStyle(image, {\n                width: imageData.width,\n                height: imageData.height,\n                marginLeft: imageData.left,\n                marginTop: imageData.top,\n                WebkitTransform: transform,\n                msTransform: transform,\n                transform: transform\n            });\n\n            if (isFunction(callback)) {\n                if (_this.transitioning) {\n                    addListener(image, EVENT_TRANSITIONEND, callback, true);\n                } else {\n                    callback();\n                }\n            }\n        },\n\n        resetImage: function() {\n            var _this = this;\n\n            // this.image only defined after viewed\n            if (_this.image) {\n                removeChild(_this.image);\n                _this.image = null;\n            }\n        },\n\n        start: function(event) {\n            var _this = this;\n            var e = getEvent(event);\n            var target = e.target;\n\n            if (target.tagName.toLowerCase() === 'img') {\n                _this.target = target;\n                _this.show();\n            }\n        },\n\n        click: function(event) {\n            var _this = this;\n            var e = getEvent(event);\n            var target = e.target;\n            var action = getData(target, 'action');\n            var imageData = _this.imageData;\n\n            switch (action) {\n                case 'mix':\n                    if (_this.isPlayed) {\n                        _this.stop();\n                    } else {\n                        if (_this.options.inline) {\n                            if (_this.isFulled) {\n                                _this.exit();\n                            } else {\n                                _this.full();\n                            }\n                        } else {\n                            _this.hide();\n                        }\n                    }\n\n                    break;\n\n                case 'view':\n                    _this.view(getData(target, 'index'));\n                    break;\n\n                case 'zoom-in':\n                    _this.zoom(0.1, true);\n                    break;\n\n                case 'zoom-out':\n                    _this.zoom(-0.1, true);\n                    break;\n\n                case 'one-to-one':\n                    _this.toggle();\n                    break;\n\n                case 'reset':\n                    _this.reset();\n                    break;\n\n                case 'prev':\n                    _this.prev();\n                    break;\n\n                case 'play':\n                    _this.play();\n                    break;\n\n                case 'next':\n                    _this.next();\n                    break;\n\n                case 'rotate-left':\n                    _this.rotate(90);\n                    break;\n\n                case 'rotate-right':\n                    _this.rotate(-90);\n                    break;\n\n                case 'flip-horizontal':\n                    _this.scaleX(-imageData.scaleX || -1);\n                    break;\n\n                case 'flip-vertical':\n                    _this.scaleY(-imageData.scaleY || -1);\n                    break;\n\n                default:\n                    if (_this.isPlayed) {\n                        _this.stop();\n                    }\n            }\n        },\n\n        load: function() {\n            var _this = this;\n            var options = _this.options;\n            var image = _this.image;\n            var index = _this.index;\n            var viewerData = _this.viewerData;\n\n            if (_this.timeout) {\n                clearTimeout(_this.timeout);\n                _this.timeout = false;\n            }\n\n            removeClass(image, CLASS_INVISIBLE);\n\n            image.style.cssText = (\n                'width:0;' +\n                'height:0;' +\n                'margin-left:' + viewerData.width / 2 + 'px;' +\n                'margin-top:' + viewerData.height / 2 + 'px;' +\n                'max-width:none!important;' +\n                'visibility:visible;'\n            );\n\n            _this.initImage(function() {\n                toggleClass(image, CLASS_TRANSITION, options.transition);\n                toggleClass(image, CLASS_MOVE, options.movable);\n\n                _this.renderImage(function() {\n                    _this.isViewed = true;\n                    dispatchEvent(_this.element, EVENT_VIEWED, {\n                        originalImage: _this.images[index],\n                        index: index,\n                        image: image\n                    });\n                });\n            });\n        },\n\n        loadImage: function(event) {\n            var e = getEvent(event);\n            var image = e.target;\n            var parent = image.parentNode;\n            var parentWidth = parent.offsetWidth || 30;\n            var parentHeight = parent.offsetHeight || 50;\n            var filled = !!getData(image, 'filled');\n\n            getImageSize(image, function(naturalWidth, naturalHeight) {\n                var aspectRatio = naturalWidth / naturalHeight;\n                var width = parentWidth;\n                var height = parentHeight;\n\n                if (parentHeight * aspectRatio > parentWidth) {\n                    if (filled) {\n                        width = parentHeight * aspectRatio;\n                    } else {\n                        height = parentWidth / aspectRatio;\n                    }\n                } else {\n                    if (filled) {\n                        height = parentWidth / aspectRatio;\n                    } else {\n                        width = parentHeight * aspectRatio;\n                    }\n                }\n\n                setStyle(image, {\n                    width: width,\n                    height: height,\n                    marginLeft: (parentWidth - width) / 2,\n                    marginTop: (parentHeight - height) / 2\n                });\n            });\n        },\n\n        resize: function() {\n            var _this = this;\n\n            _this.initContainer();\n            _this.initViewer();\n            _this.renderViewer();\n            _this.renderList();\n\n            if (_this.isViewed) {\n                _this.initImage(function() {\n                    _this.renderImage();\n                });\n            }\n\n            if (_this.isPlayed) {\n                each(getByTag(_this.player, 'img'), function(image) {\n                    addListener(image, EVENT_LOAD, proxy(_this.loadImage, _this), true);\n                    dispatchEvent(image, EVENT_LOAD);\n                });\n            }\n        },\n\n        wheel: function(event) {\n            var _this = this;\n            var e = getEvent(event);\n            var ratio = Number(_this.options.zoomRatio) || 0.1;\n            var delta = 1;\n\n            if (!_this.isViewed) {\n                return;\n            }\n\n            preventDefault(e);\n\n            // Limit wheel speed to prevent zoom too fast\n            if (_this.wheeling) {\n                return;\n            }\n\n            _this.wheeling = true;\n\n            setTimeout(function() {\n                _this.wheeling = false;\n            }, 50);\n\n            if (e.deltaY) {\n                delta = e.deltaY > 0 ? 1 : -1;\n            } else if (e.wheelDelta) {\n                delta = -e.wheelDelta / 120;\n            } else if (e.detail) {\n                delta = e.detail > 0 ? 1 : -1;\n            }\n\n            _this.zoom(-delta * ratio, true, e);\n        },\n\n        keydown: function(event) {\n            var _this = this;\n            var e = getEvent(event);\n            var options = _this.options;\n            var key = e.keyCode || e.which || e.charCode;\n\n            if (!_this.isFulled || !options.keyboard) {\n                return;\n            }\n\n            switch (key) {\n\n                // (Key: Esc)\n                case 27:\n                    if (_this.isPlayed) {\n                        _this.stop();\n                    } else {\n                        if (options.inline) {\n                            if (_this.isFulled) {\n                                _this.exit();\n                            }\n                        } else {\n                            _this.hide();\n                        }\n                    }\n\n                    break;\n\n                    // (Key: Space)\n                case 32:\n                    if (_this.isPlayed) {\n                        _this.stop();\n                    }\n\n                    break;\n\n                    // View previous (Key: )\n                case 37:\n                    _this.prev();\n                    break;\n\n                    // Zoom in (Key: )\n                case 38:\n\n                    // Prevent scroll on Firefox\n                    preventDefault(e);\n\n                    _this.zoom(options.zoomRatio, true);\n                    break;\n\n                    // View next (Key: )\n                case 39:\n                    _this.next();\n                    break;\n\n                    // Zoom out (Key: )\n                case 40:\n\n                    // Prevent scroll on Firefox\n                    preventDefault(e);\n\n                    _this.zoom(-options.zoomRatio, true);\n                    break;\n\n                    // Zoom out to initial size (Key: Ctrl + 0)\n                case 48:\n                    // Go to next\n\n                    // Zoom in to natural size (Key: Ctrl + 1)\n                case 49:\n                    if (e.ctrlKey || e.shiftKey) {\n                        preventDefault(e);\n                        _this.toggle();\n                    }\n\n                    break;\n\n                    // No default\n            }\n        },\n\n        mousedown: function(event) {\n            var _this = this;\n            var options = _this.options;\n            var e = getEvent(event);\n            var action = options.movable ? 'move' : false;\n            var touches = e.touches;\n            var touchesLength;\n            var touch;\n\n            if (!_this.isViewed) {\n                return;\n            }\n\n            if (touches) {\n                touchesLength = touches.length;\n\n                if (touchesLength > 1) {\n                    if (options.zoomable && touchesLength === 2) {\n                        touch = touches[1];\n                        _this.startX2 = touch.pageX;\n                        _this.startY2 = touch.pageY;\n                        action = 'zoom';\n                    } else {\n                        return;\n                    }\n                } else {\n                    if (_this.isSwitchable()) {\n                        action = 'switch';\n                    }\n                }\n\n                touch = touches[0];\n            }\n\n            if (action) {\n                preventDefault(e);\n                _this.action = action;\n                _this.startX = touch ? touch.pageX : e.pageX;\n                _this.startY = touch ? touch.pageY : e.pageY;\n            }\n        },\n\n        mousemove: function(event) {\n            var _this = this;\n            var options = _this.options;\n            var e = getEvent(event);\n            var action = _this.action;\n            var image = _this.image;\n            var touches = e.touches;\n            var touchesLength;\n            var touch;\n\n            if (!_this.isViewed) {\n                return;\n            }\n\n            if (touches) {\n                touchesLength = touches.length;\n\n                if (touchesLength > 1) {\n                    if (options.zoomable && touchesLength === 2) {\n                        touch = touches[1];\n                        _this.endX2 = touch.pageX;\n                        _this.endY2 = touch.pageY;\n                    } else {\n                        return;\n                    }\n                }\n\n                touch = touches[0];\n            }\n\n            if (action) {\n                preventDefault(e);\n\n                if (action === 'move' && options.transition && hasClass(image, CLASS_TRANSITION)) {\n                    removeClass(image, CLASS_TRANSITION);\n                }\n\n                _this.endX = touch ? touch.pageX : e.pageX;\n                _this.endY = touch ? touch.pageY : e.pageY;\n\n                _this.change(e);\n            }\n        },\n\n        mouseup: function(event) {\n            var _this = this;\n            var e = getEvent(event);\n            var action = _this.action;\n\n            if (action) {\n                preventDefault(e);\n\n                if (action === 'move' && _this.options.transition) {\n                    addClass(_this.image, CLASS_TRANSITION);\n                }\n\n                _this.action = false;\n            }\n        },\n\n        // Show the viewer (only available in modal mode)\n        show: function() {\n            var _this = this;\n            var options = _this.options;\n            var element = _this.element;\n            var viewer;\n\n            if (options.inline || _this.transitioning) {\n                return _this;\n            }\n\n            if (!_this.isBuilt) {\n                _this.build();\n            }\n\n            viewer = _this.viewer;\n\n            if (isFunction(options.show)) {\n                addListener(element, EVENT_SHOW, options.show, true);\n            }\n\n            if (dispatchEvent(element, EVENT_SHOW) === false) {\n                return _this;\n            }\n\n            addClass(_this.body, CLASS_OPEN);\n            removeClass(viewer, CLASS_HIDE);\n\n            addListener(element, EVENT_SHOWN, function() {\n                _this.view(_this.target ? inArray(_this.target, toArray(_this.images)) : _this.index);\n                _this.target = false;\n            }, true);\n\n            if (options.transition) {\n                _this.transitioning = true;\n                addClass(viewer, CLASS_TRANSITION);\n                forceReflow(viewer);\n                addListener(viewer, EVENT_TRANSITIONEND, proxy(_this.shown, _this), true);\n                addClass(viewer, CLASS_IN);\n            } else {\n                addClass(viewer, CLASS_IN);\n                _this.shown();\n            }\n\n            return _this;\n        },\n\n        // Hide the viewer (only available in modal mode)\n        hide: function() {\n            var _this = this;\n            var options = _this.options;\n            var element = _this.element;\n            var viewer = _this.viewer;\n\n            if (options.inline || _this.transitioning || !_this.isShown) {\n                return _this;\n            }\n\n            if (isFunction(options.hide)) {\n                addListener(element, EVENT_HIDE, options.hide, true);\n            }\n\n            if (dispatchEvent(element, EVENT_HIDE) === false) {\n                return _this;\n            }\n\n            if (_this.isViewed && options.transition) {\n                _this.transitioning = true;\n                addListener(_this.image, EVENT_TRANSITIONEND, function() {\n                    addListener(viewer, EVENT_TRANSITIONEND, proxy(_this.hidden, _this), true);\n                    removeClass(viewer, CLASS_IN);\n                }, true);\n                _this.zoomTo(0, false, false, true);\n            } else {\n                removeClass(viewer, CLASS_IN);\n                _this.hidden();\n            }\n\n            return _this;\n        },\n\n        /**\n         * View one of the images with image's index\n         *\n         * @param {Number} index\n         */\n        view: function(index) {\n            var _this = this;\n            var element = _this.element;\n            var title = _this.title;\n            var canvas = _this.canvas;\n            var image;\n            var item;\n            var img;\n            var url;\n            var alt;\n\n            index = Number(index) || 0;\n\n            if (!_this.isShown || _this.isPlayed || index < 0 || index >= _this.length ||\n                _this.isViewed && index === _this.index) {\n                return _this;\n            }\n\n            item = _this.items[index];\n            img = getByTag(item, 'img')[0];\n            url = getData(img, 'originalUrl');\n            alt = img.getAttribute('alt');\n\n            image = document.createElement('img');\n            image.src = url;\n            image.alt = alt;\n\n            if (dispatchEvent(element, EVENT_VIEW, {\n                    originalImage: _this.images[index],\n                    index: index,\n                    image: image\n                }) === false) {\n                return _this;\n            }\n\n            _this.image = image;\n\n            if (_this.isViewed) {\n                removeClass(_this.items[_this.index], CLASS_ACTIVE);\n            }\n\n            addClass(item, CLASS_ACTIVE);\n\n            _this.isViewed = false;\n            _this.index = index;\n            _this.imageData = null;\n\n            addClass(image, CLASS_INVISIBLE);\n            empty(canvas);\n            appendChild(canvas, image);\n\n            // Center current item\n            _this.renderList();\n\n            // Clear title\n            empty(title);\n\n            // Generate title after viewed\n            addListener(element, EVENT_VIEWED, function() {\n                var imageData = _this.imageData;\n                var width = imageData.naturalWidth;\n                var height = imageData.naturalHeight;\n\n                // 2016/12/23  Begin\n                // setText(title, alt + ' (' + width + '  ' + height + ')');\n                setText(title, alt);\n                // 2016/12/23  End\n            }, true);\n\n            if (image.complete) {\n                _this.load();\n            } else {\n                addListener(image, EVENT_LOAD, proxy(_this.load, _this), true);\n\n                if (_this.timeout) {\n                    clearTimeout(_this.timeout);\n                }\n\n                // Make the image visible if it fails to load within 1s\n                _this.timeout = setTimeout(function() {\n                    removeClass(image, CLASS_INVISIBLE);\n                    _this.timeout = false;\n                }, 1000);\n            }\n\n            return _this;\n        },\n\n        // View the previous image\n        prev: function() {\n            var _this = this;\n\n            _this.view(max(_this.index - 1, 0));\n\n            return _this;\n        },\n\n        // View the next image\n        next: function() {\n            var _this = this;\n\n            _this.view(min(_this.index + 1, _this.length - 1));\n\n            return _this;\n        },\n\n        /**\n         * Move the image with relative offsets\n         *\n         * @param {Number} offsetX\n         * @param {Number} offsetY (optional)\n         */\n        move: function(offsetX, offsetY) {\n            var _this = this;\n            var imageData = _this.imageData;\n\n            _this.moveTo(\n                isUndefined(offsetX) ? offsetX : imageData.left + Number(offsetX),\n                isUndefined(offsetY) ? offsetY : imageData.top + Number(offsetY)\n            );\n\n            return _this;\n        },\n\n        /**\n         * Move the image to an absolute point\n         *\n         * @param {Number} x\n         * @param {Number} y (optional)\n         */\n        moveTo: function(x, y) {\n            var _this = this;\n            var imageData = _this.imageData;\n            var changed = false;\n\n            // If \"y\" is not present, its default value is \"x\"\n            if (isUndefined(y)) {\n                y = x;\n            }\n\n            x = Number(x);\n            y = Number(y);\n\n            if (_this.isViewed && !_this.isPlayed && _this.options.movable) {\n                if (isNumber(x)) {\n                    imageData.left = x;\n                    changed = true;\n                }\n\n                if (isNumber(y)) {\n                    imageData.top = y;\n                    changed = true;\n                }\n\n                if (changed) {\n                    _this.renderImage();\n                }\n            }\n\n            return _this;\n        },\n\n        /**\n         * Zoom the image with a relative ratio\n         *\n         * @param {Number} ratio\n         * @param {Boolean} hasTooltip (optional)\n         * @param {Event} _originalEvent (private)\n         */\n        zoom: function(ratio, hasTooltip, _originalEvent) {\n            var _this = this;\n            var imageData = _this.imageData;\n\n            ratio = Number(ratio);\n\n            if (ratio < 0) {\n                ratio = 1 / (1 - ratio);\n            } else {\n                ratio = 1 + ratio;\n            }\n\n            _this.zoomTo(imageData.width * ratio / imageData.naturalWidth, hasTooltip, _originalEvent);\n\n            return _this;\n        },\n\n        /**\n         * Zoom the image to an absolute ratio\n         *\n         * @param {Number} ratio\n         * @param {Boolean} hasTooltip (optional)\n         * @param {Event} _originalEvent (private)\n         * @param {Boolean} _zoomable (private)\n         */\n        zoomTo: function(ratio, hasTooltip, _originalEvent, _zoomable) {\n            var _this = this;\n            var options = _this.options;\n            var minZoomRatio = 0.01;\n            var maxZoomRatio = 100;\n            var imageData = _this.imageData;\n            var newWidth;\n            var newHeight;\n            var offset;\n            var center;\n\n            ratio = max(0, ratio);\n\n            if (isNumber(ratio) && _this.isViewed && !_this.isPlayed && (_zoomable || options.zoomable)) {\n                if (!_zoomable) {\n                    minZoomRatio = max(minZoomRatio, options.minZoomRatio);\n                    maxZoomRatio = min(maxZoomRatio, options.maxZoomRatio);\n                    ratio = min(max(ratio, minZoomRatio), maxZoomRatio);\n                }\n\n                if (ratio > 0.95 && ratio < 1.05) {\n                    ratio = 1;\n                }\n\n                newWidth = imageData.naturalWidth * ratio;\n                newHeight = imageData.naturalHeight * ratio;\n\n                if (_originalEvent) {\n                    offset = getOffset(_this.viewer);\n                    center = _originalEvent.touches ? getTouchesCenter(_originalEvent.touches) : {\n                        pageX: _originalEvent.pageX,\n                        pageY: _originalEvent.pageY\n                    };\n\n                    // Zoom from the triggering point of the event\n                    imageData.left -= (newWidth - imageData.width) * (\n                        ((center.pageX - offset.left) - imageData.left) / imageData.width\n                    );\n                    imageData.top -= (newHeight - imageData.height) * (\n                        ((center.pageY - offset.top) - imageData.top) / imageData.height\n                    );\n                } else {\n\n                    // Zoom from the center of the image\n                    imageData.left -= (newWidth - imageData.width) / 2;\n                    imageData.top -= (newHeight - imageData.height) / 2;\n                }\n\n                imageData.width = newWidth;\n                imageData.height = newHeight;\n                imageData.ratio = ratio;\n                _this.renderImage();\n\n                if (hasTooltip) {\n                    _this.tooltip();\n                }\n            }\n\n            return _this;\n        },\n\n        /**\n         * Rotate the image with a relative degree\n         *\n         * @param {Number} degree\n         */\n        rotate: function(degree) {\n            var _this = this;\n\n            _this.rotateTo((_this.imageData.rotate || 0) + Number(degree));\n\n            return _this;\n        },\n\n        /**\n         * Rotate the image to an absolute degree\n         * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function#rotate()\n         *\n         * @param {Number} degree\n         */\n        rotateTo: function(degree) {\n            var _this = this;\n            var imageData = _this.imageData;\n\n            degree = Number(degree);\n\n            if (isNumber(degree) && _this.isViewed && !_this.isPlayed && _this.options.rotatable) {\n                imageData.rotate = degree;\n                _this.renderImage();\n            }\n\n            return _this;\n        },\n\n        /**\n         * Scale the image\n         * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function#scale()\n         *\n         * @param {Number} scaleX\n         * @param {Number} scaleY (optional)\n         */\n        scale: function(scaleX, scaleY) {\n            var _this = this;\n            var imageData = _this.imageData;\n            var changed = false;\n\n            // If \"scaleY\" is not present, its default value is \"scaleX\"\n            if (isUndefined(scaleY)) {\n                scaleY = scaleX;\n            }\n\n            scaleX = Number(scaleX);\n            scaleY = Number(scaleY);\n\n            if (_this.isViewed && !_this.isPlayed && _this.options.scalable) {\n                if (isNumber(scaleX)) {\n                    imageData.scaleX = scaleX;\n                    changed = true;\n                }\n\n                if (isNumber(scaleY)) {\n                    imageData.scaleY = scaleY;\n                    changed = true;\n                }\n\n                if (changed) {\n                    _this.renderImage();\n                }\n            }\n\n            return _this;\n        },\n\n        /**\n         * Scale the abscissa of the image\n         *\n         * @param {Number} scaleX\n         */\n        scaleX: function(scaleX) {\n            var _this = this;\n\n            _this.scale(scaleX, _this.imageData.scaleY);\n\n            return _this;\n        },\n\n        /**\n         * Scale the ordinate of the image\n         *\n         * @param {Number} scaleY\n         */\n        scaleY: function(scaleY) {\n            var _this = this;\n\n            _this.scale(_this.imageData.scaleX, scaleY);\n\n            return _this;\n        },\n\n        // Play the images\n        play: function() {\n            var _this = this;\n            var options = _this.options;\n            var player = _this.player;\n            var load = proxy(_this.loadImage, _this);\n            var list = [];\n            var total = 0;\n            var index = 0;\n            var playing;\n\n            if (!_this.isShown || _this.isPlayed) {\n                return _this;\n            }\n\n            if (options.fullscreen) {\n                _this.requestFullscreen();\n            }\n\n            _this.isPlayed = true;\n            addClass(player, CLASS_SHOW);\n\n            each(_this.items, function(item, i) {\n                var img = getByTag(item, 'img')[0];\n                var image = document.createElement('img');\n\n                image.src = getData(img, 'originalUrl');\n                image.alt = img.getAttribute('alt');\n                total++;\n\n                addClass(image, CLASS_FADE);\n                toggleClass(image, CLASS_TRANSITION, options.transition);\n\n                if (hasClass(item, CLASS_ACTIVE)) {\n                    addClass(image, CLASS_IN);\n                    index = i;\n                }\n\n                list.push(image);\n                addListener(image, EVENT_LOAD, load, true);\n                appendChild(player, image);\n            });\n\n            if (isNumber(options.interval) && options.interval > 0) {\n                playing = function() {\n                    _this.playing = setTimeout(function() {\n                        removeClass(list[index], CLASS_IN);\n                        index++;\n                        index = index < total ? index : 0;\n                        addClass(list[index], CLASS_IN);\n\n                        playing();\n                    }, options.interval);\n                };\n\n                if (total > 1) {\n                    playing();\n                }\n            }\n\n            return _this;\n        },\n\n        // Stop play\n        stop: function() {\n            var _this = this;\n            var player = _this.player;\n\n            if (!_this.isPlayed) {\n                return _this;\n            }\n\n            if (_this.options.fullscreen) {\n                _this.exitFullscreen();\n            }\n\n            _this.isPlayed = false;\n            clearTimeout(_this.playing);\n            removeClass(player, CLASS_SHOW);\n            empty(player);\n\n            return _this;\n        },\n\n        // Enter modal mode (only available in inline mode)\n        full: function() {\n            var _this = this;\n            var options = _this.options;\n            var viewer = _this.viewer;\n            var image = _this.image;\n            var list = _this.list;\n\n            if (!_this.isShown || _this.isPlayed || _this.isFulled || !options.inline) {\n                return _this;\n            }\n\n            _this.isFulled = true;\n            addClass(_this.body, CLASS_OPEN);\n            addClass(_this.button, CLASS_FULLSCREEN_EXIT);\n\n            if (options.transition) {\n                removeClass(image, CLASS_TRANSITION);\n                removeClass(list, CLASS_TRANSITION);\n            }\n\n            addClass(viewer, CLASS_FIXED);\n            viewer.setAttribute('style', '');\n            setStyle(viewer, {\n                zIndex: options.zIndex\n            });\n\n            _this.initContainer();\n            _this.viewerData = extend({}, _this.containerData);\n            _this.renderList();\n            _this.initImage(function() {\n                _this.renderImage(function() {\n                    if (options.transition) {\n                        setTimeout(function() {\n                            addClass(image, CLASS_TRANSITION);\n                            addClass(list, CLASS_TRANSITION);\n                        }, 0);\n                    }\n                });\n            });\n\n            return _this;\n        },\n\n        // Exit modal mode (only available in inline mode)\n        exit: function() {\n            var _this = this;\n            var options = _this.options;\n            var viewer = _this.viewer;\n            var image = _this.image;\n            var list = _this.list;\n\n            if (!_this.isFulled) {\n                return _this;\n            }\n\n            _this.isFulled = false;\n            removeClass(_this.body, CLASS_OPEN);\n            removeClass(_this.button, CLASS_FULLSCREEN_EXIT);\n\n            if (options.transition) {\n                removeClass(image, CLASS_TRANSITION);\n                removeClass(list, CLASS_TRANSITION);\n            }\n\n            removeClass(viewer, CLASS_FIXED);\n            setStyle(viewer, {\n                zIndex: options.zIndexInline\n            });\n\n            _this.viewerData = extend({}, _this.parentData);\n            _this.renderViewer();\n            _this.renderList();\n            _this.initImage(function() {\n                _this.renderImage(function() {\n                    if (options.transition) {\n                        setTimeout(function() {\n                            addClass(image, CLASS_TRANSITION);\n                            addClass(list, CLASS_TRANSITION);\n                        }, 0);\n                    }\n                });\n            });\n\n            return _this;\n        },\n\n        // Show the current ratio of the image with percentage\n        tooltip: function() {\n            var _this = this;\n            var options = _this.options;\n            var tooltipBox = _this.tooltipBox;\n            var imageData = _this.imageData;\n\n            if (!_this.isViewed || _this.isPlayed || !options.tooltip) {\n                return _this;\n            }\n\n            setText(tooltipBox, round(imageData.ratio * 100) + '%');\n\n            if (!_this.tooltiping) {\n                if (options.transition) {\n                    if (_this.fading) {\n                        dispatchEvent(tooltipBox, EVENT_TRANSITIONEND);\n                    }\n\n                    addClass(tooltipBox, CLASS_SHOW);\n                    addClass(tooltipBox, CLASS_FADE);\n                    addClass(tooltipBox, CLASS_TRANSITION);\n                    forceReflow(tooltipBox);\n                    addClass(tooltipBox, CLASS_IN);\n                } else {\n                    addClass(tooltipBox, CLASS_SHOW);\n                }\n            } else {\n                clearTimeout(_this.tooltiping);\n            }\n\n            _this.tooltiping = setTimeout(function() {\n                if (options.transition) {\n                    addListener(tooltipBox, EVENT_TRANSITIONEND, function() {\n                        removeClass(tooltipBox, CLASS_SHOW);\n                        removeClass(tooltipBox, CLASS_FADE);\n                        removeClass(tooltipBox, CLASS_TRANSITION);\n                        _this.fading = false;\n                    }, true);\n\n                    removeClass(tooltipBox, CLASS_IN);\n                    _this.fading = true;\n                } else {\n                    removeClass(tooltipBox, CLASS_SHOW);\n                }\n\n                _this.tooltiping = false;\n            }, 1000);\n\n            return _this;\n        },\n\n        // Toggle the image size between its natural size and initial size\n        toggle: function() {\n            var _this = this;\n\n            if (_this.imageData.ratio === 1) {\n                _this.zoomTo(_this.initialImageData.ratio, true);\n            } else {\n                _this.zoomTo(1, true);\n            }\n\n            return _this;\n        },\n\n        // Reset the image to its initial state\n        reset: function() {\n            var _this = this;\n\n            if (_this.isViewed && !_this.isPlayed) {\n                _this.imageData = extend({}, _this.initialImageData);\n                _this.renderImage();\n            }\n\n            return _this;\n        },\n\n        // Update viewer when images changed\n        update: function() {\n            var _this = this;\n            var indexes = [];\n            var index;\n\n            // Destroy viewer if the target image was deleted\n            if (_this.isImg && !_this.element.parentNode) {\n                return _this.destroy();\n            }\n\n            _this.length = _this.images.length;\n\n            if (_this.isBuilt) {\n                each(_this.items, function(item, i) {\n                    var img = getByTag(item, 'img')[0];\n                    var image = _this.images[i];\n\n                    if (image) {\n                        if (image.src !== img.src) {\n                            indexes.push(i);\n                        }\n                    } else {\n                        indexes.push(i);\n                    }\n                });\n\n                setStyle(_this.list, {\n                    width: 'auto'\n                });\n\n                _this.initList();\n\n                if (_this.isShown) {\n                    if (_this.length) {\n                        if (_this.isViewed) {\n                            index = inArray(_this.index, indexes);\n\n                            if (index >= 0) {\n                                _this.isViewed = false;\n                                _this.view(max(_this.index - (index + 1), 0));\n                            } else {\n                                addClass(_this.items[_this.index], CLASS_ACTIVE);\n                            }\n                        }\n                    } else {\n                        _this.image = null;\n                        _this.isViewed = false;\n                        _this.index = 0;\n                        _this.imageData = null;\n                        empty(_this.canvas);\n                        empty(_this.title);\n                    }\n                }\n            }\n\n            return _this;\n        },\n\n        // Destroy the viewer\n        destroy: function() {\n            var _this = this;\n            var element = _this.element;\n\n            if (_this.options.inline) {\n                _this.unbind();\n            } else {\n                if (_this.isShown) {\n                    _this.unbind();\n                }\n\n                removeListener(element, EVENT_CLICK, _this._start);\n            }\n\n            _this.unbuild();\n            removeData(element, NAMESPACE);\n\n            return _this;\n        },\n\n        shown: function() {\n            var _this = this;\n            var options = _this.options;\n            var element = _this.element;\n\n            _this.transitioning = false;\n            _this.isFulled = true;\n            _this.isShown = true;\n            _this.isVisible = true;\n            _this.render();\n            _this.bind();\n\n            if (isFunction(options.shown)) {\n                addListener(element, EVENT_SHOWN, options.shown, true);\n            }\n\n            dispatchEvent(element, EVENT_SHOWN);\n        },\n\n        hidden: function() {\n            var _this = this;\n            var options = _this.options;\n            var element = _this.element;\n\n            _this.transitioning = false;\n            _this.isViewed = false;\n            _this.isFulled = false;\n            _this.isShown = false;\n            _this.isVisible = false;\n            _this.unbind();\n            removeClass(_this.body, CLASS_OPEN);\n            addClass(_this.viewer, CLASS_HIDE);\n            _this.resetList();\n            _this.resetImage();\n\n            if (isFunction(options.hidden)) {\n                addListener(element, EVENT_HIDDEN, options.hidden, true);\n            }\n\n            dispatchEvent(element, EVENT_HIDDEN);\n        },\n\n        requestFullscreen: function() {\n            var _this = this;\n            var documentElement = document.documentElement;\n\n            if (_this.isFulled && !document.fullscreenElement && !document.mozFullScreenElement &&\n                !document.webkitFullscreenElement && !document.msFullscreenElement) {\n\n                if (documentElement.requestFullscreen) {\n                    documentElement.requestFullscreen();\n                } else if (documentElement.msRequestFullscreen) {\n                    documentElement.msRequestFullscreen();\n                } else if (documentElement.mozRequestFullScreen) {\n                    documentElement.mozRequestFullScreen();\n                } else if (documentElement.webkitRequestFullscreen) {\n                    documentElement.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);\n                }\n            }\n        },\n\n        exitFullscreen: function() {\n            var _this = this;\n\n            if (_this.isFulled) {\n                if (document.exitFullscreen) {\n                    document.exitFullscreen();\n                } else if (document.msExitFullscreen) {\n                    document.msExitFullscreen();\n                } else if (document.mozCancelFullScreen) {\n                    document.mozCancelFullScreen();\n                } else if (document.webkitExitFullscreen) {\n                    document.webkitExitFullscreen();\n                }\n            }\n        },\n\n        change: function(originalEvent) {\n            var _this = this;\n            var offsetX = _this.endX - _this.startX;\n            var offsetY = _this.endY - _this.startY;\n\n            switch (_this.action) {\n\n                // Move the current image\n                case 'move':\n                    _this.move(offsetX, offsetY);\n                    break;\n\n                    // Zoom the current image\n                case 'zoom':\n                    _this.zoom(function(x1, y1, x2, y2) {\n                        var z1 = sqrt(x1 * x1 + y1 * y1);\n                        var z2 = sqrt(x2 * x2 + y2 * y2);\n\n                        return (z2 - z1) / z1;\n                    }(\n                        abs(_this.startX - _this.startX2),\n                        abs(_this.startY - _this.startY2),\n                        abs(_this.endX - _this.endX2),\n                        abs(_this.endY - _this.endY2)\n                    ), false, originalEvent);\n\n                    _this.startX2 = _this.endX2;\n                    _this.startY2 = _this.endY2;\n                    break;\n\n                case 'switch':\n                    _this.action = 'switched';\n\n                    if (abs(offsetX) > abs(offsetY)) {\n                        if (offsetX > 1) {\n                            _this.prev();\n                        } else if (offsetX < -1) {\n                            _this.next();\n                        }\n                    }\n\n                    break;\n\n                    // No default\n            }\n\n            // Override\n            _this.startX = _this.endX;\n            _this.startY = _this.endY;\n        },\n\n        isSwitchable: function() {\n            var _this = this;\n            var imageData = _this.imageData;\n            var viewerData = _this.viewerData;\n\n            return imageData.left >= 0 && imageData.top >= 0 &&\n                imageData.width <= viewerData.width &&\n                imageData.height <= viewerData.height;\n        }\n    };\n\n    Viewer.DEFAULTS = {\n\n        // Enable inline mode\n        inline: false,\n\n        // Show the button on the top-right of the viewer\n        button: true,\n\n        // Show the navbar\n        navbar: true,\n\n        // Show the title\n        title: true,\n\n        // Show the toolbar\n        toolbar: true,\n\n        // Show the tooltip with image ratio (percentage) when zoom in or zoom out\n        tooltip: true,\n\n        // Enable to move the image\n        movable: true,\n\n        // Enable to zoom the image\n        zoomable: true,\n\n        // Enable to rotate the image\n        rotatable: true,\n\n        // Enable to scale the image\n        scalable: true,\n\n        // Enable CSS3 Transition for some special elements\n        transition: true,\n\n        // Enable to request fullscreen when play\n        fullscreen: true,\n\n        // Enable keyboard support\n        keyboard: true,\n\n        // Define interval of each image when playing\n        interval: 5000,\n\n        // Min width of the viewer in inline mode\n        minWidth: 200,\n\n        // Min height of the viewer in inline mode\n        minHeight: 100,\n\n        // Define the ratio when zoom the image by wheeling mouse\n        zoomRatio: 0.1,\n\n        // Define the min ratio of the image when zoom out\n        minZoomRatio: 0.01,\n\n        // Define the max ratio of the image when zoom in\n        maxZoomRatio: 100,\n\n        // Define the CSS `z-index` value of viewer in modal mode.\n        zIndex: 2015,\n\n        // Define the CSS `z-index` value of viewer in inline mode.\n        zIndexInline: 0,\n\n        // Define where to get the original image URL for viewing\n        // Type: String (an image attribute) or Function (should return an image URL)\n        url: 'src',\n\n        // Event shortcuts\n        build: null,\n        built: null,\n        show: null,\n        shown: null,\n        hide: null,\n        hidden: null,\n        view: null,\n        viewed: null\n    };\n\n    Viewer.TEMPLATE = (\n        '<div class=\"viewer-container\">' +\n        '<div class=\"viewer-canvas\"></div>' +\n        '<div class=\"viewer-footer\">' +\n        '<div class=\"viewer-title\"></div>' +\n        '<ul class=\"viewer-toolbar\">' +\n        // /* 2016/12/23 Begin */\n        // // '<li class=\"viewer-zoom-in\" data-action=\"zoom-in\"></li>' +\n        // // '<li class=\"viewer-zoom-out\" data-action=\"zoom-out\"></li>' +\n        // '<li class=\"viewer-one-to-one\" data-action=\"one-to-one\"></li>' +\n        // '<li class=\"viewer-reset\" data-action=\"reset\"></li>' +\n        // '<li class=\"viewer-prev\" data-action=\"prev\"></li>' +\n        // '<li class=\"viewer-play\" data-action=\"play\"></li>' +\n        // '<li class=\"viewer-next\" data-action=\"next\"></li>' +\n        /* 2016/12/23 Begin */\n        '<li tappable class=\"viewer-rotate-right\" data-action=\"rotate-left\"></li>' +\n        /* 2016/12/23 Begin */\n        // '<li class=\"viewer-rotate-left\" data-action=\"rotate-left\"></li>' +\n        // '<li class=\"viewer-rotate-right\" data-action=\"rotate-right\"></li>' +\n        // '<li class=\"viewer-flip-horizontal\" data-action=\"flip-horizontal\"></li>' +\n        // '<li class=\"viewer-flip-vertical\" data-action=\"flip-vertical\"></li>' +\n        /* 2016/12/23 End */\n        '</ul>' +\n        '<div class=\"viewer-navbar\">' +\n        '<ul class=\"viewer-list\"></ul>' +\n        '</div>' +\n        '</div>' +\n        '<div class=\"viewer-tooltip\"></div>' +\n        '<div class=\"viewer-button\" data-action=\"mix\"></div>' +\n        '<div class=\"viewer-player\"></div>' +\n        '</div>'\n    );\n\n    var _Viewer = window.Viewer;\n\n    Viewer.noConflict = function() {\n        window.Viewer = _Viewer;\n        return Viewer;\n    };\n\n    Viewer.setDefaults = function(options) {\n        extend(Viewer.DEFAULTS, options);\n    };\n\n    if (typeof define === 'function' && define.amd) {\n        define('viewer', [], function() {\n            return Viewer;\n        });\n    }\n\n    if (!noGlobal) {\n        window.Viewer = Viewer;\n    }\n\n    return Viewer;\n\n});\n"},1794:function(e,n,t){t(904),t(906),t(903),t(905),e.exports=t(902)},244:function(e,n){e.exports=function(e){"undefined"!=typeof execScript?execScript(e):eval.call(null,e)}},902:function(e,n,t){t(244)(t(1478))},903:function(e,n,t){t(244)(t(1479))},904:function(e,n,t){t(244)(t(1480))},905:function(e,n,t){t(244)(t(1481))},906:function(e,n,t){t(244)(t(1482))}},[1794]);